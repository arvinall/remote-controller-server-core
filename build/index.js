(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/async-limiter/index.js":
/*!**********************************************!*\
  !*** ../node_modules/async-limiter/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction Queue(options) {\n  if (!(this instanceof Queue)) {\n    return new Queue(options);\n  }\n\n  options = options || {};\n  this.concurrency = options.concurrency || Infinity;\n  this.pending = 0;\n  this.jobs = [];\n  this.cbs = [];\n  this._done = done.bind(this);\n}\n\nvar arrayAddMethods = [\n  'push',\n  'unshift',\n  'splice'\n];\n\narrayAddMethods.forEach(function(method) {\n  Queue.prototype[method] = function() {\n    var methodResult = Array.prototype[method].apply(this.jobs, arguments);\n    this._run();\n    return methodResult;\n  };\n});\n\nObject.defineProperty(Queue.prototype, 'length', {\n  get: function() {\n    return this.pending + this.jobs.length;\n  }\n});\n\nQueue.prototype._run = function() {\n  if (this.pending === this.concurrency) {\n    return;\n  }\n  if (this.jobs.length) {\n    var job = this.jobs.shift();\n    this.pending++;\n    job(this._done);\n    this._run();\n  }\n\n  if (this.pending === 0) {\n    while (this.cbs.length !== 0) {\n      var cb = this.cbs.pop();\n      process.nextTick(cb);\n    }\n  }\n};\n\nQueue.prototype.onDone = function(cb) {\n  if (typeof cb === 'function') {\n    this.cbs.push(cb);\n    this._run();\n  }\n};\n\nfunction done() {\n  this.pending--;\n  this._run();\n}\n\nmodule.exports = Queue;\n\n\n//# sourceURL=node_modules/async-limiter/index.js");

/***/ }),

/***/ "../node_modules/balanced-match/index.js":
/*!***********************************************!*\
  !*** ../node_modules/balanced-match/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n\n\n//# sourceURL=node_modules/balanced-match/index.js");

/***/ }),

/***/ "../node_modules/brace-expansion/index.js":
/*!************************************************!*\
  !*** ../node_modules/brace-expansion/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var concatMap = __webpack_require__(/*! concat-map */ \"../node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"../node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n\n\n//# sourceURL=node_modules/brace-expansion/index.js");

/***/ }),

/***/ "../node_modules/bufferutil/fallback.js":
/*!**********************************************!*\
  !*** ../node_modules/bufferutil/fallback.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nconst mask = (source, mask, output, offset, length) => {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n};\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nconst unmask = (buffer, mask) => {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n};\n\nmodule.exports = { mask, unmask };\n\n\n//# sourceURL=node_modules/bufferutil/fallback.js");

/***/ }),

/***/ "../node_modules/bufferutil/index.js":
/*!*******************************************!*\
  !*** ../node_modules/bufferutil/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"../node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"../node_modules/bufferutil/fallback.js\");\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=node_modules/bufferutil/index.js");

/***/ }),

/***/ "../node_modules/concat-map/index.js":
/*!*******************************************!*\
  !*** ../node_modules/concat-map/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n//# sourceURL=node_modules/concat-map/index.js");

/***/ }),

/***/ "../node_modules/fs.realpath/index.js":
/*!********************************************!*\
  !*** ../node_modules/fs.realpath/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = __webpack_require__(/*! ./old.js */ \"../node_modules/fs.realpath/old.js\")\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n\n\n//# sourceURL=node_modules/fs.realpath/index.js");

/***/ }),

/***/ "../node_modules/fs.realpath/old.js":
/*!******************************************!*\
  !*** ../node_modules/fs.realpath/old.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = __webpack_require__(/*! path */ \"path\");\nvar isWindows = process.platform === 'win32';\nvar fs = __webpack_require__(/*! fs */ \"fs\");\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n\n//# sourceURL=node_modules/fs.realpath/old.js");

/***/ }),

/***/ "../node_modules/glob/common.js":
/*!**************************************!*\
  !*** ../node_modules/glob/common.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = __webpack_require__(/*! path */ \"path\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../node_modules/minimatch/minimatch.js\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../node_modules/path-is-absolute/index.js\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\n\n//# sourceURL=node_modules/glob/common.js");

/***/ }),

/***/ "../node_modules/glob/glob.js":
/*!************************************!*\
  !*** ../node_modules/glob/glob.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar rp = __webpack_require__(/*! fs.realpath */ \"../node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(/*! inherits */ \"../node_modules/inherits/inherits.js\")\nvar EE = __webpack_require__(/*! events */ \"events\").EventEmitter\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../node_modules/path-is-absolute/index.js\")\nvar globSync = __webpack_require__(/*! ./sync.js */ \"../node_modules/glob/sync.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"../node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(/*! inflight */ \"../node_modules/inflight/inflight.js\")\nvar util = __webpack_require__(/*! util */ \"util\")\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(/*! once */ \"../node_modules/once/once.js\")\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n\n\n//# sourceURL=node_modules/glob/glob.js");

/***/ }),

/***/ "../node_modules/glob/sync.js":
/*!************************************!*\
  !*** ../node_modules/glob/sync.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar rp = __webpack_require__(/*! fs.realpath */ \"../node_modules/fs.realpath/index.js\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar Glob = __webpack_require__(/*! ./glob.js */ \"../node_modules/glob/glob.js\").Glob\nvar util = __webpack_require__(/*! util */ \"util\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../node_modules/path-is-absolute/index.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"../node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\n\n//# sourceURL=node_modules/glob/sync.js");

/***/ }),

/***/ "../node_modules/inflight/inflight.js":
/*!********************************************!*\
  !*** ../node_modules/inflight/inflight.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"../node_modules/wrappy/wrappy.js\")\nvar reqs = Object.create(null)\nvar once = __webpack_require__(/*! once */ \"../node_modules/once/once.js\")\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n\n\n//# sourceURL=node_modules/inflight/inflight.js");

/***/ }),

/***/ "../node_modules/inherits/inherits.js":
/*!********************************************!*\
  !*** ../node_modules/inherits/inherits.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("try {\n  var util = __webpack_require__(/*! util */ \"util\");\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./inherits_browser.js */ \"../node_modules/inherits/inherits_browser.js\");\n}\n\n\n//# sourceURL=node_modules/inherits/inherits.js");

/***/ }),

/***/ "../node_modules/inherits/inherits_browser.js":
/*!****************************************************!*\
  !*** ../node_modules/inherits/inherits_browser.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=node_modules/inherits/inherits_browser.js");

/***/ }),

/***/ "../node_modules/minimatch/minimatch.js":
/*!**********************************************!*\
  !*** ../node_modules/minimatch/minimatch.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = __webpack_require__(/*! path */ \"path\")\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = __webpack_require__(/*! brace-expansion */ \"../node_modules/brace-expansion/index.js\")\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n\n//# sourceURL=node_modules/minimatch/minimatch.js");

/***/ }),

/***/ "../node_modules/node-gyp-build/index.js":
/*!***********************************************!*\
  !*** ../node_modules/node-gyp-build/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar os = __webpack_require__(/*! os */ \"os\")\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire =  true ? require : undefined // eslint-disable-line\n\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : 'node'\nvar arch = os.arch()\nvar platform = os.platform()\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n  if (release) return release\n\n  var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n  if (debug) return debug\n\n  var prebuild = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchPrebuild)\n  if (prebuild) return prebuild\n\n  var napiRuntime = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapiRuntime)\n  if (napiRuntime) return napiRuntime\n\n  var napi = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapi)\n  if (napi) return napi\n\n  throw new Error('No native build was found for runtime=' + runtime + ' abi=' + abi + ' platform=' + platform + ' arch=' + arch)\n}\n\nfunction getFirst (dir, filter) {\n  try {\n    var files = fs.readdirSync(dir).filter(filter)\n    return files[0] && path.join(dir, files[0])\n  } catch (err) {\n    return null\n  }\n}\n\nfunction matchNapiRuntime (name) {\n  return name === runtime + '-napi.node'\n}\n\nfunction matchNapi (name) {\n  return name === 'node-napi.node'\n}\n\nfunction matchPrebuild (name) {\n  var parts = name.split('-')\n  return parts[0] === runtime && parts[1] === abi + '.node'\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\n\n//# sourceURL=node_modules/node-gyp-build/index.js");

/***/ }),

/***/ "../node_modules/once/once.js":
/*!************************************!*\
  !*** ../node_modules/once/once.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"../node_modules/wrappy/wrappy.js\")\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n\n//# sourceURL=node_modules/once/once.js");

/***/ }),

/***/ "../node_modules/path-is-absolute/index.js":
/*!*************************************************!*\
  !*** ../node_modules/path-is-absolute/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n\n\n//# sourceURL=node_modules/path-is-absolute/index.js");

/***/ }),

/***/ "../node_modules/rimraf/rimraf.js":
/*!****************************************!*\
  !*** ../node_modules/rimraf/rimraf.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = rimraf\nrimraf.sync = rimrafSync\n\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar glob = __webpack_require__(/*! glob */ \"../node_modules/glob/glob.js\")\nvar _0666 = parseInt('666', 8)\n\nvar defaultGlobOpts = {\n  nosort: true,\n  silent: true\n}\n\n// for EMFILE handling\nvar timeout = 0\n\nvar isWindows = (process.platform === \"win32\")\n\nfunction defaults (options) {\n  var methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(function(m) {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n  options.emfileWait = options.emfileWait || 1000\n  if (options.glob === false) {\n    options.disableGlob = true\n  }\n  options.disableGlob = options.disableGlob || false\n  options.glob = options.glob || defaultGlobOpts\n}\n\nfunction rimraf (p, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  var busyTries = 0\n  var errState = null\n  var n = 0\n\n  if (options.disableGlob || !glob.hasMagic(p))\n    return afterGlob(null, [p])\n\n  options.lstat(p, function (er, stat) {\n    if (!er)\n      return afterGlob(null, [p])\n\n    glob(p, options.glob, afterGlob)\n  })\n\n  function next (er) {\n    errState = errState || er\n    if (--n === 0)\n      cb(errState)\n  }\n\n  function afterGlob (er, results) {\n    if (er)\n      return cb(er)\n\n    n = results.length\n    if (n === 0)\n      return cb()\n\n    results.forEach(function (p) {\n      rimraf_(p, options, function CB (er) {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") &&\n              busyTries < options.maxBusyTries) {\n            busyTries ++\n            var time = busyTries * 100\n            // try again, with the same exact callback as this one.\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, time)\n          }\n\n          // this one won't happen if graceful-fs is used.\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, timeout ++)\n          }\n\n          // already gone\n          if (er.code === \"ENOENT\") er = null\n        }\n\n        timeout = 0\n        next(er)\n      })\n    })\n  }\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, function (er, st) {\n    if (er && er.code === \"ENOENT\")\n      return cb(null)\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === \"EPERM\" && isWindows)\n      fixWinEPERM(p, options, er, cb)\n\n    if (st && st.isDirectory())\n      return rmdir(p, options, er, cb)\n\n    options.unlink(p, function (er) {\n      if (er) {\n        if (er.code === \"ENOENT\")\n          return cb(null)\n        if (er.code === \"EPERM\")\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        if (er.code === \"EISDIR\")\n          return rmdir(p, options, er, cb)\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er)\n    assert(er instanceof Error)\n\n  options.chmod(p, _0666, function (er2) {\n    if (er2)\n      cb(er2.code === \"ENOENT\" ? null : er)\n    else\n      options.stat(p, function(er3, stats) {\n        if (er3)\n          cb(er3.code === \"ENOENT\" ? null : er)\n        else if (stats.isDirectory())\n          rmdir(p, options, er, cb)\n        else\n          options.unlink(p, cb)\n      })\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  assert(p)\n  assert(options)\n  if (er)\n    assert(er instanceof Error)\n\n  try {\n    options.chmodSync(p, _0666)\n  } catch (er2) {\n    if (er2.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  try {\n    var stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  if (stats.isDirectory())\n    rmdirSync(p, options, er)\n  else\n    options.unlinkSync(p)\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, function (er) {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))\n      rmkids(p, options, cb)\n    else if (er && er.code === \"ENOTDIR\")\n      cb(originalEr)\n    else\n      cb(er)\n  })\n}\n\nfunction rmkids(p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, function (er, files) {\n    if (er)\n      return cb(er)\n    var n = files.length\n    if (n === 0)\n      return options.rmdir(p, cb)\n    var errState\n    files.forEach(function (f) {\n      rimraf(path.join(p, f), options, function (er) {\n        if (errState)\n          return\n        if (er)\n          return cb(errState = er)\n        if (--n === 0)\n          options.rmdir(p, cb)\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  var results\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p]\n  } else {\n    try {\n      options.lstatSync(p)\n      results = [p]\n    } catch (er) {\n      results = glob.sync(p, options.glob)\n    }\n  }\n\n  if (!results.length)\n    return\n\n  for (var i = 0; i < results.length; i++) {\n    var p = results[i]\n\n    try {\n      var st = options.lstatSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n\n      // Windows can EPERM on stat.  Life is suffering.\n      if (er.code === \"EPERM\" && isWindows)\n        fixWinEPERMSync(p, options, er)\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory())\n        rmdirSync(p, options, null)\n      else\n        options.unlinkSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n      if (er.code === \"EPERM\")\n        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n      if (er.code !== \"EISDIR\")\n        throw er\n\n      rmdirSync(p, options, er)\n    }\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === \"ENOENT\")\n      return\n    if (er.code === \"ENOTDIR\")\n      throw originalEr\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")\n      rmkidsSync(p, options)\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(function (f) {\n    rimrafSync(path.join(p, f), options)\n  })\n\n  // We only end up here once we got ENOTEMPTY at least once, and\n  // at this point, we are guaranteed to have removed all the kids.\n  // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n  // try really hard to delete stuff on windows, because it has a\n  // PROFOUNDLY annoying habit of not closing handles promptly when\n  // files are deleted, resulting in spurious ENOTEMPTY errors.\n  var retries = isWindows ? 100 : 1\n  var i = 0\n  do {\n    var threw = true\n    try {\n      var ret = options.rmdirSync(p, options)\n      threw = false\n      return ret\n    } finally {\n      if (++i < retries && threw)\n        continue\n    }\n  } while (true)\n}\n\n\n//# sourceURL=node_modules/rimraf/rimraf.js");

/***/ }),

/***/ "../node_modules/utf-8-validate/fallback.js":
/*!**************************************************!*\
  !*** ../node_modules/utf-8-validate/fallback.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nconst isValidUTF8 = (buf) => {\n  var len = buf.length;\n  var i = 0;\n\n  while (i < len) {\n    if (buf[i] < 0x80) {  // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0  // overlong\n      ) {\n        return false;\n      } else {\n        i += 2;\n      }\n    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong\n        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0     // surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      } else {\n        i += 3;\n      }\n    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong\n        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF\n      ) {\n        return false;\n      } else {\n        i += 4;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = isValidUTF8;\n\n\n//# sourceURL=node_modules/utf-8-validate/fallback.js");

/***/ }),

/***/ "../node_modules/utf-8-validate/index.js":
/*!***********************************************!*\
  !*** ../node_modules/utf-8-validate/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"../node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"../node_modules/utf-8-validate/fallback.js\");\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=node_modules/utf-8-validate/index.js");

/***/ }),

/***/ "../node_modules/wrappy/wrappy.js":
/*!****************************************!*\
  !*** ../node_modules/wrappy/wrappy.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n\n//# sourceURL=node_modules/wrappy/wrappy.js");

/***/ }),

/***/ "../node_modules/ws/index.js":
/*!***********************************!*\
  !*** ../node_modules/ws/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"../node_modules/ws/lib/websocket.js\");\n\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"../node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"../node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"../node_modules/ws/lib/sender.js\");\n\nmodule.exports = WebSocket;\n\n\n//# sourceURL=node_modules/ws/index.js");

/***/ }),

/***/ "../node_modules/ws/lib/buffer-util.js":
/*!*********************************************!*\
  !*** ../node_modules/ws/lib/buffer-util.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  var offset = 0;\n\n  for (var i = 0; i < list.length; i++) {\n    const buf = list[i];\n    buf.copy(target, offset);\n    offset += buf.length;\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  var buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = viewToBuffer(data);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\nfunction viewToBuffer(view) {\n  const buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = __webpack_require__(/*! bufferutil */ \"../node_modules/bufferutil/index.js\");\n  const bu = bufferUtil.BufferUtil || bufferUtil;\n\n  module.exports = {\n    concat,\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bu.mask(source, mask, output, offset, length);\n    },\n    toArrayBuffer,\n    toBuffer,\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bu.unmask(buffer, mask);\n    }\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}\n\n\n//# sourceURL=node_modules/ws/lib/buffer-util.js");

/***/ }),

/***/ "../node_modules/ws/lib/constants.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/constants.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  EMPTY_BUFFER: Buffer.alloc(0),\n  NOOP: () => {}\n};\n\n\n//# sourceURL=node_modules/ws/lib/constants.js");

/***/ }),

/***/ "../node_modules/ws/lib/event-target.js":
/*!**********************************************!*\
  !*** ../node_modules/ws/lib/event-target.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Class representing an event.\n *\n * @private\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was dispatched\n   */\n  constructor(type, target) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(data, target) {\n    super('message', target);\n\n    this.data = data;\n  }\n}\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(code, reason, target) {\n    super('close', target);\n\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    this.reason = reason;\n    this.code = code;\n  }\n}\n\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\nclass OpenEvent extends Event {\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(target) {\n    super('open', target);\n  }\n}\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n * @private\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {Object} error The error that generated this event\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(error, target) {\n    super('error', target);\n\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} method A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @public\n   */\n  addEventListener(method, listener) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage(data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose(code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError(error) {\n      listener.call(this, new ErrorEvent(error, this));\n    }\n\n    function onOpen() {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    if (method === 'message') {\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} method A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener(method, listener) {\n    const listeners = this.listeners(method);\n\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(method, listeners[i]);\n      }\n    }\n  }\n};\n\nmodule.exports = EventTarget;\n\n\n//# sourceURL=node_modules/ws/lib/event-target.js");

/***/ }),

/***/ "../node_modules/ws/lib/extension.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/extension.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (Object.prototype.hasOwnProperty.call(dest, name)) dest[name].push(elem);\n  else dest[name] = [elem];\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = {};\n\n  if (header === undefined || header === '') return offers;\n\n  var params = {};\n  var mustUnescape = false;\n  var isEscaping = false;\n  var inQuotes = false;\n  var extensionName;\n  var paramName;\n  var start = -1;\n  var end = -1;\n\n  for (var i = 0; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = {};\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = {};\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        var value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = {};\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, {});\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      var configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                var values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n\n\n//# sourceURL=node_modules/ws/lib/extension.js");

/***/ }),

/***/ "../node_modules/ws/lib/permessage-deflate.js":
/*!****************************************************!*\
  !*** ../node_modules/ws/lib/permessage-deflate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Limiter = __webpack_require__(/*! async-limiter */ \"../node_modules/async-limiter/index.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"../node_modules/ws/lib/buffer-util.js\");\nconst { kStatusCode, NOOP } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst EMPTY_BLOCK = Buffer.from([0x00]);\n\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate\n   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter({ concurrency });\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      this._deflate.close();\n      this._deflate = null;\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        var value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw(\n        Object.assign({}, this._options.zlibInflateOptions, { windowBits })\n      );\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    if (!data || data.length === 0) {\n      process.nextTick(callback, null, EMPTY_BLOCK);\n      return;\n    }\n\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw(\n        Object.assign({}, this._options.zlibDeflateOptions, { windowBits })\n      );\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      //\n      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the\n      // `zlib.DeflateRaw` instance is closed while data is being processed.\n      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong\n      // time due to an abnormal WebSocket closure.\n      //\n      this._deflate.on('error', NOOP);\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // This `if` statement is only needed for Node.js < 10.0.0 because as of\n        // commit https://github.com/nodejs/node/commit/5e3f5164, the flush\n        // callback is no longer called if the deflate stream is closed while\n        // data is being processed.\n        //\n        return;\n      }\n\n      var data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.close();\n        this._deflate = null;\n      } else {\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n\n\n//# sourceURL=node_modules/ws/lib/permessage-deflate.js");

/***/ }),

/***/ "../node_modules/ws/lib/receiver.js":
/*!******************************************!*\
  !*** ../node_modules/ws/lib/receiver.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"../node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"../node_modules/ws/lib/validation.js\");\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends stream.Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {String} binaryType The type for binary data\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(binaryType, extensions, maxPayload) {\n    super();\n\n    this._binaryType = binaryType || BINARY_TYPES[0];\n    this[kWebSocket] = undefined;\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n\n      if (n >= buf.length) {\n        this._buffers.shift().copy(dst, dst.length - n);\n      } else {\n        buf.copy(dst, dst.length - n, 0, n);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    var err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002);\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002);\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002);\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009);\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    var data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n      if (this._masked) unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its lenght is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(RangeError, 'Max payload size exceeded', false, 1009)\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        var data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('message', buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, '');\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002);\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002);\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('conclude', code, buf.toString());\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {(Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err[kStatusCode] = statusCode;\n  return err;\n}\n\n\n//# sourceURL=node_modules/ws/lib/receiver.js");

/***/ }),

/***/ "../node_modules/ws/lib/sender.js":
/*!****************************************!*\
  !*** ../node_modules/ws/lib/sender.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { randomBytes } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"../node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"../node_modules/ws/lib/buffer-util.js\");\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    var offset = options.mask ? 6 : 2;\n    var payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    const mask = randomBytes(4);\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    var buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || data === '') {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose(data, mask, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x08,\n        mask,\n        readOnly: false\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x09,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x0a,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    var opcode = options.binary ? 2 : 1;\n    var rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(buf, {\n          fin: options.fin,\n          rsv1: false,\n          opcode,\n          mask: options.mask,\n          readOnly: toBuffer.readOnly\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      params[0].apply(this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n\n//# sourceURL=node_modules/ws/lib/sender.js");

/***/ }),

/***/ "../node_modules/ws/lib/validation.js":
/*!********************************************!*\
  !*** ../node_modules/ws/lib/validation.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\ntry {\n  const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"../node_modules/utf-8-validate/index.js\");\n\n  exports.isValidUTF8 =\n    typeof isValidUTF8 === 'object'\n      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\n      : isValidUTF8;\n} catch (e) /* istanbul ignore next */ {\n  exports.isValidUTF8 = () => true;\n}\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nexports.isValidStatusCode = (code) => {\n  return (\n    (code >= 1000 &&\n      code <= 1013 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n};\n\n\n//# sourceURL=node_modules/ws/lib/validation.js");

/***/ }),

/***/ "../node_modules/ws/lib/websocket-server.js":
/*!**************************************************!*\
  !*** ../node_modules/ws/lib/websocket-server.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst http = __webpack_require__(/*! http */ \"http\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\nconst extension = __webpack_require__(/*! ./extension */ \"../node_modules/ws/lib/extension.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"../node_modules/ws/lib/websocket.js\");\nconst { GUID } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} options.backlog The maximum length of the queue of pending\n   *     connections\n   * @param {Boolean} options.clientTracking Specifies whether or not to track\n   *     clients\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {String} options.path Accept only connections matching this path\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n   *     permessage-deflate\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = Object.assign(\n      {\n        maxPayload: 100 * 1024 * 1024,\n        perMessageDeflate: false,\n        handleProtocols: null,\n        clientTracking: true,\n        verifyClient: null,\n        noServer: false,\n        backlog: null, // use default (511 as implemented in net.js)\n        server: null,\n        host: null,\n        path: null,\n        port: null\n      },\n      options\n    );\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError(\n        'One of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, (ws) => {\n            this.emit('connection', ws, req);\n          });\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(cb) {\n    if (cb) this.once('close', cb);\n\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) {\n        server.close(() => this.emit('close'));\n        return;\n      }\n    }\n\n    process.nextTick(emitClose, this);\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key =\n      req.headers['sec-websocket-key'] !== undefined\n        ? req.headers['sec-websocket-key'].trim()\n        : false;\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' ||\n      req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !key ||\n      !keyRegex.test(key) ||\n      (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(req.headers['sec-websocket-extensions']);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(key, extensions, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(key, extensions, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade(key, extensions, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    const digest = crypto\n      .createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new WebSocket(null);\n    var protocol = req.headers['sec-websocket-protocol'];\n\n    if (protocol) {\n      protocol = protocol.trim().split(/ *, */);\n\n      //\n      // Optionally call external protocol selection handler.\n      //\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n      } else {\n        protocol = protocol[0];\n      }\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws.protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, this.options.maxPayload);\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n    }\n\n    cb(ws);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server.emit('close');\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    headers = Object.assign(\n      {\n        Connection: 'close',\n        'Content-type': 'text/html',\n        'Content-Length': Buffer.byteLength(message)\n      },\n      headers\n    );\n\n    socket.write(\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n        Object.keys(headers)\n          .map((h) => `${h}: ${headers[h]}`)\n          .join('\\r\\n') +\n        '\\r\\n\\r\\n' +\n        message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n\n\n//# sourceURL=node_modules/ws/lib/websocket-server.js");

/***/ }),

/***/ "../node_modules/ws/lib/websocket.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/websocket.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst url = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\nconst EventTarget = __webpack_require__(/*! ./event-target */ \"../node_modules/ws/lib/event-target.js\");\nconst extension = __webpack_require__(/*! ./extension */ \"../node_modules/ws/lib/extension.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"../node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"../node_modules/ws/lib/sender.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|url.Url|url.URL)} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = '';\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._closeCode = 1006;\n    this._extensions = {};\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  get CONNECTING() {\n    return WebSocket.CONNECTING;\n  }\n  get CLOSING() {\n    return WebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return WebSocket.CLOSED;\n  }\n  get OPEN() {\n    return WebSocket.OPEN;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return 0;\n\n    //\n    // `socket.bufferSize` is `undefined` if the socket is closed.\n    //\n    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} maxPayload The maximum allowed message size\n   * @private\n   */\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(\n      this._binaryType,\n      this._extensions,\n      maxPayload\n    );\n\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    this.readyState = WebSocket.CLOSED;\n\n    if (!this._socket) {\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived) this._socket.end();\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(\n        `WebSocket is not open: readyState ${this.readyState} ` +\n          `(${readyStates[this.readyState]})`\n      );\n\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(\n        `WebSocket is not open: readyState ${this.readyState} ` +\n          `(${readyStates[this.readyState]})`\n      );\n\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(\n        `WebSocket is not open: readyState ${this.readyState} ` +\n          `(${readyStates[this.readyState]})`\n      );\n\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    const opts = Object.assign(\n      {\n        binary: typeof data !== 'string',\n        mask: !this._isServer,\n        compress: true,\n        fin: true\n      },\n      options\n    );\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this.readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\nreadyStates.forEach((readyState, i) => {\n  WebSocket[readyState] = i;\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get() {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n\n      return undefined;\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set(listener) {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|url.Url|url.URL)} address The URL to which to connect\n * @param {String} protocols The subprotocols\n * @param {Object} options Connection options\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n *     permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the\n *     handshake request\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`\n *     header\n * @param {String} options.origin Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {Boolean} options.followRedirects Whether or not to follow redirects\n * @param {Number} options.maxRedirects The maximum number of redirects allowed\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = Object.assign(\n    {\n      protocolVersion: protocolVersions[1],\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: true,\n      followRedirects: false,\n      maxRedirects: 10\n    },\n    options,\n    {\n      createConnection: undefined,\n      socketPath: undefined,\n      hostname: undefined,\n      protocol: undefined,\n      timeout: undefined,\n      method: undefined,\n      auth: undefined,\n      host: undefined,\n      path: undefined,\n      port: undefined\n    }\n  );\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  var parsedUrl;\n\n  if (typeof address === 'object' && address.href !== undefined) {\n    parsedUrl = address;\n    websocket.url = address.href;\n  } else {\n    //\n    // The WHATWG URL constructor is not available on Node.js < 6.13.0\n    //\n    parsedUrl = url.URL ? new url.URL(address) : url.parse(address);\n    websocket.url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${websocket.url}`);\n  }\n\n  const isSecure =\n    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const defaultPort = isSecure ? 443 : 80;\n  const key = crypto.randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  const path = parsedUrl.search\n    ? `${parsedUrl.pathname || '/'}${parsedUrl.search}`\n    : parsedUrl.pathname || '/';\n  var perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = Object.assign(\n    {\n      'Sec-WebSocket-Version': opts.protocolVersion,\n      'Sec-WebSocket-Key': key,\n      Connection: 'Upgrade',\n      Upgrade: 'websocket'\n    },\n    opts.headers\n  );\n  opts.path = path;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = extension.format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols) {\n    opts.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.auth) {\n    opts.auth = parsedUrl.auth;\n  } else if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  var req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (websocket._req.aborted) return;\n\n    req = websocket._req = null;\n    websocket.readyState = WebSocket.CLOSING;\n    websocket.emit('error', err);\n    websocket.emitClose();\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      const addr = url.URL\n        ? new url.URL(location, address)\n        : url.resolve(address, location);\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = crypto\n      .createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    var protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && !protList.includes(serverProt)) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const extensions = extension.parse(\n          res.headers['sec-websocket-extensions']\n        );\n\n        if (extensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n          websocket._extensions[\n            PerMessageDeflate.extensionName\n          ] = perMessageDeflate;\n        }\n      } catch (err) {\n        abortHandshake(\n          websocket,\n          socket,\n          'Invalid Sec-WebSocket-Extensions header'\n        );\n        return;\n      }\n    }\n\n    websocket.setSocket(socket, head, opts.maxPayload);\n  });\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  //\n  // Override `options.path` only if `options` is a copy of the original options\n  // object. This is always true on Node.js >= 8 but not on Node.js 6 where\n  // `options.socketPath` might be `undefined` even if the `socketPath` option\n  // was originally set.\n  //\n  if (options.protocolVersion) options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n  options.servername = options.servername || options.host;\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\n *     socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket.readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n  websocket._socket.resume();\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._closeCode = err[kStatusCode];\n  websocket.emit('error', err);\n  websocket._socket.destroy();\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('end', socketOnEnd);\n\n  websocket.readyState = WebSocket.CLOSING;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk and emitted synchronously in a single\n  // `'data'` event.\n  //\n  websocket._socket.read();\n  websocket._receiver.end();\n\n  this.removeListener('data', socketOnData);\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  websocket.readyState = WebSocket.CLOSING;\n  this.destroy();\n}\n\n\n//# sourceURL=node_modules/ws/lib/websocket.js");

/***/ }),

/***/ "./activities/activity.js":
/*!********************************!*\
  !*** ./activities/activity.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Activity; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _idGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../idGenerator */ \"./idGenerator.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var _connections_connection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../connections/connection */ \"./connections/connection.js\");\n/* harmony import */ var _plugins_plugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../plugins/plugin */ \"./plugins/plugin.js\");\n/* harmony import */ var _activityConnection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./activityConnection */ \"./activities/activityConnection.js\");\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\n/* global global */\n\n/**\n * @module activities/activity\n */\n\n\n\n\n\n\n // Error classes\n\nconst logObject = {\n  scope: 'activity',\n  class: 'Activity',\n  event: undefined,\n  module: undefined\n};\n\nconst _TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_3__[\"makeClassLoggable\"])(global.TypeError, logObject);\n\nconst Error = Object(_logger__WEBPACK_IMPORTED_MODULE_3__[\"makeClassLoggable\"])(global.Error, logObject);\nconst generateId = Object(_idGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n/**\n * Activity is the connection between plugin instance and client connection\n *\n * @mixes module:remote-controller-server-core~external:EventEmitter\n */\n\nclass Activity extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {module:connections/connection}\n   */\n\n  /**\n   * @type {module:plugins/plugin} Actual Plugin class\n   */\n\n  /**\n   * @type {module:plugins/plugin} Plugin instance\n   */\n\n  /**\n   * @param {object} configs\n   * @param {module:connections/connection} configs.connection\n   * @param {module:plugins/plugin} configs.Plugin Plugin extended class\n   */\n  constructor(configs) {\n    if (typeof configs !== 'object') throw new _TypeError('configs parameter is required and must be object');else if (!(configs.connection instanceof _connections_connection__WEBPACK_IMPORTED_MODULE_4__[\"default\"])) throw new _TypeError('configs.connection is required and must be Connection');else if (Object.getPrototypeOf(configs.Plugin) !== _plugins_plugin__WEBPACK_IMPORTED_MODULE_5__[\"default\"]) throw new _TypeError('configs.plugin is required and must be Plugin extended class');else if (!configs.connection.isConnect) throw new Error('Connection is not connect');else if (!configs.connection.isAuthenticate) throw new Error('Connection is not authenticate');\n    super();\n\n    _status.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _id.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _connection.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _Plugin.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _plugin.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldSet(this, _id, generateId());\n\n    _classPrivateFieldSet(this, _connection, configs.connection);\n\n    _classPrivateFieldSet(this, _Plugin, configs.Plugin);\n\n    _classPrivateFieldSet(this, _plugin, new (_classPrivateFieldGet(this, _Plugin))({\n      activityId: _classPrivateFieldGet(this, _id),\n      activityConnection: new _activityConnection__WEBPACK_IMPORTED_MODULE_6__[\"default\"]({\n        connection: configs.connection,\n        activity: this\n      })\n    }));\n\n    this.on('init', () => _classPrivateFieldSet(this, _status, 'init') && this.plugin.emit('plugging'));\n    this.on('ready', () => _classPrivateFieldSet(this, _status, 'ready') && this.plugin.emit('plugged'));\n    this.on('cleanup', () => _classPrivateFieldSet(this, _status, 'cleanup') && this.plugin.emit('unplugging'));\n    this.on('close', () => _classPrivateFieldSet(this, _status, 'close') && this.plugin.emit('unplugged'));\n  }\n\n  get id() {\n    return _classPrivateFieldGet(this, _id);\n  }\n\n  get connection() {\n    return _classPrivateFieldGet(this, _connection);\n  }\n\n  get plugin() {\n    return _classPrivateFieldGet(this, _plugin);\n  }\n\n  get status() {\n    return _classPrivateFieldGet(this, _status);\n  }\n\n  get [_logger__WEBPACK_IMPORTED_MODULE_3__[\"logSymbol\"]]() {\n    return {\n      activity: {\n        id: this.id,\n        status: this.status,\n        connection: this.connection[_logger__WEBPACK_IMPORTED_MODULE_3__[\"logSymbol\"]],\n        plugin: this.plugin[_logger__WEBPACK_IMPORTED_MODULE_3__[\"logSymbol\"]]\n      }\n    };\n  }\n\n} // Set string tag\n\nvar _status = new WeakMap();\n\nvar _id = new WeakMap();\n\nvar _connection = new WeakMap();\n\nvar _Plugin = new WeakMap();\n\nvar _plugin = new WeakMap();\n\n_helpers__WEBPACK_IMPORTED_MODULE_1__[\"decorator\"].setStringTag()(Activity);\n\n//# sourceURL=src/activities/activity.js");

/***/ }),

/***/ "./activities/activityConnection.js":
/*!******************************************!*\
  !*** ./activities/activityConnection.js ***!
  \******************************************/
/*! exports provided: default, ID_SEPARATOR */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ActivityConnection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ID_SEPARATOR\", function() { return ID_SEPARATOR; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _connections_connection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../connections/connection */ \"./connections/connection.js\");\n/* harmony import */ var _activities_activity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../activities/activity */ \"./activities/activity.js\");\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\n/* global global */\n\n/**\n * @module activities/activityConnection\n */\n\n\n\n\n // Error classes\n\nconst logObject = {\n  scope: 'activityConnection',\n  class: 'ActivityConnection',\n  event: undefined,\n  module: undefined\n};\n\nconst _TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_1__[\"makeClassLoggable\"])(global.TypeError, logObject);\n/**\n * Create a wrapper around connection module to use in activity\n *\n * @mixes module:remote-controller-server-core~external:EventEmitter\n *\n * @see module:connections/connection\n */\n\n\nclass ActivityConnection extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n  /**\n   * @type {module:activities/activity}\n   */\n\n  /**\n   * @type {connections/connection}\n   */\n\n  /**\n   * @param {object} configs\n   * @param {module:activities/activity} configs.activity Activity that use for create Connection instance\n   * @param {module:connections/connection} configs.connection\n   */\n  constructor(configs) {\n    if (typeof configs !== 'object') throw new _TypeError('configs parameter is required and must be object');else if (!(configs.activity instanceof _activities_activity__WEBPACK_IMPORTED_MODULE_4__[\"default\"])) throw new _TypeError('configs.activity is required and must be Activity');else if (!(configs.connection instanceof _connections_connection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) throw new _TypeError('configs.connection is required and must be Connection');\n    super();\n\n    _activity.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _connection.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldSet(this, _activity, configs.activity);\n\n    _classPrivateFieldSet(this, _connection, configs.connection);\n\n    const eventEmitterMethods = ['emit', 'addListener', 'on', 'prependListener', 'once', 'prependOnceListener', 'removeListener', 'off', 'removeAllListeners', 'listeners', 'rawListeners', 'listenerCount'];\n    const prototype = Object.getPrototypeOf(this); // Transfer events with activity id\n\n    for (const methodName of eventEmitterMethods) {\n      prototype[methodName] = function (type, ...parameters) {\n        return configs.connection[methodName](configs.activity.id + ID_SEPARATOR + type, ...parameters);\n      };\n    }\n  }\n  /**\n   * Send message to client's activity\n   *\n   * @param {string} name Message's name\n   * @param {...*} [body] Message's content\n   * @param {function} [callback] This function listens to event with the same name just once\n   *\n   * @async\n   * @return {Promise<(void|Error)>}\n   * * Rejection\n   *  * Reject an error if Connection is not authenticated\n   *  * Reject an error if Connection is not connected\n   *\n   *  @see module:connections/connection#send\n   */\n\n\n  send(name, ...body) {\n    if (typeof name !== 'string' || name === '') throw new _TypeError('name parameter is required and must be string');\n    name = _classPrivateFieldGet(this, _activity).id + ID_SEPARATOR + name;\n    return _classPrivateFieldGet(this, _connection).send(name, ...body);\n  }\n  /**\n   * @summary Send message in binary type to client\n   * @description Same as {@link module:connections/connection#send}\n   *\n   * @param {string} name Message's name\n   * @param {...*} [body] Message's content\n   * @param {function} [callback] This function listens to event with the same name just once\n   *\n   * @async\n   * @return {Promise<(void|Error)>}\n   *\n   * @see module:connections/connection#sendBinary\n   */\n\n\n  sendBinary(name, ...body) {\n    if (typeof name !== 'string' || name === '') throw new _TypeError('name parameter is required and must be string');\n    name = _classPrivateFieldGet(this, _activity).id + ID_SEPARATOR + name;\n    return _classPrivateFieldGet(this, _connection).sendBinary(name, ...body);\n  }\n  /**\n   * Get Client IP\n   *\n   * @type {string}\n   *\n   * @see module:connections/connection#address\n   */\n\n\n  get address() {\n    return _classPrivateFieldGet(this, _connection).address;\n  }\n\n  get [_logger__WEBPACK_IMPORTED_MODULE_1__[\"logSymbol\"]]() {\n    return { ..._classPrivateFieldGet(this, _connection)[_logger__WEBPACK_IMPORTED_MODULE_1__[\"logSymbol\"]],\n      ..._classPrivateFieldGet(this, _activity)[_logger__WEBPACK_IMPORTED_MODULE_1__[\"logSymbol\"]]\n    };\n  }\n\n} // Set string tag\n\nvar _activity = new WeakMap();\n\nvar _connection = new WeakMap();\n\n_helpers__WEBPACK_IMPORTED_MODULE_2__[\"decorator\"].setStringTag()(ActivityConnection);\nconst ID_SEPARATOR = ':';\n\n//# sourceURL=src/activities/activityConnection.js");

/***/ }),

/***/ "./activities/index.js":
/*!*****************************!*\
  !*** ./activities/index.js ***!
  \*****************************/
/*! exports provided: default, Activity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makeActivities; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _activity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activity */ \"./activities/activity.js\");\n/* harmony import */ var _connections_connection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../connections/connection */ \"./connections/connection.js\");\n/* harmony import */ var _plugins_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../plugins/plugin */ \"./plugins/plugin.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Activity\", function() { return _activity__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/** global global, setTimeout */\n\n/**\n * @module activities\n */\n\n\n\n\n\n // Error classes\n\nconst logObject = {\n  scope: 'makeActivities',\n  module: 'activities',\n  event: undefined\n};\nconst TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_5__[\"makeClassLoggable\"])(global.TypeError, logObject);\n/**\n * makeActivities creates activities module\n *\n * @param {object} [configs={}]\n *\n * @return {module:activities~Activities}\n */\n\nfunction makeActivities(configs = Object.create(null)) {\n  if (typeof configs !== 'object') throw new TypeError('configs parameter must be object');\n  const connections = this.connections;\n  const plugins = this.plugins;\n  const activitiesList = {};\n\n  class Activities extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n    /**\n     * Handle activities messages\n     */\n    constructor() {\n      super();\n      const self = this;\n\n      async function connectionsOnAddActivity(configs) {\n        let Plugin = plugins.get(configs.plugin);\n        let activity;\n        let result;\n\n        if (Plugin === undefined) {\n          result = {\n            status: 2,\n            error: configs.plugin + ' plugin not found',\n            plugin: configs.plugin,\n            id: configs.id\n          };\n          await this.send('addActivity', result);\n          self.emit('addActivity', result);\n        } else {\n          Plugin = Plugin.Plugin;\n          activity = activitiesList[configs.id];\n\n          if (configs.status !== 0 && activity === undefined) {\n            result = {\n              status: 2,\n              error: 'Activity not found',\n              plugin: configs.plugin,\n              id: configs.id\n            };\n            await this.send('addActivity', result);\n            self.emit('addActivity', result);\n          } else {\n            switch (configs.status) {\n              case 0:\n                activity = self.add(this, Plugin);\n                result = {\n                  status: 0,\n                  id: activity.id,\n                  plugin: configs.plugin\n                };\n                await this.send('addActivity', result);\n                self.emit('addActivity', result);\n                break;\n\n              case 1:\n                activity.emit('init');\n                result = {\n                  status: 1,\n                  id: activity.id,\n                  plugin: configs.plugin\n                };\n                this.send('addActivity', result).then(() => self.emit('addActivity', result));\n                activity.emit('ready');\n                break;\n\n              case 2:\n                self.remove(activity);\n                break;\n            }\n          }\n        }\n      }\n\n      async function connectionsOnRemoveActivity(configs) {\n        let activity = activitiesList[configs.id];\n        let result;\n\n        if (activity === undefined) {\n          result = {\n            status: 2,\n            error: 'Activity not found',\n            id: configs.id\n          };\n          await this.send('removeActivity', result);\n          self.emit('removeActivity', result);\n        } else {\n          switch (configs.status) {\n            case 0:\n              activity.emit('cleanup');\n              result = {\n                status: 0,\n                id: activity.id\n              };\n              await this.send('removeActivity', result);\n              self.emit('removeActivity', result);\n              break;\n\n            case 1:\n              self.remove(activity);\n              result = {\n                status: 1,\n                id: activity.id\n              };\n              await this.send('removeActivity', result);\n              self.emit('removeActivity', result);\n              break;\n\n            case 2:\n              self.remove(activity);\n              break;\n          }\n        }\n      }\n\n      connections.on('connected', connection => {\n        const onAddActivity = connectionsOnAddActivity.bind(connection);\n        const onRemoveActivity = connectionsOnRemoveActivity.bind(connection);\n        connection.on('authentication', ({\n          status,\n          factor\n        }) => {\n          if (!factor) {\n            switch (status) {\n              case 1:\n                connection.on('addActivity', onAddActivity);\n                connection.on('removeActivity', onRemoveActivity);\n                connection.once('disconnected', () => {\n                  if (connection.listenerCount('addActivity')) {\n                    connection.off('addActivity', onAddActivity);\n                    connection.off('removeActivity', onRemoveActivity); // Close connection's activities on disconnected event\n\n                    for (const activityId in activitiesList) {\n                      const activity = activitiesList[activityId];\n                      if (!activitiesList.hasOwnProperty(activityId) || activity.connection !== connection) continue;\n                      if (activity.status === 'init' || activity.status === 'ready') activity.emit('cleanup');\n                      if (activity.status !== 'close') activity.emit('close');\n                    } // Remove connection's activities base-on connections removeTimeout\n\n\n                    setTimeout(() => {\n                      if (!connection.isConnect) {\n                        for (const activityId in activitiesList) {\n                          if (!activitiesList.hasOwnProperty(activityId) || activitiesList[activityId].connection !== connection) continue;\n                          this.remove(activitiesList[activityId]);\n                        }\n                      }\n                    }, connections.removeTimeout);\n                  }\n                });\n                break;\n\n              case 2:\n                connection.off('addActivity', onAddActivity);\n                connection.off('removeActivity', onRemoveActivity);\n                break;\n            }\n          }\n        });\n      });\n    }\n    /**\n     * @summary Get specific Activity or all Activities list\n     * @description\n     * When call this method without ActivityId parameter, returned object is iterable (over values) <br>\n     * `Object.values({@link module:activities~activity#get|activity.get()})[Symbol.iterator]`\n     * is same as\n     * `{@link module:activities~activity#get|activity.get()}[Symbol.iterator]`\n     *\n     * @param {string} [activityId]\n     *\n     * @return {(module:activities~activity|object<string, module:activities~activity>)}\n     */\n\n\n    get(activityId) {\n      if (activityId !== undefined && typeof activityId !== 'string') throw new TypeError('pluginName parameter must be string');\n      if (activityId) return activitiesList[activityId];\n      const activitiesListPrototype = {\n        length: 0,\n        [Symbol.iterator]: _helpers__WEBPACK_IMPORTED_MODULE_1__[\"object\"].iterateOverValues\n      };\n\n      const _activitiesList = Object.create(activitiesListPrototype);\n\n      for (const [key, value] of Object.entries(activitiesList)) {\n        _activitiesList[key] = value;\n        activitiesListPrototype.length++;\n      }\n\n      return _activitiesList;\n    }\n    /**\n     * Add and initial Activity\n     *\n     * @param {(module:connections/connection|module:activities/activity)} connection\n     * @param {module:plugins/plugin} [_Plugin] Plugin extended class\n     *\n     * @emits module:activities/activity#event:added\n     *\n     * @return {module:activities/activity}\n     */\n\n\n    add(connection, _Plugin) {\n      if (!(connection instanceof _activity__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) && !(connection instanceof _connections_connection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) throw new TypeError('connection parameter is required and must be Activity/Connection');else if (connection instanceof _connections_connection__WEBPACK_IMPORTED_MODULE_3__[\"default\"] && Object.getPrototypeOf(_Plugin) !== _plugins_plugin__WEBPACK_IMPORTED_MODULE_4__[\"default\"]) throw new TypeError('Plugin parameter is required and must be Plugin extended class');\n\n      if (connection instanceof _connections_connection__WEBPACK_IMPORTED_MODULE_3__[\"default\"]) {\n        connection = new _activity__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n          connection,\n          Plugin: _Plugin\n        });\n      }\n\n      activitiesList[connection.id] = connection;\n      /**\n       * Activity added event\n       *\n       * @event module:activities/activity#event:added\n       *\n       * @type {module:activities/activity}\n       */\n\n      this.emit('added', connection);\n      return connection;\n    }\n    /**\n     * Remove activity from list\n     *\n     * @param {(module:activities/activity|string)} activity Activity instance or id\n     *\n     * @emits module:activities/activity#event:removed\n     *\n     * @return {boolean}\n     */\n\n\n    remove(activity) {\n      if (!(activity instanceof _activity__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) && typeof activity !== 'string') throw new TypeError('activity parameter is required and must be Activity/string');\n      if (typeof activity === 'string') activity = activitiesList[activity];\n      let result = false;\n\n      if (activity instanceof _activity__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) {\n        if (activity.status === 'init' || activity.status === 'ready') activity.emit('cleanup');\n        if (activity.status !== 'close') activity.emit('close');\n        result = delete activitiesList[activity.id];\n      }\n      /**\n       * Activity removed event\n       *\n       * @event module:activities/activity#event:removed\n       *\n       * @type {module:activities/activity}\n       */\n\n\n      if (result) this.emit('removed', activity);\n      return result;\n    }\n    /**\n     * Check Activity is already exist\n     *\n     * @param {string} activityId Activity's id to check\n     *\n     * @return {boolean}\n     */\n\n\n    has(activityId) {\n      return activitiesList.hasOwnProperty(activityId);\n    }\n\n  } // Set string tag\n\n\n  _helpers__WEBPACK_IMPORTED_MODULE_1__[\"decorator\"].setStringTag()(Activities);\n  return new Activities();\n}\n\n\n\n//# sourceURL=src/activities/index.js");

/***/ }),

/***/ "./asyncEventEmitter.js":
/*!******************************!*\
  !*** ./asyncEventEmitter.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AsyncEventEmitter; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* global setImmediate */\n\n/**\n * @module asyncEventEmitter\n */\n\n/**\n * This class emit all events asynchronously by default\n *\n * @mixes module:remote-controller-server-core~external:EventEmitter\n */\n\nclass AsyncEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n  /**\n   * @param {...*} parameters\n   *\n   * @return {Promise<boolean>}\n   *\n   * @see {@link https://nodejs.org/api/events.html#events_emitter_emit_eventname_args|EventEmitter#emit}\n   */\n  async emit(...parameters) {\n    return new Promise(resolve => setImmediate(() => {\n      resolve(events__WEBPACK_IMPORTED_MODULE_0___default.a.prototype.emit.call(this, ...parameters));\n    }));\n  }\n  /**\n   * @param {...*} parameters\n   *\n   * @return {boolean}\n   *\n   * @see {@link https://nodejs.org/api/events.html#events_emitter_emit_eventname_args|EventEmitter#emit}\n   */\n\n\n  emitSync(...parameters) {\n    return events__WEBPACK_IMPORTED_MODULE_0___default.a.prototype.emit.call(this, ...parameters);\n  }\n\n}\n\n//# sourceURL=src/asyncEventEmitter.js");

/***/ }),

/***/ "./connections/connection.js":
/*!***********************************!*\
  !*** ./connections/connection.js ***!
  \***********************************/
/*! exports provided: default, uint8ArrayToUint8ArrayLike, bufferToUint8ArrayLike, uint8ArrayLikeToBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Connection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uint8ArrayToUint8ArrayLike\", function() { return uint8ArrayToUint8ArrayLike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bufferToUint8ArrayLike\", function() { return bufferToUint8ArrayLike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uint8ArrayLikeToBuffer\", function() { return uint8ArrayLikeToBuffer; });\n/* harmony import */ var _asyncEventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asyncEventEmitter */ \"./asyncEventEmitter.js\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ws */ \"../node_modules/ws/index.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _passport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../passport */ \"./passport/index.js\");\n/* harmony import */ var _idGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../idGenerator */ \"./idGenerator.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/* global global, Buffer */\n\n/**\n * @module connections/connection\n */\n\n\n\n\n\n\n\n // Error classes\n\nconst logObject = {\n  scope: 'connection',\n  class: 'Connection',\n  event: undefined,\n  module: undefined\n};\nconst Error = Object(_logger__WEBPACK_IMPORTED_MODULE_7__[\"makeClassLoggable\"])(global.Error, logObject);\n\nconst _TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_7__[\"makeClassLoggable\"])(global.TypeError, logObject);\n\nconst CLIENT_AUTHENTICATION_FACTORS = ['passport'];\nconst generateId = Object(_idGenerator__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n/**\n * @summary Connection is a {@link module:remote-controller-server-core~external:ws.WebSocket|ws.WebSocket} wrapper\n * @description\n * This class receives client's messages like this\n * <br> `'[string, *[]]'` <br>\n * and then emit an event with its name and body\n * ##### Elements\n *  | Name | Type | Attributes | Description |\n *  | --- | --- | --- | --- | --- |\n *  | `0` | `string` |   | Message's name |\n *  | `1` | `*[]` | &lt;optional> | Message's body (Every element pass as parameter to event) |\n *\n *\n * ### Messages\n * ##### Sends\n * **authentication**:  `{@link module:connections/connection#event:authentication}`\n *\n * ##### Receives\n * **authenticate**:  `object`\n *\n * | Name  | Type  | Description |\n * | --- | --- | --- |\n * | `factor`  | `string`  |  Target factor\n * | `passportInput` | `string`  | If factor is passport |\n *\n *\n * ##### Disconnect codes and descriptions\n * |  Code  | Description |\n * |  --- | --- |\n * |  `4000`  | Connection unauthenticated  |\n *\n * @mixes module:asyncEventEmitter\n */\n\nclass Connection extends _asyncEventEmitter__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {module:remote-controller-server-core~external:ws.WebSocket}\n   */\n\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {module:passport}\n   */\n\n  /**\n   * @type {{passport: boolean[], confirmation: boolean[]}}\n   */\n\n  /**\n   * @emits module:connections/connection#event:authentication\n   */\n\n  /**\n   * Transfer events from {@link module:remote-controller-server-core~external:ws.WebSocket|ws.WebSocket}, <br>\n   * Initial connection and send authentication (factor) statuses\n   *\n   * @param {object} configs\n   * @param {module:remote-controller-server-core~external:ws.WebSocket} configs.socket\n   * @param {module:remote-controller-server-core~external:http.IncomingMessage} configs.socket.request\n   * @param {object} [configs.authenticationFactors={}] Authentication factors\n   * @param {boolean} [configs.authenticationFactors.confirmation=true] Must Connection confirm before interact?\n   * @param {boolean} [configs.authenticationFactors.passport=false]\n   * @param {module:passport} [configs.passport] Required if configs.authenticationFactors.passport is set to true\n   *\n   * @emits module:connections/connection#event:authentication\n   * @emits module:connections/connection#event:connected\n   */\n  constructor(configs) {\n    if (typeof configs !== 'object') throw new _TypeError('configs parameter is required and must be object');else if (!(configs.socket instanceof ws__WEBPACK_IMPORTED_MODULE_2___default.a)) throw new _TypeError('configs.socket is required and must be ws.WebSocket');else if (!(configs.socket.request instanceof http__WEBPACK_IMPORTED_MODULE_1___default.a.IncomingMessage)) throw new _TypeError('configs.socket.request is required and must be http.IncomingMessage');else if (configs.authenticationFactors !== undefined && typeof configs.authenticationFactors !== 'object' || (configs.authenticationFactors && configs.authenticationFactors.confirmation) !== undefined && typeof configs.authenticationFactors.confirmation !== 'boolean' || (configs.authenticationFactors && configs.authenticationFactors.passport) !== undefined && typeof configs.authenticationFactors.passport !== 'boolean') throw new _TypeError('configs.authenticationFactors must be object with boolean values');\n    super(); // Set default configs\n\n    _id.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _socket.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _address.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _passport.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _authenticationFactors.set(this, {\n      writable: true,\n      value: {\n        // [Requirement, Verification]\n        passport: [false\n        /* , false */\n        ],\n        // eslint-disable-line standard/array-bracket-even-spacing\n        confirmation: [true\n        /* , false */\n        ] // eslint-disable-line standard/array-bracket-even-spacing\n\n        /**\n         * @type {boolean}\n         */\n\n      }\n    });\n\n    _binary.set(this, {\n      writable: true,\n      value: false\n    });\n\n    _emitAuthentication.set(this, {\n      writable: true,\n      value: (() => {\n        let isAuthenticateCache;\n\n        const handler = () => {\n          // Prevent emit authentication status if:\n          if (isAuthenticateCache === this.isAuthenticate || // Authentication status has no change\n          _classPrivateFieldGet(this, _authenticationFactors).confirmation[0] && // (confirmation) Only one factor passed when two factor needed\n          _classPrivateFieldGet(this, _authenticationFactors).confirmation[1] !== undefined && _classPrivateFieldGet(this, _authenticationFactors).passport[0] && _classPrivateFieldGet(this, _authenticationFactors).passport[1] === undefined || _classPrivateFieldGet(this, _authenticationFactors).confirmation[0] && // (passport) Only one factor passed when two factor needed\n          _classPrivateFieldGet(this, _authenticationFactors).confirmation[1] === undefined && _classPrivateFieldGet(this, _authenticationFactors).passport[0]) return;\n          isAuthenticateCache = this.isAuthenticate;\n          const EVENT_PROPS = ['authentication', {\n            status: this.isAuthenticate ? 1 : 2\n          }];\n          if (this.isAuthenticate) EVENT_PROPS[1].id = this.id;\n          this.emit(...EVENT_PROPS);\n          this.send(...EVENT_PROPS).catch(() => {});\n        };\n\n        handler.clearCache = () => {\n          isAuthenticateCache = undefined;\n        };\n\n        return handler;\n      })()\n    });\n\n    _passportChecker.set(this, {\n      writable: true,\n      value: passportInput => {\n        try {\n          _classPrivateFieldGet(this, _authenticationFactors).passport[1] = _classPrivateFieldGet(this, _passport).isEqual(passportInput);\n        } catch (error) {\n          _classPrivateFieldGet(this, _authenticationFactors).passport[1] = false;\n        }\n\n        const EVENT_PROPS = ['authentication', {\n          factor: 'passport',\n          status: _classPrivateFieldGet(this, _authenticationFactors).passport[1] ? 1 : 2\n        }];\n        this.emit(...EVENT_PROPS);\n        this.send(...EVENT_PROPS).catch(() => {});\n\n        _classPrivateFieldGet(this, _emitAuthentication).call(this);\n      }\n    });\n\n    _emitFirstAuthenticationFactorAsk.set(this, {\n      writable: true,\n      value: () => {\n        for (let factor in _classPrivateFieldGet(this, _authenticationFactors)) {\n          if (!_classPrivateFieldGet(this, _authenticationFactors)[factor][0] || _classPrivateFieldGet(this, _authenticationFactors)[factor][1] !== undefined) continue;\n          const EVENT_PROPS = ['authentication', {\n            factor,\n            status: 0\n          }];\n          if (factor === 'passport') EVENT_PROPS[1].type = _classPrivateFieldGet(this, _passport).type;\n          this.emit(...EVENT_PROPS);\n          this.send(...EVENT_PROPS).catch(() => {});\n          break;\n        }\n      }\n    });\n\n    _emitConnected.set(this, {\n      writable: true,\n      value: () => {\n        /**\n         * Connection connected event\n         *\n         * @event module:connections/connection#event:connected\n         */\n        return this.emit('connected');\n      }\n    });\n\n    configs = Object.assign({\n      authenticationFactors: {}\n    }, configs); // Set default authentication factors\n\n    configs.authenticationFactors = Object.assign({\n      confirmation: true,\n      passport: false\n    }, configs.authenticationFactors);\n    let withoutAuthFactor = true;\n\n    for (let factor in configs.authenticationFactors) {\n      if (!_classPrivateFieldGet(this, _authenticationFactors)[factor] || !configs.authenticationFactors[factor]) continue;\n      withoutAuthFactor = false;\n      break;\n    }\n\n    if (withoutAuthFactor) throw new Error('One authentication factor require at least');\n    if (configs.authenticationFactors.passport === true && !(configs.passport instanceof _passport__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) throw new _TypeError('configs.passport is required and must be Passport');\n\n    _classPrivateFieldSet(this, _id, generateId());\n\n    _classPrivateFieldSet(this, _socket, configs.socket);\n\n    _classPrivateFieldSet(this, _address, _classPrivateFieldGet(this, _socket).request.socket.remoteAddress);\n\n    for (let factor in _classPrivateFieldGet(this, _authenticationFactors)) {\n      _classPrivateFieldGet(this, _authenticationFactors)[factor][0] = configs.authenticationFactors[factor];\n    }\n\n    if (configs.authenticationFactors.passport) _classPrivateFieldSet(this, _passport, configs.passport); // Transform Socket events to Connection\n\n    _classPrivateFieldGet(this, _socket).emit = (eventName, ...args) => {\n      const chain = _asyncEventEmitter__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype.emit.call(_classPrivateFieldGet(this, _socket), eventName, ...args);\n      const necessaryEvents = ['message', 'disconnected', 'error']; // Change events name\n\n      if (eventName === 'close') eventName = 'disconnected';\n      if (!necessaryEvents.includes(eventName)) return chain;\n      if (eventName !== 'message') this.emit(eventName, ...args);else if (this.listenerCount(args[0].split('\"')[1])) {\n        let message = args[0];\n        let name;\n        let body;\n        necessaryEvents.splice(necessaryEvents.indexOf(eventName), 1);\n\n        try {\n          message = JSON.parse(message);\n        } catch (error) {}\n\n        if (message instanceof Array && typeof message[0] === 'string') {\n          name = message[0];\n          if (message[1] instanceof Array) body = message[1];\n        }\n\n        if (body instanceof Array) {\n          for (let dataIndex in body) {\n            const data = body[dataIndex];\n\n            if (data instanceof Array && data[0] === 'Uint8Array' && data[1] instanceof Array) {\n              body[dataIndex] = uint8ArrayLikeToBuffer(data);\n            }\n          }\n        }\n\n        if (!(body instanceof Array)) body = [];\n        if (name && (name === 'authenticate' || this.isAuthenticate) && !necessaryEvents.includes(name)) this.emit(name, ...body);\n      }\n      return chain;\n    };\n\n    this.on('authentication', event => {\n      // Emit/Send next factor ask\n      if (event.factor === 'passport') {\n        if (!this.isAuthenticate && _classPrivateFieldGet(this, _authenticationFactors).confirmation[0] && event.status === 1) {\n          const EVENT_PROPS = ['authentication', {\n            factor: 'confirmation',\n            status: 0\n          }];\n          this.emit(...EVENT_PROPS);\n          this.send(...EVENT_PROPS).catch(() => {});\n        }\n      } else if (event.factor === undefined && // Disconnect when connection unauthenticated\n      event.status === 2) this.disconnect(4000, 'Connection unauthenticated');\n    });\n    this.on('authenticate', event => {\n      if (!_classPrivateFieldGet(this, _authenticationFactors)[event.factor] || !_classPrivateFieldGet(this, _authenticationFactors)[event.factor][0] || _classPrivateFieldGet(this, _authenticationFactors)[event.factor][1] || !CLIENT_AUTHENTICATION_FACTORS.includes(event.factor)) return;\n      if (event.factor === 'passport') _classPrivateFieldGet(this, _passportChecker).call(this, event.passportInput);\n    });\n    if (this.isConnect) _classPrivateFieldGet(this, _emitConnected).call(this);\n\n    _classPrivateFieldGet(this, _emitFirstAuthenticationFactorAsk).call(this);\n  }\n  /**\n   * @summary Send message to client\n   * @description\n   * If each element of body is instanceof Buffer <br>\n   * convert to Uint8Array then convert to pure array <br>\n   * then send as {@link module:connections/connection~Uint8ArrayLike|Uint8ArrayLike} . <br>\n   * This method create an array and push name and body to it like this <br>\n   * `[name, [...body]]` <br>\n   * and then serialize it to string and send to client\n   *\n   * @param {string} name Message's name\n   * @param {...*} [body] Message's content\n   * @param {function} [callback] This function listens to event with the same name just once\n   *\n   * @async\n   * @return {Promise<(void|Error)>}\n   * * Rejection\n   *  * Reject an error if Connection is not authenticated\n   *  * Reject an error if Connection is not connected\n   */\n\n\n  send(name, ...body) {\n    const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_7__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n      method: 'send',\n      ...this[_logger__WEBPACK_IMPORTED_MODULE_7__[\"logSymbol\"]]\n    });\n    if (typeof name !== 'string') throw new _TypeError('name parameter is required and must be string');\n    return (async () => {\n      if (name !== 'authentication' && !this.isAuthenticate) throw new Error('Connection is not authenticated');else if (!this.isConnect) throw new Error('Connection is not connected');\n      let message = [name, body];\n      let callback;\n      if (typeof body[body.length - 1] === 'function') callback = body.splice(body.length - 1, 1)[0];\n\n      for (let dataIndex in body) {\n        const data = body[dataIndex];\n        if (data instanceof Buffer) body[dataIndex] = bufferToUint8ArrayLike(data);else if (data instanceof Uint8Array) body[dataIndex] = uint8ArrayToUint8ArrayLike(data);\n      }\n\n      message = JSON.stringify(message);\n      if (_classPrivateFieldGet(this, _binary)) message = Buffer.from(message);\n      return new Promise(resolve => _classPrivateFieldGet(this, _socket).send(message, undefined, resolve)).then(() => {\n        if (typeof callback === 'function') this.once(name, callback);\n      });\n    })();\n  }\n  /**\n   * @summary Send message in binary type to client\n   * @description Same as {@link module:connections/connection#send}\n   *\n   * @param {string} name Message's name\n   * @param {...*} [body] Message's content\n   * @param {function} [callback] This function listens to event with the same name just once\n   *\n   * @async\n   * @return {Promise<(void|Error)>}\n   *\n   * @see module:connections/connection#send\n   */\n\n\n  sendBinary(name, ...body) {\n    _classPrivateFieldSet(this, _binary, true);\n\n    const result = this.send(name, ...body);\n\n    _classPrivateFieldSet(this, _binary, false);\n\n    return result;\n  }\n  /**\n   * Disconnect Connection\n   *\n   * @param {number} [code]\n   * @param {string} [description]\n   *\n   * @emits module:connections/connection#event:disconnected\n   *\n   * @return {void}\n   */\n\n\n  disconnect(code, description) {\n    if (code !== undefined && typeof code !== 'number') throw new _TypeError('code parameter must be number');else if (description !== undefined && typeof description !== 'string') throw new _TypeError('description parameter must be string');\n    /**\n     * @summary Connection disconnected event\n     * @description\n     * Same as {@link module:remote-controller-server-core~external:ws.WebSocket|ws.WebSocket} close event\n     *\n     * @event module:connections/connection#event:disconnected\n     *\n     * @see module:remote-controller-server-core~external:ws.WebSocket\n     */\n\n    if (_classPrivateFieldGet(this, _socket).readyState !== ws__WEBPACK_IMPORTED_MODULE_2___default.a.CLOSED || _classPrivateFieldGet(this, _socket).readyState !== ws__WEBPACK_IMPORTED_MODULE_2___default.a.CLOSING) _classPrivateFieldGet(this, _socket).close(code, description);\n  }\n  /**\n   * Mark this Connection as confirmed\n   *\n   * @param {boolean} [confirmation=true]\n   *\n   * @emits module:connections/connection#event:authentication\n   *\n   * @return {void}\n   */\n\n\n  confirm(confirmation = true) {\n    confirmation = Boolean(confirmation);\n    if (_classPrivateFieldGet(this, _authenticationFactors).confirmation[1] === confirmation) return;\n    _classPrivateFieldGet(this, _authenticationFactors).confirmation[1] = confirmation;\n    const EVENT_PROPS = ['authentication', {\n      factor: 'confirmation',\n      status: _classPrivateFieldGet(this, _authenticationFactors).confirmation[1] ? 1 : 2\n    }];\n    this.emit(...EVENT_PROPS);\n    this.send(...EVENT_PROPS).catch(() => {});\n\n    _classPrivateFieldGet(this, _emitAuthentication).call(this);\n  }\n  /**\n   * Get Connection authentication status\n   *\n   * @type {boolean}\n   */\n\n\n  get isAuthenticate() {\n    let authenticated = false;\n\n    for (let factor in _classPrivateFieldGet(this, _authenticationFactors)) {\n      if (_classPrivateFieldGet(this, _authenticationFactors)[factor][0]) {\n        authenticated = _classPrivateFieldGet(this, _authenticationFactors)[factor][1];\n        if (!authenticated) break;\n      }\n    }\n\n    return !!authenticated;\n  }\n  /**\n   * Get Client IP\n   *\n   * @type {string}\n   */\n\n\n  get address() {\n    return _classPrivateFieldGet(this, _address);\n  }\n  /**\n   * @type {boolean}\n   */\n\n\n  get isConnect() {\n    return _classPrivateFieldGet(this, _socket).readyState === ws__WEBPACK_IMPORTED_MODULE_2___default.a.OPEN;\n  }\n  /**\n   * Connection id\n   *\n   * @type {number}\n   */\n\n\n  get id() {\n    return _classPrivateFieldGet(this, _id);\n  }\n  /**\n   * @type {module:remote-controller-server-core~external:ws.WebSocket}\n   */\n\n\n  get socket() {\n    return _classPrivateFieldGet(this, _socket);\n  }\n  /**\n   * @param socket\n   *\n   * @emits module:connections/connection#event:connected\n   * @emits module:connections/connection#event:authentication\n   */\n\n\n  set socket(socket) {\n    if (!(socket instanceof ws__WEBPACK_IMPORTED_MODULE_2___default.a)) throw new _TypeError('Value must be ws.WebSocket'); // Reset authentication factors\n\n    for (const factorKey of CLIENT_AUTHENTICATION_FACTORS) {\n      delete _classPrivateFieldGet(this, _authenticationFactors)[factorKey][1];\n    }\n\n    _classPrivateFieldGet(this, _emitAuthentication).clearCache(); // Replace emit method with our customized one\n\n\n    socket.emit = _classPrivateFieldGet(this, _socket).emit; // Change previous socket's emit method with it's default\n\n    _classPrivateFieldGet(this, _socket).emit = _asyncEventEmitter__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype.emit; // Replace private properties\n\n    _classPrivateFieldSet(this, _socket, socket);\n\n    _classPrivateFieldSet(this, _address, _classPrivateFieldGet(this, _socket).request.socket.remoteAddress);\n\n    if (this.isConnect) _classPrivateFieldGet(this, _emitConnected).call(this);\n\n    _classPrivateFieldGet(this, _emitFirstAuthenticationFactorAsk).call(this);\n\n    _classPrivateFieldGet(this, _emitAuthentication).call(this);\n  }\n\n  get [_logger__WEBPACK_IMPORTED_MODULE_7__[\"logSymbol\"]]() {\n    return {\n      connection: {\n        id: this.id,\n        address: this.address,\n        isConnect: this.isConnect,\n        isAuthenticate: this.isAuthenticate\n      }\n    };\n  }\n  /**\n   * Set preferred options for nodejs fs.createReadStream method\n   *\n   * * Read 1.0625 megabyte per chunk\n   *\n   * @param {object} [options={}]\n   * @param {boolean} [overwrite=true] Write to the same object or create a new one\n   *\n   * @returns {Object}\n   */\n\n\n  static setReadStreamDefaults(options, overwrite = true) {\n    if (typeof options !== 'object') options = {};\n    let result; // Byte Per Chunk\n\n    const BPC = 1062500;\n    const DEFAULTS = {\n      end: BPC,\n      highWaterMark: BPC + 1,\n      multiChunks: true\n    };\n    const optionsCache = Object.assign(Object.create(null), options);\n\n    if (typeof optionsCache.end !== 'number') {\n      DEFAULTS.end = (typeof optionsCache.start === 'number' ? optionsCache.start : 0) + BPC;\n    }\n\n    if (typeof optionsCache.highWaterMark === 'number') optionsCache.highWaterMark++;\n    result = Object.assign(overwrite ? options : {}, DEFAULTS, optionsCache);\n\n    if (result.end - result.start + 1 < result.highWaterMark) {\n      result.highWaterMark = result.end - result.start + 1;\n    }\n\n    return result;\n  }\n  /**\n   * A helper to read readable stream chunks\n   *\n   * @param {module:remote-controller-server-core~external:stream.Readable} readableStream\n   * @param {boolean} [multiChunk=true]\n   *\n   * @returns {module:connections/connection~streamChunksReader}\n   *\n   * @example\n   * let streamOptions = {@link module:connections/connection.setReadStreamDefaults|Connection.setReadStreamDefaults}({ end: 1062500 * 5 })\n   * let readableStream = fs.createReadStream('Big.File', streamOptions)\n   * ;(async function () {\n   *    for await (const someChunks of {@link module:connections/connection.readStreamChunks|Connection.readStreamChunks}(readableStream, false)()) {\n   *      await {@link module:connections/connection#send|connection.send}('bigFile', streamOptions, ...someChunks)\n   *    }\n   *  })()\n   */\n\n\n  static readStreamChunks(readableStream, multiChunk = true) {\n    if (!(readableStream instanceof stream__WEBPACK_IMPORTED_MODULE_5___default.a.Readable)) {\n      throw new _TypeError('readableStream parameter is required and must be stream.Readable');\n    }\n    /**\n     * Resolve an array of chunks. <br>\n     * * `{@link module:connections/connection.readStreamChunks|readStreamChunks}(multiChunk = true)`:\n     * Resolve an array that contains **all** the chunks.\n     * * `{@link module:connections/connection.readStreamChunks|readStreamChunks}(multiChunk = false)`:\n     * Resolve an array that contains **one** chunk in every iteration.\n     *\n     * @name module:connections/connection~streamChunksReader\n     * @generator\n     * @async\n     *\n     * @returns {AsyncIterableIterator<Buffer[]>}\n     */\n\n\n    async function* streamChunksReader() {\n      const chunks = [];\n\n      while (!readableStream.closed) {\n        readableStream.resume();\n        let closeListener;\n        let dataListener;\n        const chunk = await Promise.race([new Promise(resolve => readableStream.once('data', dataListener = data => {\n          // eslint-disable-line no-return-assign\n          readableStream.pause();\n          resolve(data);\n        })), new Promise(resolve => readableStream.once('close', closeListener = resolve)) // eslint-disable-line no-return-assign\n        ]);\n        readableStream.off('data', dataListener);\n        readableStream.off('close', closeListener);\n\n        if (chunk) {\n          if (multiChunk) chunks.push(chunk);else yield [chunk];\n        }\n      }\n\n      if (multiChunk) yield chunks;\n    }\n\n    return streamChunksReader;\n  }\n\n} // Set string tag\n\nvar _id = new WeakMap();\n\nvar _socket = new WeakMap();\n\nvar _address = new WeakMap();\n\nvar _passport = new WeakMap();\n\nvar _authenticationFactors = new WeakMap();\n\nvar _binary = new WeakMap();\n\nvar _emitAuthentication = new WeakMap();\n\nvar _passportChecker = new WeakMap();\n\nvar _emitFirstAuthenticationFactorAsk = new WeakMap();\n\nvar _emitConnected = new WeakMap();\n\n_helpers__WEBPACK_IMPORTED_MODULE_6__[\"decorator\"].setStringTag()(Connection);\n/**\n * Convert uint8Array to pure array then uint8ArrayLike\n *\n * @param {Uint8Array} uint8Array\n *\n * @returns {module:connections/connection~Uint8ArrayLike}\n */\n\nfunction uint8ArrayToUint8ArrayLike(uint8Array) {\n  return ['Uint8Array', Array.from(uint8Array)];\n}\n/**\n * Convert buffer to uint8Array then uint8ArrayLike\n *\n * @param {Buffer} buffer\n *\n * @returns {module:connections/connection~Uint8ArrayLike}\n */\n\nfunction bufferToUint8ArrayLike(buffer) {\n  const arrayBuffer = new ArrayBuffer(buffer.length);\n  const uint8Array = new Uint8Array(arrayBuffer);\n\n  for (let index = 0; index < buffer.length; index++) {\n    uint8Array[index] = buffer[index];\n  }\n\n  return uint8ArrayToUint8ArrayLike(uint8Array);\n}\n/**\n * Convert uint8ArrayLike to buffer\n *\n * @param {module:connections/connection~Uint8ArrayLike} uint8ArrayLike\n *\n * @returns {Buffer}\n */\n\nfunction uint8ArrayLikeToBuffer(uint8ArrayLike) {\n  return Buffer.from(Uint8Array.from(uint8ArrayLike[1]));\n}\n/**\n * Binary style use for send and receive <br>\n * `[\"Uint8Array\", arrayFromUint8Array]`\n *\n * @typedef {array} module:connections/connection~Uint8ArrayLike\n * @property {string} 0 This element always is Uint8Array\n * @property {Array} 1 An array that contains uint8Array's data\n */\n\n/**\n * Connection authentication status\n *\n * @event module:connections/connection#event:authentication\n *\n * @type {object}\n * @property {string} factor Authentication factor's name that it's state changed\n * @property {number} status\n * Authentication (factor) status\n *\n * | Value | Description |\n * | --- | --- |\n * | `0` | Ask for authentication factor |\n * | `1` | Allowed |\n * | `2` | Denied |\n *\n * @property {string} type\n * Depend on factor\n *\n * |  Factor  | Description |\n * | --- | --- |\n * |  `passport`  | Type of passport |\n */\n\n//# sourceURL=src/connections/connection.js");

/***/ }),

/***/ "./connections/index.js":
/*!******************************!*\
  !*** ./connections/index.js ***!
  \******************************/
/*! exports provided: default, Connection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makeConnections; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ws */ \"../node_modules/ws/index.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./connection */ \"./connections/connection.js\");\n/* harmony import */ var _passport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../passport */ \"./passport/index.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Connection\", function() { return _connection__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/* global global, console */\n\n/**\n * @module connections\n */\n\n\n\n\n\n\n // Error classes\n\nconst logObject = {\n  scope: 'makeConnections',\n  module: 'connections',\n  event: undefined\n};\nconst Error = Object(_logger__WEBPACK_IMPORTED_MODULE_6__[\"makeClassLoggable\"])(global.Error, logObject);\n\nconst _TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_6__[\"makeClassLoggable\"])(global.TypeError, logObject);\n\nconst GLOBAL_ERRORS = {\n  authenticationFactorsRequirement: new Error('One authentication factor require at least')\n  /**\n   * makeConnections creates connections module\n   *\n   * @return {module:connections~Connections}\n   */\n\n};\nfunction makeConnections() {\n  const logger = this.logger;\n  const connectionsList = new Map();\n\n  const preference = (defaults => {\n    const NAME = 'connections';\n    let preference;\n\n    try {\n      preference = this.preferences.add(NAME, defaults);\n    } catch (error) {\n      if (error.message === `${NAME} is already exist`) {\n        try {\n          preference = this.preferences.get(NAME);\n        } catch (error) {\n          throw error;\n        }\n      } else throw error;\n    }\n\n    try {\n      Object.defineProperty(preference, 'defaults', {\n        value: defaults\n      });\n    } catch (error) {}\n\n    return preference;\n  })(Object.freeze({\n    /** @type {object} */\n    authenticationFactors: Object.freeze({\n      /** @type {boolean} */\n      confirmation: true,\n\n      /** @type {boolean} */\n      passport: false\n    }),\n\n    /** @type {{type: string, hash: number[], salt: number[]}} */\n    passport: undefined,\n\n    /** @type {number} */\n    removeTimeout: 1000 * 60 * 30\n  }));\n  /**\n   * @summary Connections module is a Connection holder/manager\n   * @description\n   * ##### Disconnect codes and descriptions\n   * |  Code  | Description |\n   * |  --- | --- |\n   * |  `4001`  | Previous connection that requested is not exist  |\n   * |  `4002`  | Previous connection that requested is already connect  |\n   *\n   * @memberOf module:connections\n   * @inner\n   *\n   * @mixes module:remote-controller-server-core~external:EventEmitter\n   */\n\n\n  class Connections extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n    constructor(...args) {\n      super(...args);\n\n      _authenticationFactors.set(this, {\n        writable: true,\n        value: {\n          /**\n           * @summary Authentication confirmation factor requirement\n           * @description To reset to default value set it to `null` <br>\n           * Default: `true`\n           *\n           * @memberOf module:connections~Connections#authenticationFactors\n           *\n           * @type {boolean}\n           */\n          get confirmation() {\n            return preference.body.authenticationFactors.confirmation;\n          },\n\n          set confirmation(value) {\n            if (typeof value === 'boolean' || value === null) {\n              if (value === false && !this.passport) {\n                throw GLOBAL_ERRORS.authenticationFactorsRequirement.setLogObject({\n                  setter: 'confirmation'\n                });\n              }\n\n              preference.updateSync(body => {\n                if (value !== null) body.authenticationFactors.confirmation = value;else body.authenticationFactors.confirmation = preference.defaults.authenticationFactors.confirmation;\n                return body;\n              });\n            }\n          },\n\n          /**\n           * @summary Authentication passport factor requirement\n           * @description To reset to default value set it to `null` <br>\n           * Default: `false`\n           *\n           * @memberOf module:connections~Connections#authenticationFactors\n           *\n           * @type {boolean}\n           */\n          get passport() {\n            return preference.body.authenticationFactors.passport;\n          },\n\n          set passport(value) {\n            if (typeof value === 'boolean' || value === null) {\n              if (value === false && !this.confirmation) {\n                throw GLOBAL_ERRORS.authenticationFactorsRequirement.setLogObject({\n                  setter: 'passport'\n                });\n              }\n\n              preference.updateSync(body => {\n                if (value !== null) body.authenticationFactors.passport = value;else body.authenticationFactors.passport = preference.defaults.authenticationFactors.passport;\n                return body;\n              });\n            }\n          }\n\n        }\n      });\n\n      _passport.set(this, {\n        writable: true,\n        value: void 0\n      });\n\n      _binary.set(this, {\n        writable: true,\n        value: false\n      });\n    }\n\n    /**\n     * Authentication factors requirement\n     *\n     * @namespace module:connections~Connections#authenticationFactors\n     */\n    get authenticationFactors() {\n      return _classPrivateFieldGet(this, _authenticationFactors);\n    }\n    /**\n     * @summary Authentication passport factor\n     * @description To reset to default value set it to `null` <br>\n     * Default: `undefined`\n     *\n     * @type {module:passport}\n     */\n\n\n    get passport() {\n      if (!(_classPrivateFieldGet(this, _passport) instanceof _passport__WEBPACK_IMPORTED_MODULE_4__[\"default\"])) {\n        const passportDetails = preference.body.passport;\n\n        _classPrivateFieldSet(this, _passport, passportDetails ? _passport__WEBPACK_IMPORTED_MODULE_4__[\"default\"].from(passportDetails.type, passportDetails) : undefined);\n      }\n\n      return _classPrivateFieldGet(this, _passport);\n    }\n\n    set passport(value) {\n      if (value instanceof _passport__WEBPACK_IMPORTED_MODULE_4__[\"default\"] || value === null) {\n        preference.updateSync(body => {\n          if (value !== null) {\n            body.passport = {\n              type: value.type,\n              hash: value.hash.toJSON().data,\n              salt: value.salt.toJSON().data\n            };\n          } else body.passport = preference.defaults.passport;\n\n          return body;\n        });\n\n        _classPrivateFieldSet(this, _passport, value !== null ? value : preference.defaults.passport);\n      }\n    }\n    /**\n     * @summary Connections will remove after this time in millisecond when disconnect\n     * @description To reset to default value set it to `null` <br>\n     * Default: `1800000` (30 minutes)\n     *\n     * @type {number}\n     */\n\n\n    get removeTimeout() {\n      return preference.body.removeTimeout;\n    }\n\n    set removeTimeout(value) {\n      if (typeof value === 'number' || value === null) {\n        preference.updateSync(body => {\n          if (value !== null) {\n            body.removeTimeout = value;\n          } else body.removeTimeout = preference.defaults.removeTimeout;\n\n          return body;\n        });\n      }\n    }\n    /**\n     * Add and initial connection\n     *\n     * @param {(module:remote-controller-server-core~external:ws.WebSocket|module:connections/connection)} socket\n     * @param {module:remote-controller-server-core~external:http.IncomingMessage} [request] Is not require when socket parameter is a {@link module:connections/connection|Connection}\n     *\n     * @throws Will throw an error if previous connection that requested is not exist\n     * @throws Will throw an error if previous connection is already connect\n     *\n     * @emits module:connections~Connections#event:connected\n     * @emits module:connections~Connections#event:disconnected\n     * @emits module:connections~Connections#event:added\n     *\n     * @return {module:connections/connection}\n     */\n\n\n    add(socket, request) {\n      const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_6__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n        method: 'add'\n      });\n      if (!(socket instanceof ws__WEBPACK_IMPORTED_MODULE_2___default.a) && !(socket instanceof _connection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) throw new _TypeError('socket parameter is required and must be ws.WebSocket/Connection');else if (socket instanceof ws__WEBPACK_IMPORTED_MODULE_2___default.a && !(request instanceof http__WEBPACK_IMPORTED_MODULE_1___default.a.IncomingMessage)) throw new _TypeError('request parameter is required and must be http.IncomingMessage');\n      let connection = socket instanceof _connection__WEBPACK_IMPORTED_MODULE_3__[\"default\"] ? socket : undefined;\n      let isNew = true;\n\n      if (connection === undefined) {\n        socket.request = request;\n        socket.request.previousSocketId = new URLSearchParams(request.url.split('?')[1]).get('id');\n        isNew = socket.request.previousSocketId === null;\n\n        if (isNew) {\n          // Create new Connection instance\n          delete socket.request.previousSocketId;\n          connection = new _connection__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n            socket,\n            authenticationFactors: this.authenticationFactors,\n            passport: this.passport\n          });\n        } else {\n          // Change an existing connection's socket\n          if (!connectionsList.has(socket.request.previousSocketId)) {\n            const ERROR = new Error('Previous connection that requested is not exist');\n            socket.close(4001, ERROR.message);\n            throw ERROR;\n          }\n\n          connection = connectionsList.get(socket.request.previousSocketId);\n\n          if (connection.isConnect) {\n            const ERROR = new Error('Previous connection that requested is already connect');\n            socket.close(4002, ERROR.message);\n            throw ERROR;\n          }\n\n          connection.socket = socket;\n        }\n      }\n\n      if (isNew) {\n        connectionsList.set(connection.id, connection);\n        let removeTimeOut; // Transfer events\n\n        /**\n         * @summary Connections connected event\n         * @description First parameter is the target connection\n         *\n         * @event module:connections~Connections#event:connected\n         *\n         * @type {module:connections/connection}\n         *\n         * @see module:connections/connection#event:connected\n         */\n\n        connection.on('connected', (...parameters) => {\n          clearTimeout(removeTimeOut);\n          this.emit('connected', connection, ...parameters);\n        });\n        /**\n         * @summary Connections disconnected event\n         * @description First parameter is the target connection\n         *\n         * @event module:connections~Connections#event:disconnected\n         *\n         * @type {module:connections/connection}\n         *\n         * @see module:connections/connection#event:disconnected\n         */\n\n        connection.on('disconnected', (...parameters) => {\n          removeTimeOut = setTimeout(() => {\n            this.remove(connection);\n          }, this.removeTimeout);\n          this.emit('disconnected', connection, ...parameters);\n        });\n      }\n      /**\n       * Connections added event\n       *\n       * @event module:connections~Connections#event:added\n       *\n       * @type {module:connections/connection}\n       */\n\n\n      this.emit('added', connection);\n      return connection;\n    }\n    /**\n     * @summary Get specific connection or all connected list\n     * @description\n     * When call this method without id parameter, returned object is iterable (over values) <br>\n     * `Object.values({@link module:connections~Connections#get|connections.get()})[Symbol.iterator]`\n     * is same as\n     * `{@link module:connections~Connections#get|connections.get()}[Symbol.iterator]`\n     *\n     * @param  {string} [id]\n     *\n     * @return {(module:connections/connection|object<string, module:connections/connection>)}\n     */\n\n\n    get(id) {\n      if (id !== undefined && typeof id !== 'string') throw new _TypeError('id parameter must be string');\n      if (id) return connectionsList.get(id);\n      const connectedListPrototype = {\n        length: 0,\n        [Symbol.iterator]: _helpers__WEBPACK_IMPORTED_MODULE_5__[\"object\"].iterateOverValues\n      };\n      const connectedList = Object.create(connectedListPrototype);\n\n      for (const connection of connectionsList.values()) {\n        if (connection.isConnect) {\n          connectedList[connection.id] = connection;\n          connectedListPrototype.length++;\n        }\n      }\n\n      return connectedList;\n    }\n    /**\n     * Remove connection from list\n     *\n     * @param {(module:connections/connection|string)} connection Instance of Connection or connection's id\n     *\n     * @emits module:connections~Connections#event:removed\n     *\n     * @return {boolean}\n     */\n\n\n    remove(connection) {\n      if (!(connection instanceof _connection__WEBPACK_IMPORTED_MODULE_3__[\"default\"]) && typeof connection !== 'string') throw new _TypeError('connection parameter is required and must be Connection/string');\n      if (typeof connection === 'string') connection = connectionsList.get(connection);\n      let result = false;\n\n      if (connection instanceof _connection__WEBPACK_IMPORTED_MODULE_3__[\"default\"]) {\n        connection.disconnect();\n        result = connectionsList.delete(connection.id);\n      }\n      /**\n       * Connections removed event\n       *\n       * @event module:connections~Connections#event:removed\n       *\n       * @type {module:connections/connection}\n       */\n\n\n      if (result) this.emit('removed', connection);\n      return result;\n    }\n    /**\n     * Check Connection is already exist\n     *\n     * @param {string} connectionId Connection's id to check\n     *\n     * @return {boolean}\n     */\n\n\n    has(connectionId) {\n      return connectionsList.has(connectionId);\n    }\n    /**\n     * Send broadcast message to clients (connected and authenticated connections)\n     *\n     * @param {string} name Message's name\n     * @param {...*} [body] Message's content\n     * @param {function} [callback] This function listens to event with the same name just once\n     *\n     * @return {Promise<(void|Error)>}\n     */\n\n\n    send(name, ...body) {\n      if (typeof name !== 'string') throw new _TypeError('name parameter is required and must be string');\n\n      const binary = _classPrivateFieldGet(this, _binary);\n\n      return (async () => {\n        for (const connection of this.get()) {\n          if (connection.isAuthenticate) {\n            if (!binary) await connection.send(name, ...body);else await connection.sendBinary(name, ...body);\n          }\n        }\n      })();\n    }\n    /**\n     * @summary Send broadcast message in binary type to clients (connected and authenticated connections)\n     * @description same as {@link module:connections~Connections#send}\n     *\n     * @param {string} name Message's name\n     * @param {...*} [body] Message's content\n     * @param {function} [callback] This function listens to event with the same name just once\n     *\n     * @return {Promise<(void|Error)>}\n     *\n     * @see module:connections~Connections#send\n     */\n\n\n    sendBinary(name, ...body) {\n      _classPrivateFieldSet(this, _binary, true);\n\n      const result = this.send(name, ...body);\n\n      _classPrivateFieldSet(this, _binary, false);\n\n      return result;\n    }\n\n    get [_logger__WEBPACK_IMPORTED_MODULE_6__[\"logSymbol\"]]() {\n      return {\n        connections: {\n          authenticationFactors: this.authenticationFactors,\n          removeTimeout: this.removeTimeout,\n          passport: this.passport !== undefined ? this.passport.toString() : undefined\n        }\n      };\n    }\n\n  } // Set string tag\n\n\n  var _authenticationFactors = new WeakMap();\n\n  var _passport = new WeakMap();\n\n  var _binary = new WeakMap();\n\n  _helpers__WEBPACK_IMPORTED_MODULE_5__[\"decorator\"].setStringTag()(Connections);\n  const connections = new Connections() // Logging\n  ;\n\n  (() => {\n    const loggedList = new WeakSet();\n    connections.on('connected', connection => {\n      if (true) {\n        console.log(connection.id, 'Connected', connection.address);\n      }\n\n      logger.info('makeConnections', {\n        module: 'connections',\n        event: 'connected'\n      }, connection);\n\n      if (!loggedList.has(connection)) {\n        connection.on('authentication', event => {\n          let state;\n\n          switch (event.factor) {\n            case undefined:\n              state = ['connection authenticated', 'connection unauthenticated'][event.status - 1];\n              break;\n\n            case 'confirmation':\n              state = ['connection ask for confirmation', 'connection confirmation allowed', 'connection confirmation denied'][event.status];\n              break;\n\n            case 'passport':\n              state = ['connection ask for passport', 'connection passport allowed', 'connection passport denied'][event.status];\n              break;\n          }\n\n          if (true) {\n            console.log(connection.id, state);\n          }\n\n          logger.info('makeConnections', {\n            module: 'connections',\n            event: 'authentication',\n            status: state\n          }, connection, {\n            _event: event\n          });\n        });\n        loggedList.add(connection);\n      }\n    });\n    connections.on('disconnected', connection => {\n      const state = 'disconnected';\n\n      if (true) {\n        console.log(connection.id, state, connection.address);\n      }\n\n      logger.info('makeConnections', {\n        module: 'connections',\n        event: state\n      }, connection);\n    });\n    preference.on('updated', () => logger.info('makeConnections', {\n      module: 'preference',\n      event: 'updated'\n    }, connections, preference));\n  })();\n\n  return connections;\n}\n\n\n\n//# sourceURL=src/connections/index.js");

/***/ }),

/***/ "./engine/index.js":
/*!*************************!*\
  !*** ./engine/index.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makeEngine; });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ws */ \"../node_modules/ws/index.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* global global */\n\n/**\n * @module engine\n */\n\n\n\n\n\n\n\n/**\n * makeEngine creates engine module\n *\n * @param {object} [configs={}]\n * @param {number} [configs.port=7777] Server's port\n * @param {string} [configs.path=\"/\"] WebSocket's path\n *\n * @return {module:engine~Engine}\n */\n\nfunction makeEngine(configs = Object.create(null)) {\n  // Error classes\n  const logObject = {\n    scope: 'makeEngine',\n    event: undefined,\n    module: undefined\n  };\n  const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_5__[\"makeClassLoggable\"])(global.Error, logObject);\n  const TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_5__[\"makeClassLoggable\"])(global.TypeError, logObject);\n  if (typeof configs !== 'object') throw new TypeError('configs parameter must be object'); // Set default configs\n\n  configs = Object.assign({\n    port: 7777,\n    path: '/'\n  }, configs);\n  if (typeof configs.port !== 'number') throw new TypeError('configs.port must be number');else if (typeof configs.path !== 'string') throw new TypeError('configs.path must be string');else if (!configs.path.startsWith('/')) throw new Error('configs.path must starts with \"/\"');\n  const logger = this.logger;\n  const connections = this.connections;\n  const httpServer = http__WEBPACK_IMPORTED_MODULE_3___default.a.createServer();\n  const webSocketServer = new ws__WEBPACK_IMPORTED_MODULE_4___default.a.Server({\n    server: httpServer,\n    path: configs.path,\n    perMessageDeflate: true\n  });\n  logObject.module = 'engine';\n  Error.setLogObject(logObject);\n  TypeError.setLogObject(logObject);\n  /**\n   * Engine module control web server and it's websocket\n   *\n   * @memberOf module:engine\n   * @inner\n   *\n   * @mixes module:remote-controller-server-core~external:EventEmitter\n   */\n\n  class Engine extends events__WEBPACK_IMPORTED_MODULE_1___default.a {\n    constructor() {\n      super();\n      webSocketServer.on('connection', (...parameters) => {\n        const logParameters = {\n          socket: {\n            readyState: parameters[0].readyState,\n            bufferedAmount: parameters[0].bufferedAmount,\n            extensions: parameters[0].extensions\n          },\n          request: {\n            url: parameters[1].url,\n            socket: {\n              address: parameters[1].socket.address,\n              remoteAddress: parameters[1].socket.remoteAddress,\n              remoteFamily: parameters[1].socket.remoteFamily,\n              remotePort: parameters[1].socket.remotePort,\n              localAddress: parameters[1].socket.localAddress,\n              localPort: parameters[1].socket.localPort\n            }\n          }\n        };\n\n        try {\n          logger.info('engine', {\n            module: 'ws.Server',\n            event: 'connection'\n          }, logParameters);\n          connections.add(...parameters);\n        } catch (error) {\n          logger.error('engine', {\n            module: 'connections',\n            method: 'add'\n          }, error, logParameters);\n        }\n      });\n    }\n    /**\n     * Start engine\n     *\n     * @param {number} [port=module:engine~configs.port]\n     *\n     * @emits module:engine~Engine#event:started\n     *\n     * @async\n     * @returns {Promise<(void|Error)>}\n     * * Rejection\n     *  * Reject an error if engine started before\n     *  * Reject an error if there is no network\n     */\n\n\n    start(port = configs.port) {\n      const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_5__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n        method: 'start',\n        ...this[_logger__WEBPACK_IMPORTED_MODULE_5__[\"logSymbol\"]]\n      });\n      if (typeof port !== 'number') throw new TypeError('port parameter must be number');\n      return (async () => {\n        if (this.isActive) throw new Error('Engine already started');else if (getNetworkIP() === null) throw new Error('Network is not available');\n        configs.port = port;\n        /**\n         * Engine started event\n         *\n         * @event module:engine~Engine#event:started\n         */\n\n        const fireEvent = () => {\n          this.emit('started');\n        };\n\n        await Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(httpServer.listen.bind(httpServer))({\n          port,\n          host: '0.0.0.0'\n        });\n        fireEvent();\n      })();\n    }\n    /**\n     * Stop engine\n     *\n     * @emits module:engine~Engine#event:stopped\n     *\n     * @returns {Promise<(void|Error)>}\n     * * Rejection\n     *  * Reject an error if engine stopped before\n     */\n\n\n    async stop() {\n      const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_5__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n        method: 'stop',\n        ...this[_logger__WEBPACK_IMPORTED_MODULE_5__[\"logSymbol\"]]\n      });\n      if (!this.isActive) throw new Error('Engine already stopped');\n      /**\n       * Engine stopped event\n       *\n       * @event module:engine~Engine#event:stopped\n       */\n\n      const fireEvent = () => {\n        this.emit('stopped');\n      };\n\n      for (const webSocket of webSocketServer.clients) {\n        webSocket.close();\n      }\n\n      await Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(httpServer.close.bind(httpServer))();\n      fireEvent();\n    }\n    /**\n     * Get server address\n     *\n     * @example\n     * { address: '192.168.1.2', family: 'IPv4', port: 7777, path: '/'}\n     *\n     * @type {{address: (string|null), family: string, port: number}}\n     *\n     * @see {@link https://github.com/websockets/ws/blob/master/doc/ws.md#serveraddress|WebSocket.Server#address method}\n     */\n\n\n    get address() {\n      const ADDRESS = webSocketServer.address() || {};\n      const ADDRESS_CACHE = Object.assign(Object.create(null), ADDRESS);\n      Object.assign(ADDRESS, {\n        family: 'IPv4',\n        port: configs.port,\n        path: configs.path\n      }, ADDRESS_CACHE, {\n        address: getNetworkIP()\n      });\n      return ADDRESS;\n    }\n    /**\n     * Get server listening status\n     *\n     * @type {boolean}\n     */\n\n\n    get isActive() {\n      return httpServer.listening;\n    }\n    /**\n     * Get http server instance that in use\n     *\n     * @type {module:remote-controller-server-core~external:http.Server}\n     */\n\n\n    get httpServer() {\n      return httpServer;\n    }\n\n    get [_logger__WEBPACK_IMPORTED_MODULE_5__[\"logSymbol\"]]() {\n      return {\n        engine: {\n          address: this.address,\n          isActive: this.isActive\n        }\n      };\n    }\n\n  } // Set string tag\n\n\n  _helpers__WEBPACK_IMPORTED_MODULE_6__[\"decorator\"].setStringTag()(Engine);\n  const engine = new Engine() // Logging\n  ;\n\n  (() => {\n    engine.on('started', () => {\n      logger.info('makeEngine', {\n        module: 'engine',\n        event: 'started'\n      }, engine);\n    });\n    engine.on('stopped', () => {\n      logger.info('makeEngine', {\n        module: 'engine',\n        event: 'stopped'\n      }, engine);\n    });\n  })();\n\n  return engine;\n} // Get Network IP\n\nfunction getNetworkIP() {\n  const networkInterfaces = os__WEBPACK_IMPORTED_MODULE_2___default.a.networkInterfaces();\n  let ip = null;\n\n  for (let interfaceName of Object.keys(networkInterfaces)) {\n    if (typeof ip === 'string') break;\n\n    for (let iface of networkInterfaces[interfaceName]) {\n      if (typeof ip === 'string') break;\n      if (!iface.internal && iface.family === 'IPv4') ip = iface.address;\n    }\n  }\n\n  return ip;\n}\n\n//# sourceURL=src/engine/index.js");

/***/ }),

/***/ "./helpers.js":
/*!********************!*\
  !*** ./helpers.js ***!
  \********************/
/*! exports provided: object, decorator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"object\", function() { return object; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decorator\", function() { return decorator; });\n/**\n * @module helpers\n */\n\n/**\n * Object helpers\n *\n * @namespace\n */\nconst object = {\n  /**\n   * Iterate over context object's values\n   */\n  iterateOverValues() {\n    return Object.values(this)[Symbol.iterator]();\n  },\n\n  /**\n   * Check context is an inheritance of Target parameter\n   *\n   * @param {Function} Target\n   *\n   * @return {boolean}\n   */\n  inheritOf(Target) {\n    let prototype = Object.getPrototypeOf(this);\n    return function inheritOf() {\n      // eslint-disable-line no-extra-parens\n      if (prototype === null) return false;else if (prototype === Target || prototype.constructor === Target) return true;\n      prototype = Object.getPrototypeOf(prototype);\n      return inheritOf();\n    }.call(this);\n  }\n\n};\n/**\n * Decorator helpers (for future usage)\n *\n * @namespace\n */\n\nconst decorator = {\n  /**\n   * Set class Symbol.toStringTag property. default is \"target.name\"\n   *\n   * @param {string} [name]\n   *\n   * @return {function(object): object}\n   */\n  setStringTag(name) {\n    return target => {\n      Object.defineProperty(target.prototype, Symbol.toStringTag, {\n        get() {\n          return name || target.name || Object.getPrototypeOf(target).constructor.name;\n        }\n\n      });\n      return target;\n    };\n  }\n\n};\n\n//# sourceURL=src/helpers.js");

/***/ }),

/***/ "./idGenerator.js":
/*!************************!*\
  !*** ./idGenerator.js ***!
  \************************/
/*! exports provided: keyCodesList, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyCodesList\", function() { return keyCodesList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return idGenerator; });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ \"./logger.js\");\n/**\n * @module idGenerator\n */\n\nconst TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_0__[\"makeClassLoggable\"])(global.TypeError, {\n  module: 'idGenerator',\n  scope: undefined,\n  event: undefined\n});\n/**\n * ID character's range [0 to 9 then a to z]\n *\n * @type {number[][]}\n */\n\nconst keyCodesList = [[48, 57], [65, 90]];\n/**\n * Make new id generator\n *\n * @param {number[][]} [charCodesList] Min and max key code as every element (sort by size)\n * @param {string} [lastId]\n *\n * @returns {function(): string}\n */\n\nfunction idGenerator(charCodesList = keyCodesList, lastId) {\n  const firstId = codeToChar(charCodesList[0][0]);\n  const nextCode = nextCharCode.bind(null, charCodesList, charToCode(firstId));\n  /**\n   * Make a new unique id\n   *\n   * @returns {string}\n   */\n\n  return function () {\n    if (lastId === undefined) lastId = firstId;else {\n      let newId = lastId.split('');\n\n      for (let charIndex in newId) {\n        charIndex = Number(charIndex);\n\n        if (charToCode(newId[charIndex]) === charCodesList[charCodesList.length - 1][1]) {\n          newId[charIndex] = firstId;\n\n          if (newId[charIndex + 1] === undefined) {\n            newId.push(firstId);\n            break;\n          }\n        } else {\n          let charCode = nextCode(charToCode(newId[charIndex]));\n          newId[charIndex] = codeToChar(charCode);\n          break;\n        }\n      }\n\n      lastId = newId.join('');\n    }\n    return lastId;\n  };\n}\n/**\n * @param {number[][]} charCodesList\n * @param {number} charCode\n *\n * @throws Will throw an error if id is not in range of charCodesList parameter\n *\n * @returns {number}\n */\n\nfunction rangeOf(charCodesList, charCode) {\n  if (typeof charCode !== 'number') throw new TypeError('charCode parameter is required and mus be number');\n\n  for (const rangeIndex in charCodesList) {\n    if (charCode > charCodesList[rangeIndex][0] - 1 && charCode < charCodesList[rangeIndex][1] + 1) return Number(rangeIndex);\n  }\n\n  throw new RangeError('ID is not in range of charCodesList parameter');\n}\n/**\n * @param {number[][]} charCodesList\n * @param {number} firstId\n * @param {number} charCode\n *\n * @returns {number}\n */\n\n\nfunction nextCharCode(charCodesList, firstId, charCode) {\n  let rangeIndex = rangeOf(charCodesList, charCode);\n\n  if (charCode >= charCodesList[rangeIndex][1]) {\n    if (rangeIndex === charCodesList.length - 1) charCode = firstId;else charCode = charCodesList[rangeIndex + 1][0];\n  } else charCode++;\n\n  return charCode;\n}\n/**\n * @param {number} charCode\n *\n * @returns {string}\n */\n\n\nfunction codeToChar(charCode) {\n  return String.fromCharCode(charCode).toUpperCase();\n}\n/**\n * @param {string} char\n *\n * @returns {number}\n */\n\n\nfunction charToCode(char) {\n  return char.toUpperCase().charCodeAt(0);\n}\n\n//# sourceURL=src/idGenerator.js");

/***/ }),

/***/ "./logger.js":
/*!*******************!*\
  !*** ./logger.js ***!
  \*******************/
/*! exports provided: default, logSymbol, createInfoObject, createErrorObject, makeClassLoggable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Logger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logSymbol\", function() { return logSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createInfoObject\", function() { return createInfoObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createErrorObject\", function() { return createErrorObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeClassLoggable\", function() { return makeClassLoggable; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers */ \"./helpers.js\");\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/**\n * @module logger\n */\n\n\n\n\n\nconst INDENT = 2; // spaces\n\n/**\n * Simple logger\n *\n * @mixes module:remote-controller-server-core~external:EventEmitter\n */\n\nclass Logger extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n  /**\n   * @type {string[]}\n   */\n\n  /**\n   * @type {{warn: string, error: string, info: string}}\n   */\n\n  /**\n   * Emit events with \"Logged\" suffix\n   *\n   * @param {string} type\n   * @param {...*} data\n   *\n   * @return {module:logger~Logger}\n   */\n\n  /**\n   * @param {string} [directory]\n   */\n  constructor(directory) {\n    if (directory !== undefined && directory !== null) directory = String(directory);\n\n    try {\n      fs__WEBPACK_IMPORTED_MODULE_1___default.a.mkdirSync(directory, {\n        recursive: true\n      });\n    } catch (error) {}\n\n    super();\n\n    _types.set(this, {\n      writable: true,\n      value: ['info', 'warn', 'error']\n    });\n\n    _paths.set(this, {\n      writable: true,\n      value: {\n        info: undefined,\n        warn: undefined,\n        error: undefined\n        /**\n         * @summary Append log to log files\n         * @description\n         * Available type:\n         * * `info`\n         * * `warn`\n         * * `error`\n         *\n         * @param {string} type Target log file\n         * @param {*} data This parameter pass to JSON.stringify\n         *\n         * @return {Promise<(void|Error)>}\n         */\n\n      }\n    });\n\n    _append.set(this, {\n      writable: true,\n      value: async (type, data) => {\n        const path = _classPrivateFieldGet(this, _paths)[type];\n\n        if (typeof path !== 'string') return;\n        return Object(util__WEBPACK_IMPORTED_MODULE_3__[\"promisify\"])(fs__WEBPACK_IMPORTED_MODULE_1___default.a.appendFile)(path, JSON.stringify(data, null, INDENT) + \",\\n\"); // eslint-disable-line quotes\n      }\n    });\n\n    _emitLogged.set(this, {\n      writable: true,\n      value: (type, ...data) => this.emit(type + 'Logged', ...data)\n    });\n\n    try {\n      if (fs__WEBPACK_IMPORTED_MODULE_1___default.a.statSync(directory).isDirectory()) {\n        for (const type of _classPrivateFieldGet(this, _types)) {\n          _classPrivateFieldGet(this, _paths)[type] = path__WEBPACK_IMPORTED_MODULE_2___default.a.join(directory, type + '.log');\n        }\n      }\n    } catch (e) {}\n  }\n  /**\n   * Log information\n   *\n   * @param {string} [scope]\n   * @param {...*} [data]\n   *\n   * @emits module:logger~Logger#event:infoLogged\n   *\n   * @return {{_promise: Promise}}\n   *\n   * @see module:logger.createInfoObject\n   */\n\n\n  info(scope, ...data) {\n    if (typeof _classPrivateFieldGet(this, _paths).info !== 'string') return;\n    const infoObject = createInfoObject(scope, ...data);\n    if (infoObject === undefined) return;\n    const parameters = ['info', infoObject];\n    Object.defineProperty(infoObject, '_promise', {\n      value: _classPrivateFieldGet(this, _append).call(this, ...parameters).then(() => {\n        /**\n         * Logger infoLogged event\n         *\n         * @event module:logger~Logger#event:infoLogged\n         *\n         * @type {object}\n         *\n         * @see module:logger.createInfoObject\n         */\n        _classPrivateFieldGet(this, _emitLogged).call(this, ...parameters);\n      }),\n      enumerable: false\n    });\n    return infoObject;\n  }\n  /**\n   * Log warnings\n   *\n   * @param {string} [scope]\n   * @param {...*} [data]\n   *\n   * @emits module:logger~Logger#event:warnLogged\n   *\n   * @return {{_promise: Promise}}\n   *\n   * @see module:logger.createErrorObject\n   */\n\n\n  warn(scope, ...data) {\n    if (typeof _classPrivateFieldGet(this, _paths).warn !== 'string') return;\n    const warnObject = createErrorObject(scope, ...data);\n    if (warnObject === undefined) return;\n    const parameters = ['warn', warnObject];\n    Object.defineProperty(warnObject, '_promise', {\n      value: _classPrivateFieldGet(this, _append).call(this, ...parameters).then(() => {\n        /**\n         * Logger warnLogged event\n         *\n         * @event module:logger~Logger#event:warnLogged\n         *\n         * @type {object}\n         *\n         * @see module:logger.createErrorObject\n         */\n        _classPrivateFieldGet(this, _emitLogged).call(this, ...parameters);\n      }),\n      enumerable: false\n    });\n    return warnObject;\n  }\n  /**\n   * Log errors\n   *\n   * @param {string} [scope]\n   * @param {...*} [data]\n   *\n   * @emits module:logger~Logger#event:errorLogged\n   *\n   * @return {{_promise: Promise}}\n   *\n   * @see module:logger.createErrorObject\n   */\n\n\n  error(scope, ...data) {\n    if (typeof _classPrivateFieldGet(this, _paths).error !== 'string') return;\n    const errorObject = createErrorObject(scope, ...data);\n    if (errorObject === undefined) return;\n    const parameters = ['error', errorObject];\n    Object.defineProperty(errorObject, '_promise', {\n      value: _classPrivateFieldGet(this, _append).call(this, ...parameters).then(() => {\n        /**\n         * Logger errorLogged event\n         *\n         * @event module:logger~Logger#event:errorLogged\n         *\n         * @type {object}\n         *\n         * @see module:logger.createErrorObject\n         */\n        _classPrivateFieldGet(this, _emitLogged).call(this, ...parameters);\n      }),\n      enumerable: false\n    });\n    return errorObject;\n  }\n\n} // Set string tag\n\nvar _types = new WeakMap();\n\nvar _paths = new WeakMap();\n\nvar _append = new WeakMap();\n\nvar _emitLogged = new WeakMap();\n\n_helpers__WEBPACK_IMPORTED_MODULE_4__[\"decorator\"].setStringTag()(Logger);\n/**\n * Use this symbol as key on any object for custom logging\n *\n * @type {symbol}\n */\n\nconst logSymbol = Symbol('log');\n/**\n * @summary Create an object based inputs for logging information\n * @description\n * Adds date key to return object with current human readable date and time <br>\n * Use object's `{@link module:logger.logSymbol}` getter instead object if available\n *\n * @param {string} [scope] If this parameter provided, added to return object by \"scope\" key\n * @param {...*} [data] All objects merged with return object and other primitive values push to an array that its key is \"messages\"\n *\n * @return {object}\n */\n\nfunction createInfoObject(scope, ...data) {\n  const infoObject = Object.create(null);\n\n  if (scope !== undefined && typeof scope !== 'string' || !data.length && typeof scope === 'string') {\n    data.unshift(scope);\n    scope = undefined;\n  }\n\n  if (!data.length) return;\n  Object.assign(infoObject, {\n    scope: typeof scope === 'string' ? scope : undefined,\n    date: Date()\n  });\n  const mergedObjects = []; // Merge objects\n\n  for (const dataIndex in data) {\n    if (data[dataIndex]) {\n      if (data[dataIndex][logSymbol] !== undefined) {\n        data[dataIndex] = data[dataIndex][logSymbol];\n      }\n\n      if (typeof data[dataIndex] === 'object' && !(data[dataIndex] instanceof Array)) {\n        mergedObjects.unshift(dataIndex);\n        Object.assign(infoObject, data[dataIndex]);\n      }\n    }\n  } // Remove merged objects from \"data\"\n\n\n  for (const objectIndex of mergedObjects) {\n    data.splice(objectIndex, 1);\n  }\n\n  if (data.length) infoObject.messages = data;\n  return infoObject;\n}\n/**\n * @summary Create an object based inputs for logging errors\n * @description\n * Same as {@link module:logger.createInfoObject} with some additional behaviors <br><br>\n * Errors pushes to \"_errors\" array for future usage <br>\n * Errors serialize to normal objects <br>\n * Serialized errors push to `errors` key\n *\n * @param {string} [scope]\n * @param {...*} [data]\n *\n * @return {object}\n *\n * @see module:logger.createInfoObject\n */\n\nfunction createErrorObject(scope, ...data) {\n  if (scope !== undefined && typeof scope !== 'string' || !data.length && typeof scope === 'string') {\n    data.unshift(scope);\n    scope = undefined;\n  }\n\n  if (!data.length) return;\n  const errors = [];\n\n  for (let dataIndex = data.length - 1; dataIndex >= 0; dataIndex--) {\n    if (data[dataIndex] instanceof Error) errors.unshift(data.splice(dataIndex, 1)[0]);\n  }\n\n  for (const error of errors) {\n    if (error[logSymbol] !== undefined) data.push(error[logSymbol]);\n  }\n\n  if (errors.length && !data.length) data.push(Object.create(null));\n  const errorObject = createInfoObject(scope, ...data);\n  if (errorObject === undefined) return;\n\n  if (errors.length) {\n    Object.defineProperty(errorObject, '_errors', {\n      value: errors,\n      enumerable: false\n    });\n  }\n\n  const safeErrors = [];\n\n  if (errorObject._errors) {\n    for (const error of errors) {\n      const safeError = safeErrors[safeErrors.push(Object.create(null)) - 1];\n\n      for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(error))) {\n        safeError[key] = error[key];\n      }\n\n      for (const key of Object.getOwnPropertyNames(error)) {\n        safeError[key] = error[key];\n      }\n    }\n  }\n\n  if (safeErrors.length) errorObject.errors = safeErrors;\n  return errorObject;\n}\n/**\n * Make custom class for logging\n *\n * @param {Function} constructor\n * @param {object} [logObject={}] Initial object\n *\n * @return {Function}\n *\n * @see module:logger.makeClassLoggable~Loggable\n */\n\nfunction makeClassLoggable(constructor, logObject = Object.create(null)) {\n  logObject = JSON.parse(JSON.stringify(logObject));\n  /**\n   * Custom class for logging\n   */\n\n  class Loggable extends constructor {\n    constructor(...args) {\n      super(...args);\n\n      _logObject2.set(this, {\n        writable: true,\n        value: Object.create(null)\n      });\n    }\n\n    get [logSymbol]() {\n      return { ...logObject,\n        ..._classPrivateFieldGet(this, _logObject2)\n      };\n    }\n    /**\n     * Set log object\n     *\n     * @param {object} [logObject]\n     *\n     * @return {module:logger.makeClassLoggable~Loggable}\n     */\n\n\n    setLogObject(logObject) {\n      if (typeof logObject === 'object' && logObject !== null) _classPrivateFieldSet(this, _logObject2, Object.assign({}, logObject));\n      return this;\n    }\n    /**\n     * Assign object to log object\n     *\n     * @param {object} [logObject]\n     *\n     * @return {module:logger.makeClassLoggable~Loggable}\n     */\n\n\n    assignLogObject(logObject) {\n      if (typeof logObject === 'object' && logObject !== null) Object.assign(_classPrivateFieldGet(this, _logObject2), logObject);\n      return this;\n    }\n    /**\n     * Set initial log object\n     *\n     * @param {object} [_logObject]\n     *\n     * @return {Function}\n     */\n\n\n    static setLogObject(_logObject) {\n      if (typeof _logObject === 'object' && _logObject !== null) logObject = Object.assign({}, _logObject);\n      return this;\n    }\n    /**\n     * Assign object to initial log object\n     *\n     * @param {object} [_logObject]\n     *\n     * @return {Function}\n     */\n\n\n    static assignLogObject(_logObject) {\n      if (typeof _logObject === 'object' && _logObject !== null) Object.assign(logObject, _logObject);\n      return this;\n    }\n\n  }\n\n  var _logObject2 = new WeakMap();\n\n  Object.defineProperty(Loggable, 'name', {\n    value: 'Loggable' + constructor.name\n  });\n  return Loggable;\n}\n\n//# sourceURL=src/logger.js");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! exports provided: default, storages, preferences, engine, passport, idGenerator, connections, asyncEventEmitter, helpers, logger, plugins, activities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makeCore; });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger */ \"./logger.js\");\n/* harmony import */ var _storages__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storages */ \"./storages/index.js\");\n/* harmony import */ var _preferences__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./preferences */ \"./preferences/index.js\");\n/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./engine */ \"./engine/index.js\");\n/* harmony import */ var _connections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./connections */ \"./connections/index.js\");\n/* harmony import */ var _plugins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./plugins */ \"./plugins/index.js\");\n/* harmony import */ var _activities__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./activities */ \"./activities/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"storages\", function() { return _storages__WEBPACK_IMPORTED_MODULE_2__; });\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"preferences\", function() { return _preferences__WEBPACK_IMPORTED_MODULE_3__; });\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"engine\", function() { return _engine__WEBPACK_IMPORTED_MODULE_4__; });\n/* harmony import */ var _passport__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./passport */ \"./passport/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"passport\", function() { return _passport__WEBPACK_IMPORTED_MODULE_8__; });\n/* harmony import */ var _idGenerator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./idGenerator */ \"./idGenerator.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"idGenerator\", function() { return _idGenerator__WEBPACK_IMPORTED_MODULE_9__; });\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"connections\", function() { return _connections__WEBPACK_IMPORTED_MODULE_5__; });\n/* harmony import */ var _asyncEventEmitter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./asyncEventEmitter */ \"./asyncEventEmitter.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"asyncEventEmitter\", function() { return _asyncEventEmitter__WEBPACK_IMPORTED_MODULE_10__; });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./helpers */ \"./helpers.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"helpers\", function() { return _helpers__WEBPACK_IMPORTED_MODULE_11__; });\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"logger\", function() { return _logger__WEBPACK_IMPORTED_MODULE_1__; });\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"plugins\", function() { return _plugins__WEBPACK_IMPORTED_MODULE_6__; });\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"activities\", function() { return _activities__WEBPACK_IMPORTED_MODULE_7__; });\n/* global global, console, process, setImmediate */\n\n/**\n * @module remote-controller-server-core\n */\n\n/**\n * Nodejs EventEmitter class\n *\n * @external module:remote-controller-server-core~external:EventEmitter\n *\n * @see {@link https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter|EventEmitter}\n */\n\n/**\n * Nodejs stream module\n *\n * @external module:remote-controller-server-core~external:stream\n *\n * @see {@link https://nodejs.org/api/stream.html|Stream}\n */\n\n/**\n * Nodejs stream.Readable class\n *\n * @name Readable\n * @memberOf module:remote-controller-server-core~external:stream\n * @static\n *\n * @see {@link https://nodejs.org/api/stream.html#stream_readable_streams|Readable Streams}\n */\n\n/**\n * Nodejs http module\n *\n * @external module:remote-controller-server-core~external:http\n *\n * @see {@link https://nodejs.org/api/http.html|HTTP}\n */\n\n/**\n * Nodejs http.Server class\n *\n * @name Server\n * @memberOf module:remote-controller-server-core~external:http\n * @static\n *\n * @see {@link https://nodejs.org/api/http.html#http_class_http_server|HTTP Server}\n */\n\n/**\n * Nodejs http.IncomingMessage class\n *\n * @name IncomingMessage\n * @memberOf module:remote-controller-server-core~external:http\n * @static\n *\n * @see {@link https://nodejs.org/api/http.html#http_class_http_incomingmessage|HTTP IncomingMessage}\n */\n\n/**\n * ws module\n *\n * @external module:remote-controller-server-core~external:ws\n *\n * @see {@link https://github.com/websockets/ws/blob/master/README.md|ws Github page}\n */\n\n/**\n * ws WebSocket class\n *\n * @name WebSocket\n * @memberOf module:remote-controller-server-core~external:ws\n * @static\n *\n * @see {@link https://github.com/websockets/ws/blob/master/doc/ws.md#class-websocket|Class: WebSocket}\n */\n\n/**\n * ws WebSocket.Server class\n *\n * @name Server\n * @memberOf module:remote-controller-server-core~external:ws.WebSocket\n * @static\n *\n * @see {@link https://github.com/websockets/ws/blob/master/doc/ws.md#class-websocketserver|Class: WebSocket.Server}\n */\n\n\n\n\n\n\n\n // Error classes\n\nconst logObject = {\n  scope: 'makeCore',\n  module: 'core',\n  event: undefined\n};\nconst TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_1__[\"makeClassLoggable\"])(global.TypeError, logObject);\nconst handleUncaughtExceptions = !process.listenerCount('uncaughtException');\nconst storagesList = Object.create(null);\n/**\n * makeCore creates core namespace\n *\n * @param {object} [configs={}]\n * @param {string} [configs.storagePath=path.join(process.cwd(), 'storage')] Storages path address\n * @param {string} [configs.preferenceStorageName='preferences'] Preferences storage name\n * @param {number} [configs.httpServerPort=7777] Default http server port\n * @param {string} [configs.loggerPath=path.join(configs.storagePath, '../logs')] Logger directory path\n * @param {string} [configs.pluginPath=path.join(configs.storagePath, '../plugins')] Plugins directory path\n *\n * @return {module:remote-controller-server-core~core}\n */\n\nfunction makeCore(configs = Object.create(null)) {\n  if (typeof configs !== 'object') throw new TypeError('configs parameter must be object'); // Set default configs\n\n  configs = Object.assign({\n    storagePath: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(process.cwd(), 'storage'),\n    preferenceStorageName: 'preferences',\n    httpServerPort: 7777\n  }, configs);\n  configs = Object.assign({\n    loggerPath: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(configs.storagePath, '../logs'),\n    pluginPath: path__WEBPACK_IMPORTED_MODULE_0___default.a.join(configs.storagePath, '../plugins')\n  }, configs);\n  if (typeof configs.storagePath !== 'string') throw new TypeError('configs.storagePath must be string');else if (typeof configs.preferenceStorageName !== 'string') throw new TypeError('configs.preferencesStorageName must be string');else if (typeof configs.httpServerPort !== 'number') throw new TypeError('configs.httpServerPort must be number');\n  if (typeof configs.loggerPath !== 'string') throw new TypeError('configs.loggerPath must be string');\n  if (typeof configs.pluginPath !== 'string') throw new TypeError('configs.pluginPath must be string');\n  /**\n   * @namespace module:remote-controller-server-core~core\n   */\n\n  const core = Object.create(null);\n  /**\n   * Logger module\n   *\n   * @name logger\n   * @memberOf module:remote-controller-server-core~core\n   *\n   * @type {module:logger}\n   */\n\n  core.logger = new _logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"](configs.loggerPath);\n  /*\n  Handle unexpected behaviors\n   */\n\n  if (handleUncaughtExceptions) {\n    process.prependListener('uncaughtException', error => {\n      if (!error._dontLog) {\n        core.logger.error('process', {\n          module: 'core',\n          event: 'uncaughtException'\n        }, error);\n      }\n\n      if (false) {}\n    });\n  }\n\n  process.on('unhandledRejection', reason => {\n    if (!reason._dontLog) {\n      core.logger.error('process', {\n        module: 'core',\n        event: 'unhandledRejection'\n      }, reason);\n    }\n\n    if (false) {}\n  });\n  process.on('warning', warning => core.logger.warn('process', {\n    module: 'core',\n    event: 'warning'\n  }, warning)); // storages\n\n  if (storagesList[configs.storagePath] === undefined) {\n    try {\n      storagesList[configs.storagePath] = _storages__WEBPACK_IMPORTED_MODULE_2__[\"default\"].call(core, {\n        path: configs.storagePath\n      });\n    } catch (error) {\n      core.logger.error('core', {\n        module: 'storages'\n      }, error);\n      error._dontLog = true;\n      throw error;\n    }\n  }\n  /**\n   * Storage manager module\n   *\n   * @name storages\n   * @memberOf module:remote-controller-server-core~core\n   *\n   * @type {module:storages~Storages}\n   */\n\n\n  core.storages = storagesList[configs.storagePath]; // preferences\n\n  try {\n    /**\n     * Preference manager module\n     *\n     * @name preferences\n     * @memberOf module:remote-controller-server-core~core\n     *\n     * @type {module:preferences~Preferences}\n     */\n    core.preferences = _preferences__WEBPACK_IMPORTED_MODULE_3__[\"default\"].call(core, {\n      name: configs.preferenceStorageName\n    });\n  } catch (error) {\n    core.logger.error('core', {\n      module: 'preferences'\n    }, error);\n    error._dontLog = true;\n    throw error;\n  } // connections\n\n\n  try {\n    /**\n     * Connection manager module\n     *\n     * @name connections\n     * @memberOf module:remote-controller-server-core~core\n     *\n     * @type {module:connections~Connections}\n     */\n    core.connections = _connections__WEBPACK_IMPORTED_MODULE_5__[\"default\"].call(core);\n  } catch (error) {\n    core.logger.error('core', {\n      module: 'connections'\n    }, error);\n    error._dontLog = true;\n    throw error;\n  } // engine\n\n\n  try {\n    /**\n     * Core engine\n     *\n     * @name engine\n     * @memberOf module:remote-controller-server-core~core\n     *\n     * @type {module:engine~Engine}\n     */\n    core.engine = _engine__WEBPACK_IMPORTED_MODULE_4__[\"default\"].call(core, {\n      port: configs.httpServerPort\n    });\n  } catch (error) {\n    core.logger.error('core', {\n      module: 'engine'\n    }, error);\n    error._dontLog = true;\n    throw error;\n  } // plugins\n\n\n  try {\n    /**\n     * Plugins manager module\n     *\n     * @name plugins\n     * @memberOf module:remote-controller-server-core~core\n     *\n     * @type {module:plugins~Plugins}\n     */\n    core.plugins = _plugins__WEBPACK_IMPORTED_MODULE_6__[\"default\"].call(core, {\n      path: configs.pluginPath\n    });\n  } catch (error) {\n    core.logger.error('core', {\n      module: 'plugins'\n    }, error);\n    error._dontLog = true;\n    throw error;\n  } // activities\n\n\n  try {\n    /**\n     * Activities manager module\n     *\n     * @name activities\n     * @memberOf module:remote-controller-server-core~core\n     *\n     * @type {module:activities~activities}\n     */\n    core.activities = _activities__WEBPACK_IMPORTED_MODULE_7__[\"default\"].call(core);\n  } catch (error) {\n    core.logger.error('core', {\n      module: 'activities'\n    }, error);\n    error._dontLog = true;\n    throw error;\n  }\n\n  return Object.freeze(core);\n}\n\nif (handleUncaughtExceptions) {\n  process.on('uncaughtException', error => {\n    if (false) {} else {\n      console.error('uncaughtException', error); // eslint-disable-line quotes\n    }\n\n    setImmediate(() => process.exit(1));\n  });\n}\n\nprocess.on('unhandledRejection', reason => {\n  if (false) {} else {\n    console.error('unhandledRejection', reason);\n  }\n});\nprocess.on('warning', warning => {\n  if (false) {} else {\n    console.warn('warning', warning);\n  }\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=src/main.js");

/***/ }),

/***/ "./passport/encryption.js":
/*!********************************!*\
  !*** ./passport/encryption.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n/* global global */\n\n/**\n * @module passport/encryption\n */\n\n // Error classes\n\nconst logObject = {\n  scope: 'encryption',\n  event: undefined,\n  module: undefined\n};\nconst Error = Object(_logger__WEBPACK_IMPORTED_MODULE_0__[\"makeClassLoggable\"])(global.Error, logObject);\nconst TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_0__[\"makeClassLoggable\"])(global.TypeError, logObject);\n/**\n * encryption is a password encryptor\n *\n * @param {string} password password must have at least two character\n * @param {(string|Buffer|TypedArray|DataView)} [salt=crypto.randomBytes(32)]\n *\n * @return {{salt: Buffer, hash: Buffer}}\n */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ((password, salt) => {\n  if (typeof password !== 'string') throw new TypeError('password parameter is required and must be string');else if (password.length < 2) {\n    throw new Error('password parameter must have at least two characters').setLogObject({\n      length: password.length\n    });\n  }\n  const result = Object.create(null);\n  result.salt = salt !== undefined ? salt : crypto__WEBPACK_IMPORTED_MODULE_1___default.a.randomBytes(32);\n  result.hash = crypto__WEBPACK_IMPORTED_MODULE_1___default.a.scryptSync(password, result.salt, result.salt.length * password.length);\n  return result;\n});\n\n//# sourceURL=src/passport/encryption.js");

/***/ }),

/***/ "./passport/index.js":
/*!***************************!*\
  !*** ./passport/index.js ***!
  \***************************/
/*! exports provided: default, passwordPattern */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Passport; });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var _password__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./password */ \"./passport/password.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"passwordPattern\", function() { return _password__WEBPACK_IMPORTED_MODULE_2__[\"pattern\"]; });\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\n/* global global, Buffer */\n\n/**\n * @module passport\n */\n\n // Error classes\n\nconst logObject = {\n  scope: 'passport',\n  class: 'Passport',\n  event: undefined,\n  module: undefined\n};\n\nconst _TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_1__[\"makeClassLoggable\"])(global.TypeError, logObject);\n\nconst GLOBAL_ERRORS = {\n  passportInputRequired: new _TypeError('passportInput parameter is required')\n};\nconst passports = {\n  password: __webpack_require__(/*! ./password */ \"./passport/password.js\").default\n};\nclass Passport {\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {Buffer}\n   */\n\n  /**\n   * @type {Buffer}\n   */\n\n  /**\n   * passport holder and manager\n   *\n   * @param {string} type\n   * @param {*} passportInput Depend on passport's type\n   * @param {{salt: Buffer, hash: Buffer}} [passport]\n   */\n  constructor(type, passportInput, passport) {\n    _type.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _hash.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _salt.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_1__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n      method: 'constructor'\n    });\n    if (typeof type !== 'string') throw new _TypeError('type parameter is required and must be string');else if (!passports.hasOwnProperty(type)) throw new Error('type parameter must be one of the passport types');else if (passportInput === undefined) {\n      throw GLOBAL_ERRORS.passportInputRequired.setLogObject({\n        method: 'constructor'\n      });\n    } else if (passportInput === null && (typeof passport !== 'object' || !(passport.hash instanceof Buffer) || !(passport.hash instanceof Buffer))) {\n      throw new _TypeError('passport parameter must be an encryption object');\n    }\n\n    _classPrivateFieldSet(this, _type, type);\n\n    if (passportInput !== null) passport = passports[_classPrivateFieldGet(this, _type)](passportInput);\n\n    _classPrivateFieldSet(this, _hash, passport.hash);\n\n    _classPrivateFieldSet(this, _salt, passport.salt);\n  }\n  /**\n   * Check passport equality\n   *\n   * @param {*} passportInput This parameter can be a encryption object or passport[type] input\n   *\n   * @return {boolean}\n   */\n\n\n  isEqual(passportInput) {\n    if (passportInput === undefined || passportInput === null) {\n      throw GLOBAL_ERRORS.passportInputRequired.setLogObject({\n        method: 'isEqual'\n      });\n    }\n\n    const passport = passportInput.hash instanceof Buffer ? passportInput : passports[this.type](passportInput, this.salt);\n    return this.hash.equals(passport.hash);\n  }\n  /**\n   * Create instance from hash\n   *\n   * @param {string} type\n   * @param {{salt: (Buffer|Buffer#toJSON), hash: (Buffer|Buffer#toJSON)}} passport\n   */\n\n\n  static from(type, passport) {\n    if (typeof passport === 'object') {\n      if (typeof passport.salt === 'object' && !(passport.salt instanceof Buffer)) {\n        passport.salt = Buffer.from(passport.salt);\n      }\n\n      if (typeof passport.hash === 'object' && !(passport.hash instanceof Buffer)) {\n        passport.hash = Buffer.from(passport.hash);\n      }\n    }\n\n    return new Passport(type, null, passport);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get type() {\n    return _classPrivateFieldGet(this, _type);\n  }\n  /**\n   * @type {(Buffer|string)}\n   */\n\n\n  get hash() {\n    return _classPrivateFieldGet(this, _hash);\n  }\n  /**\n   * @type {(Buffer|string)}\n   */\n\n\n  get salt() {\n    return _classPrivateFieldGet(this, _salt);\n  }\n\n} // Set string tag\n\nvar _type = new WeakMap();\n\nvar _hash = new WeakMap();\n\nvar _salt = new WeakMap();\n\n_helpers__WEBPACK_IMPORTED_MODULE_0__[\"decorator\"].setStringTag()(Passport);\n\n\n//# sourceURL=src/passport/index.js");

/***/ }),

/***/ "./passport/password.js":
/*!******************************!*\
  !*** ./passport/password.js ***!
  \******************************/
/*! exports provided: pattern, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pattern\", function() { return pattern; });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var _encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./encryption */ \"./passport/encryption.js\");\n/* global global */\n\n/**\n * @module passport/password\n */\n\n // Error classes\n\nconst logObject = {\n  scope: 'password',\n  event: undefined,\n  module: undefined\n};\nconst Error = Object(_logger__WEBPACK_IMPORTED_MODULE_0__[\"makeClassLoggable\"])(global.Error, logObject);\nconst TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_0__[\"makeClassLoggable\"])(global.TypeError, logObject);\nconst pattern = /(?=^.{8,}$)((?=.*\\d)|(?=.*\\W+))(?![.\\n])(?=.*[A-Z])(?=.*[a-z]).*$/;\n/**\n * * Minimum eight characters\n * * At least one uppercase letter\n * * At least one lowercase letter\n * * At least one number\n * * At least one special character\n *\n * @param {string} password\n * @param [salt] same as encryption salt parameter\n *\n * @throws Will throw an error if the password doesn't math with pattern\n *\n * @return {{salt: Buffer, hash: Buffer}}\n */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ((password, salt) => {\n  if (typeof password !== 'string') {\n    throw new TypeError('password parameter is required and must be string');\n  }\n\n  if (!pattern.test(password)) throw new Error('Password is not secure');\n  return Object(_encryption__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(password, salt);\n});\n\n//# sourceURL=src/passport/password.js");

/***/ }),

/***/ "./plugins/index.js":
/*!**************************!*\
  !*** ./plugins/index.js ***!
  \**************************/
/*! exports provided: default, packageNameSuffix, isPluginPackage, packageNameToPluginName, pluginNameToPackageName, packageNameToPath, pluginNameToPath, Plugin, PluginPreferences, pluginStorages, PluginLogger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makePlugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"packageNameSuffix\", function() { return packageNameSuffix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPluginPackage\", function() { return isPluginPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"packageNameToPluginName\", function() { return packageNameToPluginName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pluginNameToPackageName\", function() { return pluginNameToPackageName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"packageNameToPath\", function() { return packageNameToPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pluginNameToPath\", function() { return pluginNameToPath; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugin */ \"./plugins/plugin.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var rimraf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rimraf */ \"../node_modules/rimraf/rimraf.js\");\n/* harmony import */ var rimraf__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(rimraf__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _pluginPreferences__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./pluginPreferences */ \"./plugins/pluginPreferences.js\");\n/* harmony import */ var _pluginStorages__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pluginStorages */ \"./plugins/pluginStorages.js\");\n/* harmony import */ var _pluginLogger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./pluginLogger */ \"./plugins/pluginLogger.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Plugin\", function() { return _plugin__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PluginPreferences\", function() { return _pluginPreferences__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"pluginStorages\", function() { return _pluginStorages__WEBPACK_IMPORTED_MODULE_9__; });\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PluginLogger\", function() { return _pluginLogger__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; });\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/* global global, process, console, setImmediate */\n\n/**\n * @module plugins\n */\n\n/**\n * An object that hold plugin package data\n *\n * @typedef {object} module:plugins.PluginPackage\n *\n * @property {module:plugins/plugin} Plugin Exported Plugin class\n * @property {string} name\n * @property {object} package Same as package.json config file\n * @property {module:plugins/pluginPreferences} pluginPreferences\n * @property {module:plugins/pluginStorages} pluginStorages\n * @property {module:plugins/pluginLogger} pluginLogger\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * makePlugins creates plugins module\n *\n * @param {object} [configs={}]\n * @param {string} [configs.path=\"path.join(process.cwd(), 'plugins')\"] Default plugins directory address\n *\n * @return {module:plugins~Plugins}\n */\n\nfunction makePlugins(configs = Object.create(null)) {\n  // Error classes\n  const logObject = {\n    scope: 'makePlugins',\n    event: undefined,\n    module: undefined\n  };\n  const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_2__[\"makeClassLoggable\"])(global.Error, logObject);\n  const TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_2__[\"makeClassLoggable\"])(global.TypeError, logObject);\n  if (typeof configs !== 'object') throw new TypeError('configs parameter must be object'); // Set default configs\n\n  configs = Object.assign({\n    path: path__WEBPACK_IMPORTED_MODULE_3___default.a.join(process.cwd(), 'plugins')\n  }, configs);\n  if (typeof configs.path !== 'string') throw new TypeError('configs.path must be string');\n  const preferences = this.preferences;\n\n  const preference = (defaults => {\n    const NAME = 'plugins';\n    let preference;\n\n    try {\n      preference = preferences.add(NAME, defaults);\n    } catch (error) {\n      if (error.message === `${NAME} is already exist`) {\n        try {\n          preference = preferences.get(NAME);\n        } catch (error) {\n          throw error;\n        }\n      } else throw error;\n    }\n\n    try {\n      Object.defineProperty(preference, 'defaults', {\n        value: defaults\n      });\n    } catch (error) {}\n\n    return preference;\n  })(Object.freeze({\n    path: configs.path\n  }));\n\n  configs.path = preference.body.path;\n\n  try {\n    fs__WEBPACK_IMPORTED_MODULE_4___default.a.mkdirSync(configs.path, {\n      recursive: true\n    });\n  } catch (error) {\n    if (error.code !== 'EEXIST') throw error;\n  }\n\n  const _packageNameToPath = (...parameters) => packageNameToPath(configs.path, ...parameters);\n\n  const _pluginNameToPath = (...parameters) => pluginNameToPath(configs.path, ...parameters);\n\n  const storages = this.storages;\n  const logger = this.logger;\n  logObject.module = 'plugins';\n  Error.setLogObject(logObject);\n  TypeError.setLogObject(logObject);\n  /**\n   * Plugins module download, install and load plugins\n   *\n   * @memberOf module:plugins\n   * @inner\n   *\n   * @mixes module:remote-controller-server-core~external:EventEmitter\n   */\n\n  class Plugins extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n    /**\n     * A list that holds plugins\n     *\n     * @type {Object<string, module:plugins.PluginPackage>}\n     */\n\n    /**\n     * A list that holds reloaded plugins\n     *\n     * @type {Object<string, module:plugins.PluginPackage>}\n     */\n\n    /**\n     * Read, setup and add plugin to the list\n     *\n     * @param {string} pluginPath\n     *\n     * @throws Will throw an error if plugin package's name hasn't \"-plugin\" suffix\n     * @throws Will throw an typeError if plugin package's default exported value doesn't function\n     * @throws Will throw an typeError if plugin package's default exported return value doesn't contain a class that implements the {@link module:plugins/plugin} as Plugin key\n     *\n     * @return module:plugins.PluginPackage\n     */\n\n    /**\n     * Remove plugin from list and ram\n     *\n     * @param {string} pluginPath\n     * @param {boolean} removeData Remove it's preference all storages\n     */\n\n    /**\n     * Load installed plugins\n     */\n    constructor() {\n      super(); // Load installed plugins\n\n      _pluginsList.set(this, {\n        writable: true,\n        value: {}\n      });\n\n      _reloadedPluginPackagesCache.set(this, {\n        writable: true,\n        value: {}\n      });\n\n      _add.set(this, {\n        writable: true,\n        value: pluginPath => {\n          if (typeof pluginPath !== 'string') throw new TypeError('pluginPath parameter is required and must be string');\n          const pluginPackage = Object.create({\n            get [_logger__WEBPACK_IMPORTED_MODULE_2__[\"logSymbol\"]]() {\n              const self = this;\n              return {\n                pluginPackage: {\n                  name: self.name,\n                  plugin: self.Plugin.name,\n                  package: {\n                    name: self.package.name,\n                    version: self.package.version,\n                    description: self.package.description,\n                    main: self.package.main\n                  }\n                }\n              };\n            }\n\n          }); // Read package.json config file\n\n          pluginPackage.package = global.require(path__WEBPACK_IMPORTED_MODULE_3___default.a.join(pluginPath, 'package.json'));\n          const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_2__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n            method: '#add',\n            ...this[_logger__WEBPACK_IMPORTED_MODULE_2__[\"logSymbol\"]],\n            package: pluginPackage.package\n          });\n\n          if (!isPluginPackage(pluginPackage.package.name)) {\n            throw new Error('Plugin package name must ends with \\'-' + _plugin__WEBPACK_IMPORTED_MODULE_5__[\"default\"].name.toLowerCase() + '\\', ' + pluginPackage.package.name);\n          }\n\n          pluginPackage.name = packageNameToPluginName(pluginPackage.package.name); // Load module\n\n          let setup = global.require(pluginPath);\n\n          if (setup.__esModule) setup = setup.default;\n\n          if (typeof setup !== 'function') {\n            throw new TypeError('Default exported value is not function, ' + pluginPackage.package.name).setLogObject(pluginPackage.package);\n          } // Setup\n\n\n          pluginPackage.pluginPreferences = new _pluginPreferences__WEBPACK_IMPORTED_MODULE_8__[\"default\"]({\n            name: pluginPackage.package.name,\n            preferences\n          });\n          pluginPackage.pluginStorages = new _pluginStorages__WEBPACK_IMPORTED_MODULE_9__[\"default\"]({\n            name: pluginPackage.package.name,\n            storages\n          });\n          pluginPackage.pluginLogger = new _pluginLogger__WEBPACK_IMPORTED_MODULE_10__[\"default\"]({\n            name: pluginPackage.name,\n            logger\n          });\n          const result = setup({\n            Plugin: _plugin__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n            pluginPreferences: pluginPackage.pluginPreferences,\n            pluginStorages: pluginPackage.pluginStorages,\n            pluginLogger: pluginPackage.pluginLogger\n          });\n\n          if (!result || !result.Plugin || !_helpers__WEBPACK_IMPORTED_MODULE_1__[\"object\"].inheritOf.call(result.Plugin, _plugin__WEBPACK_IMPORTED_MODULE_5__[\"default\"])) {\n            throw new TypeError('Returned value has no any \\'' + _plugin__WEBPACK_IMPORTED_MODULE_5__[\"default\"].name + '\\' key that extends \\'' + _plugin__WEBPACK_IMPORTED_MODULE_5__[\"default\"].name + '\\' class, ' + pluginPackage.package.name).setLogObject(pluginPackage.package);\n          } // Set string tag\n\n\n          _helpers__WEBPACK_IMPORTED_MODULE_1__[\"decorator\"].setStringTag()(result.Plugin);\n          pluginPackage.Plugin = result.Plugin; // Add to list\n\n          _classPrivateFieldGet(this, _pluginsList)[pluginPackage.name] = pluginPackage;\n          return pluginPackage;\n        }\n      });\n\n      _remove.set(this, {\n        writable: true,\n        value: (pluginPath, removeData = false) => {\n          if (typeof pluginPath !== 'string') throw new TypeError('pluginPath parameter is required and must be string');else if (typeof removeData !== 'boolean') throw new TypeError('removeData parameter must be boolean');\n          let pluginName = pluginPath.split('/');\n          pluginName = packageNameToPluginName(pluginName[pluginName.length - 1]);\n          const packageName = pluginNameToPackageName(pluginName);\n\n          const pluginPackage = _classPrivateFieldGet(this, _pluginsList)[pluginName]; // Remove module from ram\n\n\n          delete global.require.cache[global.require.resolve(pluginPath)]; // Remove package from ram\n\n          delete global.require.cache[global.require.resolve(path__WEBPACK_IMPORTED_MODULE_3___default.a.join(pluginPath, 'package.json'))]; // Remove pluginPackage from list\n\n          delete _classPrivateFieldGet(this, _pluginsList)[pluginName];\n\n          if (removeData) {\n            try {\n              pluginPackage.pluginPreferences.removeSync();\n            } catch (error) {}\n\n            for (const file of fs__WEBPACK_IMPORTED_MODULE_4___default.a.readdirSync(pluginPackage.pluginStorages.path)) {\n              if (!file.startsWith(packageName + '.') || !file.endsWith('.json')) continue;\n              const storageName = file.split(packageName + '.')[1].split('.json')[0];\n\n              try {\n                pluginPackage.pluginStorages.removeSync(storageName);\n              } catch (error) {}\n            }\n          }\n        }\n      });\n\n      for (const file of fs__WEBPACK_IMPORTED_MODULE_4___default.a.readdirSync(configs.path, {\n        withFileTypes: true\n      })) {\n        if (file.isDirectory() && isPluginPackage(file.name)) {\n          try {\n            _classPrivateFieldGet(this, _add).call(this, _packageNameToPath(file.name));\n          } catch (error) {\n            logger.error(logObject, {\n              pluginName: packageNameToPluginName(file.name),\n              path: this.path\n            }, error);\n            console.error(error);\n          }\n        }\n      }\n    }\n    /**\n     * Download, Read, setup and add plugin to the list\n     *\n     * @param {string} pluginName\n     *\n     * @emits module:plugins~Plugins#event:added\n     *\n     * @async\n     * @return {Promise<(module:plugins.PluginPackage|Error)>}\n     * * Rejection\n     *  * Will reject an error if target plugin is already exist\n     *  * Will reject an error if plugin package's name hasn't \"-plugin\" suffix\n     *  * Will reject an typeError if plugin package's default exported value doesn't function\n     *  * Will reject an typeError if plugin package's default exported return value doesn't contain a class that implements the {@link module:plugins/plugin} as Plugin key\n     */\n\n\n    add(pluginName) {\n      const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_2__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n        method: 'add'\n      });\n      if (typeof pluginName !== 'string') throw new TypeError('pluginName parameter is required and must be string');\n      return (async () => {\n        if (this.get(pluginName)) throw new Error(`${pluginName} is already exist`); // Temporary\n\n        await new Promise(resolve => setImmediate(resolve));\n\n        const pluginPackage = _classPrivateFieldGet(this, _add).call(this, _pluginNameToPath(pluginName));\n        /**\n         * New plugin added event\n         *\n         * @event module:plugins~Plugins#event:added\n         *\n         * @type {module:plugins.PluginPackage}\n         */\n\n\n        this.emit('added', pluginPackage);\n        return pluginPackage;\n      })();\n    }\n    /**\n     * @summary Get specific plugin package or all plugins list\n     * @description\n     * When call this method without pluginName parameter, returned object is iterable (over values) <br>\n     * `Object.values({@link module:plugins~Plugins#get|plugins.get()})[Symbol.iterator]`\n     * is same as\n     * `{@link module:plugins~Plugins#get|plugins.get()}[Symbol.iterator]`\n     *\n     * @param  {string} [pluginName]\n     *\n     * @return {(module:plugins.PluginPackage|object<string, module:plugins.PluginPackage>)}\n     */\n\n\n    get(pluginName) {\n      if (pluginName !== undefined && typeof pluginName !== 'string') throw new TypeError('pluginName parameter must be string');\n      if (pluginName) return _classPrivateFieldGet(this, _pluginsList)[pluginName];\n      const pluginsListPrototype = {\n        length: 0,\n        [Symbol.iterator]: _helpers__WEBPACK_IMPORTED_MODULE_1__[\"object\"].iterateOverValues\n      };\n      const pluginsList = Object.create(pluginsListPrototype);\n\n      for (const [key, value] of Object.entries(_classPrivateFieldGet(this, _pluginsList))) {\n        pluginsList[key] = value;\n        pluginsListPrototype.length++;\n      }\n\n      return pluginsList;\n    }\n    /**\n     * Remove plugin from list and ram and remove plugin package from disk and user account\n     *\n     * @param {(module:plugins.PluginPackage|string)} pluginPackage\n     * @param {boolean} removeData Remove it's preference all storages\n     *\n     * @emits module:plugins~Plugins#event:removed\n     *\n     * @async\n     * @return {Promise<(void|Error)>}\n     * * Rejection\n     *  * Reject an error if target plugin is not exist in list\n     */\n\n\n    remove(pluginPackage, removeData = false) {\n      const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_2__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n        method: 'remove'\n      });\n      if (!pluginPackage || typeof pluginPackage !== 'string' && typeof pluginPackage.name !== 'string') throw new TypeError('pluginPackage parameter is required and must be PluginPackage/string');else if (typeof removeData !== 'boolean') throw new TypeError('removeData parameter must be boolean');\n      const pluginName = pluginPackage.name || pluginPackage;\n      pluginPackage = this.get(pluginName);\n\n      const pluginPath = _pluginNameToPath(pluginName);\n\n      return (async () => {\n        if (!pluginPackage) throw new Error(`${pluginName} is not exist in list`); // Remove cache from disk\n\n        await Object(util__WEBPACK_IMPORTED_MODULE_6__[\"promisify\"])(rimraf__WEBPACK_IMPORTED_MODULE_7___default.a)(pluginPath); // Remove cache from ram\n\n        _classPrivateFieldGet(this, _remove).call(this, pluginPath, removeData);\n        /**\n         * New plugin removed event\n         *\n         * @event module:plugins~Plugins#event:removed\n         *\n         * @type {module:plugins.PluginPackage}\n         */\n\n\n        this.emit('removed', pluginPackage);\n      })();\n    }\n    /**\n     * Reload (read, setup, cache) plugin\n     *\n     * @param {(module:plugins.PluginPackage|string)} pluginPackage\n     *\n     * @emits module:plugins~Plugins#event:reloaded\n     *\n     * @return {module:plugins.PluginPackage}\n     */\n\n\n    reload(pluginPackage) {\n      if (!pluginPackage || typeof pluginPackage !== 'string' && typeof pluginPackage.name !== 'string') throw new TypeError('pluginPackage parameter is required and must be PluginPackage/string');\n      const pluginName = pluginPackage.name || pluginPackage;\n\n      const pluginPath = _pluginNameToPath(pluginName);\n\n      _classPrivateFieldGet(this, _reloadedPluginPackagesCache)[pluginName] = pluginPackage = _classPrivateFieldGet(this, _reloadedPluginPackagesCache)[pluginName] || this.get(pluginName); // Remove cache from ram\n\n      _classPrivateFieldGet(this, _remove).call(this, pluginPath); // Read and setup plugin again\n\n\n      const newPluginPackage = _classPrivateFieldGet(this, _add).call(this, pluginPath); // Copy previous pluginPackage objects\n\n\n      const oldPluginPackage = Object.assign(Object.create(Object.getPrototypeOf(pluginPackage)), pluginPackage); // Update previous cached pluginPackage objects\n\n      Object.assign(pluginPackage, newPluginPackage);\n      /**\n       * @summary Plugin reloaded event\n       * @description New PluginPackage pass as first parameter, and old PluginPackage pass as second parameter\n       *\n       * @event module:plugins~Plugins#event:reloaded\n       *\n       * @type {module:plugins.PluginPackage}\n       */\n\n      this.emit('reloaded', newPluginPackage, oldPluginPackage);\n      return newPluginPackage;\n    }\n    /**\n     * Check Plugin is already exist\n     *\n     * @param {string} pluginName Plugin's name to check\n     *\n     * @return {boolean}\n     */\n\n\n    has(pluginName) {\n      return _classPrivateFieldGet(this, _pluginsList).hasOwnProperty(pluginName);\n    }\n    /**\n     * @summary Plugins directory path\n     * @description To reset to default value set it to `null` <br>\n     * Default: path property in configs parameter of {@link module:plugins|makePlugins}\n     *\n     * @type {string}\n     */\n\n\n    get path() {\n      return configs.path;\n    }\n\n    set path(value) {\n      if (typeof value === 'string' || value === null) {\n        preference.updateSync(body => {\n          if (value !== null) {\n            body.path = value;\n          } else body.path = preference.defaults.path;\n\n          return body;\n        });\n\n        try {\n          fs__WEBPACK_IMPORTED_MODULE_4___default.a.mkdirSync(preference.body.path, {\n            recursive: true\n          });\n        } catch (error) {\n          if (error.code !== 'EEXIST') throw error;\n        }\n\n        configs.path = preference.body.path;\n      }\n    }\n\n    get [_logger__WEBPACK_IMPORTED_MODULE_2__[\"logSymbol\"]]() {\n      return {\n        plugins: {\n          path: configs.path\n        }\n      };\n    }\n\n  } // Set string tag\n\n\n  var _pluginsList = new WeakMap();\n\n  var _reloadedPluginPackagesCache = new WeakMap();\n\n  var _add = new WeakMap();\n\n  var _remove = new WeakMap();\n\n  _helpers__WEBPACK_IMPORTED_MODULE_1__[\"decorator\"].setStringTag()(Plugins);\n  const plugins = new Plugins() // Logging\n  ;\n\n  (() => {\n    plugins.on('added', pluginPackage => logger.info('makePlugins', {\n      module: 'plugins',\n      event: 'added'\n    }, pluginPackage));\n    plugins.on('removed', pluginPackage => logger.info('makePlugins', {\n      module: 'plugins',\n      event: 'removed'\n    }, pluginPackage));\n    plugins.on('reloaded', (newPluginPackage, oldPluginPackage) => logger.info('makePlugins', {\n      module: 'plugins',\n      event: 'reloaded'\n    }, {\n      oldPluginPackage: oldPluginPackage[_logger__WEBPACK_IMPORTED_MODULE_2__[\"logSymbol\"]].pluginPackage,\n      newPluginPackage: newPluginPackage[_logger__WEBPACK_IMPORTED_MODULE_2__[\"logSymbol\"]].pluginPackage\n    }));\n  })();\n\n  return plugins;\n}\nconst packageNameSuffix = '-' + _plugin__WEBPACK_IMPORTED_MODULE_5__[\"default\"].name.toLowerCase();\n/**\n * @param {string} packageName\n *\n * @return {boolean}\n */\n\nfunction isPluginPackage(packageName) {\n  return packageName.endsWith(packageNameSuffix);\n}\n/**\n * @param {string} packageName\n *\n * @return {string}\n */\n\nfunction packageNameToPluginName(packageName) {\n  return packageName.split(packageNameSuffix)[0];\n}\n/**\n * @param {string} pluginName\n *\n * @return {string}\n */\n\nfunction pluginNameToPackageName(pluginName) {\n  return pluginName + packageNameSuffix;\n}\n/**\n * @param {string} _path\n * @param {string} packageName\n *\n * @return {string}\n */\n\nfunction packageNameToPath(_path, packageName) {\n  return path__WEBPACK_IMPORTED_MODULE_3___default.a.join(_path, packageName);\n}\n/**\n * @param {string} path\n * @param {string} pluginName\n *\n * @return {string}\n */\n\nfunction pluginNameToPath(path, pluginName) {\n  return packageNameToPath(path, pluginNameToPackageName(pluginName));\n}\n\n\n\n\n\n\n\n\n\n//# sourceURL=src/plugins/index.js");

/***/ }),

/***/ "./plugins/plugin.js":
/*!***************************!*\
  !*** ./plugins/plugin.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Plugin; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/**\n * @module plugins/plugin\n */\n\n\n\n/**\n * Interface for plugins\n *\n * @interface\n *\n * @mixes module:remote-controller-server-core~external:EventEmitter\n */\n\nclass Plugin extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n  /**\n   * Assign configs properties to context as non enumerable getters\n   *\n   * @param [configs]\n   */\n  constructor(configs = Object.create(null)) {\n    if (typeof configs !== 'object') throw new TypeError('configs parameter must be object');\n    super();\n\n    for (const key in configs) {\n      if (!configs.hasOwnProperty(key)) continue;\n      Object.defineProperty(this, key, {\n        enumerable: false,\n\n        get() {\n          return configs[key];\n        }\n\n      });\n    }\n\n    const states = ['plugging', 'plugged', 'unplugging', 'unplugged'];\n\n    for (const state of states) {\n      // Call state methods event base\n      this.on(state, this[state].bind(this));\n    }\n  }\n  /**\n   * Calls right before plug the plugin\n   *\n   * @return {(Promise<*>|*)}\n   */\n\n\n  plugging() {}\n  /**\n   * Calls right after plug the plugin\n   *\n   * @return {(Promise<*>|*)}\n   */\n\n\n  plugged() {}\n  /**\n   * Calls right before unplug the plugin\n   *\n   * @return {(Promise<*>|*)}\n   */\n\n\n  unplugging() {}\n  /**\n   * Calls right after unplug the plugin\n   *\n   * @return {(Promise<*>|*)}\n   */\n\n\n  unplugged() {}\n\n  get [_logger__WEBPACK_IMPORTED_MODULE_2__[\"logSymbol\"]]() {\n    return {\n      plugin: {\n        activityId: this.activityId,\n        activityConnection: this.activityConnection[_logger__WEBPACK_IMPORTED_MODULE_2__[\"logSymbol\"]]\n      }\n    };\n  }\n\n} // Set string tag\n\n_helpers__WEBPACK_IMPORTED_MODULE_1__[\"decorator\"].setStringTag()(Plugin);\n\n//# sourceURL=src/plugins/plugin.js");

/***/ }),

/***/ "./plugins/pluginLogger.js":
/*!*********************************!*\
  !*** ./plugins/pluginLogger.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PluginLogger; });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\n/**\n * @module plugins/pluginLogger\n */\n\n\n/**\n * Create a wrapper around logger module to use in plugins\n *\n * @see module:logger\n */\n\nclass PluginLogger {\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {module:logger}\n   */\n\n  /**\n   * @type {object}\n   */\n\n  /**\n   * @param {object} configs\n   * @param {string} configs.name\n   * @param {module:logger} configs.logger\n   */\n  constructor(configs) {\n    _name.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _logger.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _logObject.set(this, {\n      writable: true,\n      value: {}\n    });\n\n    if (typeof configs !== 'object') throw new TypeError('configs parameter is required and must be object');else if (typeof configs.name !== 'string') throw new TypeError('configs.name is required and must be string');else if (!(configs.logger instanceof _logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"])) throw new TypeError('configs.logger is required and must be Logger');\n\n    _classPrivateFieldSet(this, _name, configs.name);\n\n    _classPrivateFieldSet(this, _logger, configs.logger);\n\n    _classPrivateFieldGet(this, _logObject).pluginName = _classPrivateFieldGet(this, _name);\n  }\n  /**\n   * Log information\n   *\n   * @param {string} [scope]\n   * @param {...*} [data]\n   *\n   * @return {{_promise: Promise}}\n   *\n   * @see module:logger#info\n   */\n\n\n  info(scope, ...data) {\n    data.push(_classPrivateFieldGet(this, _logObject));\n    return _classPrivateFieldGet(this, _logger).info(scope, ...data);\n  }\n  /**\n   * Log warnings\n   *\n   * @param {string} [scope]\n   * @param {...*} [data]\n   *\n   * @return {{_promise: Promise}}\n   *\n   * @see module:logger#warn\n   */\n\n\n  warn(scope, ...data) {\n    data.push(_classPrivateFieldGet(this, _logObject));\n    return _classPrivateFieldGet(this, _logger).warn(scope, ...data);\n  }\n  /**\n   * Log errors\n   *\n   * @param {string} [scope]\n   * @param {...*} [data]\n   *\n   * @return {{_promise: Promise}}\n   *\n   * @see module:logger#error\n   */\n\n\n  error(scope, ...data) {\n    data.push(_classPrivateFieldGet(this, _logObject));\n    return _classPrivateFieldGet(this, _logger).error(scope, ...data);\n  }\n  /**\n   * @type {symbol}\n   *\n   * @see module:logger.logSymbol\n   */\n\n\n  static get logSymbol() {\n    return _logger__WEBPACK_IMPORTED_MODULE_1__[\"logSymbol\"];\n  }\n  /**\n   * @type {function}\n   *\n   * @see module:logger.makeClassLoggable\n   */\n\n\n  static get makeClassLoggable() {\n    return _logger__WEBPACK_IMPORTED_MODULE_1__[\"makeClassLoggable\"];\n  }\n\n} // Set string tag\n\nvar _name = new WeakMap();\n\nvar _logger = new WeakMap();\n\nvar _logObject = new WeakMap();\n\n_helpers__WEBPACK_IMPORTED_MODULE_0__[\"decorator\"].setStringTag()(PluginLogger);\n\n//# sourceURL=src/plugins/pluginLogger.js");

/***/ }),

/***/ "./plugins/pluginPreferences.js":
/*!**************************************!*\
  !*** ./plugins/pluginPreferences.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PluginPreferences; });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\n/* global global */\n\n/**\n * @module plugins/pluginPreferences\n */\n\n // Error classes\n\nconst logObject = {\n  scope: 'pluginPreferences',\n  class: 'PluginPreferences',\n  event: undefined,\n  module: undefined\n};\n\nconst _TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_0__[\"makeClassLoggable\"])(global.TypeError, logObject);\n/**\n * Create a wrapper around preferences module to use in plugins\n *\n * @see module:preferences~Preferences\n */\n\n\nclass PluginPreferences {\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {module:preferences~Preferences}\n   */\n\n  /**\n   * @param {object} configs\n   * @param {string} configs.name Name that use for create Preference instance\n   * @param {module:preferences~Preferences} configs.preferences\n   */\n  constructor(configs) {\n    _name.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _preferences.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    if (typeof configs !== 'object') throw new _TypeError('configs parameter is required and must be object');else if (typeof configs.name !== 'string') throw new _TypeError('configs.name is required and must be string');else if (!(configs.preferences instanceof Object)) throw new _TypeError('configs.preferences is required and must be Preferences');\n\n    _classPrivateFieldSet(this, _name, configs.name);\n\n    _classPrivateFieldSet(this, _preferences, configs.preferences);\n  }\n  /**\n   * Get previous created preference\n   *\n   * @return {module:preferences/preference}\n   *\n   * @see module:preferences~Preferences#get\n   */\n\n\n  get() {\n    return _classPrivateFieldGet(this, _preferences).get(_classPrivateFieldGet(this, _name));\n  }\n  /**\n   * Create/Initialize preference\n   *\n   * @param {object} [body={}] Preference's initial content\n   *\n   * @return {module:preferences/preference}\n   *\n   * @see module:preferences~Preferences#add\n   */\n\n\n  add(body = Object.create(null)) {\n    return _classPrivateFieldGet(this, _preferences).add(_classPrivateFieldGet(this, _name), body);\n  }\n  /**\n   * Remove preference\n   *\n   * @async\n   *\n   * @see module:preferences~Preferences#remove\n   */\n\n\n  remove() {\n    return _classPrivateFieldGet(this, _preferences).remove(_classPrivateFieldGet(this, _name));\n  }\n  /**\n   * Remove preference\n   *\n   * @see module:preferences~Preferences#removeSync\n   */\n\n\n  removeSync() {\n    return _classPrivateFieldGet(this, _preferences).removeSync(_classPrivateFieldGet(this, _name));\n  }\n  /**\n   * Check Preference is already exist\n   *\n   * @return {boolean}\n   *\n   * @see module:preferences~Preferences#has\n   */\n\n\n  has() {\n    return _classPrivateFieldGet(this, _preferences).has(_classPrivateFieldGet(this, _name));\n  }\n\n  get [_logger__WEBPACK_IMPORTED_MODULE_0__[\"logSymbol\"]]() {\n    try {\n      return this.get()[_logger__WEBPACK_IMPORTED_MODULE_0__[\"logSymbol\"]];\n    } catch (error) {\n      return {};\n    }\n  }\n\n} // Set string tag\n\nvar _name = new WeakMap();\n\nvar _preferences = new WeakMap();\n\n_helpers__WEBPACK_IMPORTED_MODULE_1__[\"decorator\"].setStringTag()(PluginPreferences);\n\n//# sourceURL=src/plugins/pluginPreferences.js");

/***/ }),

/***/ "./plugins/pluginStorages.js":
/*!***********************************!*\
  !*** ./plugins/pluginStorages.js ***!
  \***********************************/
/*! exports provided: default, NAME_SEPARATOR */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PluginStorages; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NAME_SEPARATOR\", function() { return NAME_SEPARATOR; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _storages_storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../storages/storage */ \"./storages/storage.js\");\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\n/* global global */\n\n/**\n * @module plugins/pluginStorages\n */\n\n\n\n // Error classes\n\nconst logObject = {\n  scope: 'pluginStorages',\n  class: 'PluginStorages',\n  event: undefined,\n  module: undefined\n};\n\nconst _TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_1__[\"makeClassLoggable\"])(global.TypeError, logObject);\n/**\n * Create a wrapper around storages module to use in plugins\n *\n * @mixes module:remote-controller-server-core~external:EventEmitter\n *\n * @see module:storages~Storages\n */\n\n\nclass PluginStorages extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {module:storages~Storages}\n   */\n\n  /**\n   * Storage added event\n   *\n   * @event module:plugins/pluginStorages#event:added\n   *\n   * @type module:storages/storage\n   *\n   * @see module:storages~Storages#event:added\n   */\n\n  /**\n   * @summary Storage removed event\n   * @description Target Storage pass as first parameter, and event pass as second parameter\n   *\n   * @event module:plugins/pluginStorages#event:removed\n   *\n   * @type {module:storages/storage}\n   *\n   * @see module:storages~Storages#event:removed\n   */\n\n  /**\n   * @summary Storage updated event\n   * @description Target Storage pass as first parameter, and event pass as second parameter\n   *\n   * @event module:plugins/pluginStorages#event:updated\n   *\n   * @type {module:storages/storage}\n   *\n   * @see module:storages~Storages#event:updated\n   */\n\n  /**\n   * @param {object} configs\n   * @param {string} configs.name Name that use for create Storage instance\n   * @param {module:storages~Storages} configs.storages\n   *\n   * @emits module:plugins/pluginStorages#event:added\n   * @emits module:plugins/pluginStorages#event:removed\n   * @emits module:plugins/pluginStorages#event:updated\n   *\n   * @listens module:storages~Storages#event:added\n   * @listens module:storages~Storages#event:removed\n   * @listens module:storages~Storages#event:updated\n   */\n  constructor(configs) {\n    if (typeof configs !== 'object') throw new _TypeError('configs parameter is required and must be object');else if (typeof configs.name !== 'string') throw new _TypeError('configs.name is required and must be string');else if (!(configs.storages instanceof Object)) throw new _TypeError('configs.storages is required and must be Storages');\n    super();\n\n    _name.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _storages.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldSet(this, _name, configs.name);\n\n    _classPrivateFieldSet(this, _storages, configs.storages); // Transfer events\n\n\n    const events = ['added', 'removed', 'updated'];\n\n    for (const event of events) {\n      _classPrivateFieldGet(this, _storages).on(event, (...parameters) => {\n        const [storage, additional] = parameters;\n        const name = storage.name || additional.name;\n\n        if (name.startsWith(_classPrivateFieldGet(this, _name) + NAME_SEPARATOR)) {\n          this.emit(event, ...parameters);\n        }\n      });\n    }\n  }\n  /**\n   * Get Storage instance via it's name\n   *\n   * @param {string} name Target storage's name\n   *\n   * @return {module:storages/storage}\n   *\n   * @see module:storages~Storages#get\n   */\n\n\n  get(name) {\n    if (typeof name !== 'string') throw new _TypeError('name parameter is required and must be string');\n    return _classPrivateFieldGet(this, _storages).get(_classPrivateFieldGet(this, _name) + NAME_SEPARATOR + name);\n  }\n  /**\n   * Add/Initialize Storage\n   *\n   * @param {string} name\n   * @param {object} [body={}] Storage's initial content\n   *\n   * @return {module:storages/storage}\n   *\n   * @see module:storages~Storages#add\n   */\n\n\n  add(name, body = Object.create(null)) {\n    if (typeof name !== 'string') throw new _TypeError('name parameter is required and must be string');\n    return _classPrivateFieldGet(this, _storages).add(_classPrivateFieldGet(this, _name) + NAME_SEPARATOR + name, body);\n  }\n  /**\n   * Remove Storage from list and it's file\n   *\n   * @param {(string|module:storages/storage)} storage\n   *\n   * @async\n   *\n   * @see module:storages~Storages#remove\n   */\n\n\n  remove(storage) {\n    if (storage === undefined || typeof storage !== 'string' && !(storage instanceof _storages_storage__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) throw new _TypeError('storage parameter is required and must be string/Storage');\n    if (typeof storage === 'string') storage = _classPrivateFieldGet(this, _name) + NAME_SEPARATOR + storage;\n    return _classPrivateFieldGet(this, _storages).remove(storage);\n  }\n  /**\n   * Remove Storage from list and it's file\n   *\n   * @param {(string|module:storages/storage)} storage\n   *\n   * @see module:storages~Storages#removeSync\n   */\n\n\n  removeSync(storage) {\n    if (storage === undefined || typeof storage !== 'string' && !(storage instanceof _storages_storage__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) throw new _TypeError('storage parameter is required and must be string/Storage');\n    if (typeof storage === 'string') storage = _classPrivateFieldGet(this, _name) + NAME_SEPARATOR + storage;\n    return _classPrivateFieldGet(this, _storages).removeSync(storage);\n  }\n  /**\n   * Check Storage is already exist\n   *\n   * @param {string} name Storage's name to check\n   *\n   * @return {boolean}\n   *\n   * @see module:storages~Storages#has\n   */\n\n\n  has(name) {\n    return _classPrivateFieldGet(this, _storages).has(_classPrivateFieldGet(this, _name) + NAME_SEPARATOR + name);\n  }\n  /**\n   * Return storage's path\n   *\n   * @return {string}\n   *\n   * @see module:storages~Storages#path\n   */\n\n\n  get path() {\n    return _classPrivateFieldGet(this, _storages).path;\n  }\n\n  get [_logger__WEBPACK_IMPORTED_MODULE_1__[\"logSymbol\"]]() {\n    return _classPrivateFieldGet(this, _storages)[_logger__WEBPACK_IMPORTED_MODULE_1__[\"logSymbol\"]];\n  }\n\n} // Set string tag\n\nvar _name = new WeakMap();\n\nvar _storages = new WeakMap();\n\n_helpers__WEBPACK_IMPORTED_MODULE_2__[\"decorator\"].setStringTag()(PluginStorages);\nconst NAME_SEPARATOR = '.';\n\n//# sourceURL=src/plugins/pluginStorages.js");

/***/ }),

/***/ "./preferences/index.js":
/*!******************************!*\
  !*** ./preferences/index.js ***!
  \******************************/
/*! exports provided: default, Preference */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makePreferences; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _preference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./preference */ \"./preferences/preference.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Preference\", function() { return _preference__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/* global global */\n\n/**\n * @module preferences\n */\n\n\n\n\n/**\n * makePreferences creates preferences module\n *\n * @param {object} configs\n * @param {string} [configs.name='preferences'] Preferences's Storage name\n *\n * @throws Will throw an error if Preferences file is already in use\n *\n * @return {module:preferences~Preferences}\n */\n\nfunction makePreferences(configs) {\n  // Error classes\n  const logObject = {\n    scope: 'makePreferences',\n    event: undefined,\n    module: undefined\n  };\n  const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_3__[\"makeClassLoggable\"])(global.Error, logObject);\n  const TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_3__[\"makeClassLoggable\"])(global.TypeError, logObject);\n  if (typeof configs !== 'object') throw new TypeError('configs parameter is required and must be object'); // Set default configs\n\n  configs = Object.assign({\n    name: 'preferences'\n  }, configs);\n  if (typeof configs.name !== 'string') throw new TypeError('configs.name must be string');else if (this.storages.has(configs.name)) throw new Error(`${configs.name} is already in use`);\n  const logger = this.logger;\n  logObject.module = 'preferences';\n  Error.setLogObject(logObject);\n  TypeError.setLogObject(logObject);\n  const PREFERENCES_GLOBAL_ERRORS = {\n    accessibility: new Error(`Preference is not accessible`),\n    existence: name => new Error(`${name} is not exist in list`)\n  };\n\n  const preferencesStorage = (() => {\n    try {\n      return this.storages.add(configs.name);\n    } catch (error) {\n      if (error.message === `${configs.name} is already exist`) {\n        try {\n          return this.storages.get(configs.name);\n        } catch (error) {\n          throw error;\n        }\n      } else {\n        throw error;\n      }\n    }\n  })();\n  /**\n   * Preferences module is a Preference holder/manager\n   *\n   * @todo This class doesn't show correctly in documentation, so needs to fix it\n   *\n   * @memberOf module:preferences\n   * @inner\n   *\n   * @mixes module:remote-controller-server-core~external:EventEmitter\n   */\n\n\n  class Preferences extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n    constructor(...args) {\n      super(...args);\n\n      _preferencesList.set(this, {\n        writable: true,\n        value: {}\n      });\n\n      _transferEvent.set(this, {\n        writable: true,\n        value: (preference, eventName) => preference.on(eventName, event => this.emit(eventName, preference, event))\n      });\n\n      _remove.set(this, {\n        writable: true,\n        value: (preference, configs = Object.create(null)) => {\n          if (preference === undefined || typeof preference !== 'string' && !(preference instanceof _preference__WEBPACK_IMPORTED_MODULE_1__[\"default\"])) {\n            throw new TypeError('preference parameter is required and must be string/Preference');\n          } // Set default configs\n\n\n          configs = Object.assign({\n            sync: true\n          }, configs);\n          const name = preference.name || preference;\n\n          const deletePreference = () => {\n            delete _classPrivateFieldGet(this, _preferencesList)[name];\n          };\n\n          const ERRORS = {\n            accessibility: PREFERENCES_GLOBAL_ERRORS.accessibility.setLogObject({\n              method: '#remove'\n            }),\n            existence: PREFERENCES_GLOBAL_ERRORS.existence(name).setLogObject({\n              method: '#remove'\n            })\n          };\n          preference = _classPrivateFieldGet(this, _preferencesList)[name];\n\n          if (configs.sync) {\n            if (typeof name !== 'string') throw ERRORS.accessibility;\n            if (preference === undefined) throw ERRORS.existence;\n            preference.removeSync();\n            deletePreference();\n            return;\n          }\n\n          if (typeof name !== 'string') return Promise.reject(ERRORS.accessibility);\n          if (preference === undefined) return Promise.reject(ERRORS.existence);\n          return preference.remove().then(deletePreference, error => Promise.reject(error));\n        }\n      });\n    }\n\n    /**\n     * Get Preference instance via it's name\n     *\n     * @param {string} name Target Preference's name\n     *\n     * @emits module:preferences~Preferences#event:updated\n     * @emits module:preferences~Preferences#event:removed\n     *\n     * @listens module:preferences/preference#event:updated\n     * @listens module:preferences/preference#event:removed\n     *\n     * @return {module:preferences/preference}\n     */\n    get(name) {\n      if (typeof name !== 'string') throw new TypeError('name parameter is required and must be string'); // Return Preference from list if exist\n\n      if (_classPrivateFieldGet(this, _preferencesList).hasOwnProperty(name)) return _classPrivateFieldGet(this, _preferencesList)[name];\n      _classPrivateFieldGet(this, _preferencesList)[name] = new _preference__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        name,\n        storage: preferencesStorage\n      });\n\n      _classPrivateFieldGet(this, _transferEvent).call(this, _classPrivateFieldGet(this, _preferencesList)[name], 'updated');\n\n      _classPrivateFieldGet(this, _transferEvent).call(this, _classPrivateFieldGet(this, _preferencesList)[name], 'removed');\n\n      return _classPrivateFieldGet(this, _preferencesList)[name];\n    }\n    /**\n     * Add/Initialize Preference\n     *\n     * @param {(module:preferences/preference|string)} preference Preference instance or preference's name\n     * @param {object} [body={}] Preference's initial content\n     *\n     * @throws Will throw an error if Preference is already exist in list\n     *\n     * @emits module:preferences~Preferences#event:updated\n     * @emits module:preferences~Preferences#event:removed\n     * @emits module:preferences~Preferences#event:added\n     *\n     * @listens module:preferences/preference#event:updated\n     * @listens module:preferences/preference#event:removed\n     *\n     * @return {module:preferences/preference}\n     */\n\n\n    add(preference, body = Object.create(null)) {\n      const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_3__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n        method: 'add'\n      });\n      if (!(preference instanceof _preference__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) && typeof preference !== 'string') throw new TypeError('preference parameter is required and must be Preference/string');else if (typeof body !== 'object') throw new TypeError('body parameter must be object');\n      const name = preference.name || preference;\n      if (!(preference instanceof _preference__WEBPACK_IMPORTED_MODULE_1__[\"default\"])) preference = undefined;\n      if (_classPrivateFieldGet(this, _preferencesList).hasOwnProperty(name)) throw new Error(`${name} is already exist`);\n\n      if (preference) {\n        _classPrivateFieldGet(this, _preferencesList)[name] = preference;\n      } else {\n        _classPrivateFieldGet(this, _preferencesList)[name] = preference = new _preference__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n          name,\n          body,\n          storage: preferencesStorage\n        });\n      }\n\n      _classPrivateFieldGet(this, _transferEvent).call(this, preference, 'updated');\n\n      _classPrivateFieldGet(this, _transferEvent).call(this, preference, 'removed');\n      /**\n       * Preference added event\n       *\n       * @event module:preferences~Preferences#event:added\n       *\n       * @type module:preferences/preference\n       */\n\n\n      this.emit('added', preference);\n      return preference;\n    }\n    /**\n     * Same as {@link module:preferences~Preferences~remove|~remove}(preference, { sync: false })\n     *\n     * @param {(string|module:preferences/preference)} preference\n     *\n     * @async\n     *\n     * @see module:preferences~Preferences~remove\n     */\n\n\n    remove(preference) {\n      return _classPrivateFieldGet(this, _remove).call(this, preference, {\n        sync: false\n      });\n    }\n    /**\n     * Same as {@link module:preferences~Preferences~remove|~remove}(preference)\n     *\n     * @param {(string|module:preferences/preference)} preference\n     *\n     * @see module:preferences~Preferences~remove\n     */\n\n\n    removeSync(preference) {\n      return _classPrivateFieldGet(this, _remove).call(this, preference);\n    }\n    /**\n     * Check Preference is already exist\n     *\n     * @param {string} preferenceName Storage's name to check\n     *\n     * @return {boolean}\n     */\n\n\n    has(preferenceName) {\n      return _classPrivateFieldGet(this, _preferencesList).hasOwnProperty(preferenceName);\n    }\n\n  } // Set string tag\n\n\n  var _preferencesList = new WeakMap();\n\n  var _transferEvent = new WeakMap();\n\n  var _remove = new WeakMap();\n\n  _helpers__WEBPACK_IMPORTED_MODULE_2__[\"decorator\"].setStringTag()(Preferences);\n  const preferences = new Preferences() // Logging\n  ;\n\n  (() => {\n    preferences.on('added', preference => logger.info('makePreferences', {\n      module: 'preferences',\n      event: 'added'\n    }, preference));\n    preferences.on('removed', (preference, {\n      name\n    }) => logger.info('makePreferences', {\n      module: 'preferences',\n      event: 'removed'\n    }, preference, {\n      preference: {\n        name\n      }\n    }));\n    preferences.on('updated', preference => logger.info('makePreferences', {\n      module: 'preferences',\n      event: 'updated'\n    }, preference));\n  })();\n\n  return preferences;\n}\n\n\n\n//# sourceURL=src/preferences/index.js");

/***/ }),

/***/ "./preferences/preference.js":
/*!***********************************!*\
  !*** ./preferences/preference.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Preference; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _storages_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../storages/storage */ \"./storages/storage.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/* global global */\n\n/**\n * @module preferences/preference\n */\n\n\n\n // Error classes\n\nconst logObject = {\n  scope: 'preference',\n  class: 'Preference',\n  event: undefined,\n  module: undefined\n};\nconst Error = Object(_logger__WEBPACK_IMPORTED_MODULE_3__[\"makeClassLoggable\"])(global.Error, logObject);\n\nconst _TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_3__[\"makeClassLoggable\"])(global.TypeError, logObject);\n\nconst GLOBAL_ERRORS = {\n  accessibility: new Error('Preference is not accessible')\n  /**\n   * Preference is a holder for modules preferences\n   *\n   * @mixes module:remote-controller-server-core~external:EventEmitter\n   */\n\n};\nclass Preference extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n  /**\n   * preferences storage\n   *\n   * @type {module:storages/storage}\n   */\n\n  /**\n   * Preference's name\n   *\n   * @type {string}\n   */\n\n  /**\n   * Update Preference content\n   *\n   * @function update\n   * @memberOf module:preferences/preference\n   * @inner\n   *\n   * @param {(object|function)} body Updated Preference body, if body is a function, a copy of last body passed to it, then have to return object as Preference body\n   * @param {object} [configs={}]\n   * @param {boolean} [configs.sync=true] Async or sync\n   *\n   * @throws Will throw an error if the Preference is not accessible\n   *\n   * @emits module:preferences/preference#event:updated\n   *\n   * @return {(void|Promise<(void|Error)>)} Return promise if configs.sync equal to false\n   * * Rejection\n   *  * Reject an error if the Preference is not accessible\n   */\n\n  /**\n   * Remove Preference object\n   *\n   * @function remove\n   * @memberOf module:preferences/preference\n   * @inner\n   *\n   * @param {object} [configs={}]\n   * @param {boolean} [configs.sync=true] Async or sync\n   *\n   * @throws Will throw an error if the Preference is not accessible\n   *\n   * @emits module:preferences/preference#event:removed\n   *\n   * @return {(void|Promise<(void|Error)>)} Return promise if configs.sync equal to false\n   * * Rejection\n   *  * Reject an error if the Preference is not accessible\n   */\n\n  /**\n   * Initialize/Read Preference\n   *\n   * @param {object} configs\n   * @param {string} configs.name Preference's name\n   * @param {module:storages/storage} configs.storage Storage that use for preferences\n   * @param {object} [configs.body] Preference's initial content\n   *\n   * @throws Will throw an error if the storage is not accessible\n   * @throws Will throw an error if the body property provided but storage is already exist\n   * @throws Will throw an error if the body property not provided and storage is not accessible\n   */\n  constructor(_configs) {\n    const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_3__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n      method: 'constructor'\n    });\n    if (typeof _configs !== 'object') throw new _TypeError('configs parameter is required and must be object');else if (typeof _configs.name !== 'string') throw new _TypeError('configs.name is required and must be string');else if (_configs.storage === undefined || !(_configs.storage instanceof _storages_storage__WEBPACK_IMPORTED_MODULE_1__[\"default\"])) throw new _TypeError('configs.storage is required and must be Storage');else if (_configs.storage.body === undefined) throw new Error('Storage is not accessible');else if (_configs.body !== undefined && typeof _configs.body !== 'object') throw new _TypeError('configs.body must be object');\n    super();\n\n    _storage.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _name.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _update.set(this, {\n      writable: true,\n      value: (body, configs = Object.create(null)) => {\n        // Make body object from function\n        if (typeof body === 'function') body = body(this.body);\n        if (typeof body !== 'object') throw new _TypeError('body parameter is required and must be object/function'); // Set default configs\n\n        configs = Object.assign({\n          sync: true\n        }, configs);\n\n        const updateBody = storageBody => {\n          storageBody[_classPrivateFieldGet(this, _name)] = body;\n          return storageBody;\n        };\n\n        const currentBody = this.body;\n        /**\n         * Preference updated event\n         *\n         * @event module:preferences/preference#event:updated\n         *\n         * @type {object}\n         * @property {object} lastBody Preference's body before update\n         * @property {object} updatedBody A copy of updated body object\n         */\n\n        const fireEvent = () => {\n          const EVENT = {\n            lastBody: currentBody,\n            updatedBody: this.body\n          };\n          this.emit('updated', EVENT);\n        };\n\n        if (configs.sync) {\n          if (_classPrivateFieldGet(this, _storage) === undefined) {\n            throw GLOBAL_ERRORS.accessibility.setLogObject({\n              method: '#update'\n            });\n          }\n\n          _classPrivateFieldGet(this, _storage).updateSync(updateBody);\n\n          fireEvent();\n          return;\n        }\n\n        if (_classPrivateFieldGet(this, _storage) === undefined) {\n          return Promise.reject(GLOBAL_ERRORS.accessibility.setLogObject({\n            method: '#update'\n          }));\n        }\n\n        return _classPrivateFieldGet(this, _storage).update(updateBody).then(fireEvent, error => Promise.reject(error));\n      }\n    });\n\n    _remove.set(this, {\n      writable: true,\n      value: (configs = Object.create(null)) => {\n        const lastBody = this.body;\n\n        const deletePreference = body => {\n          delete body[this.name];\n          return body;\n        };\n        /**\n         * Preference removed event\n         *\n         * @event module:preferences/preference#event:removed\n         *\n         * @type {object}\n         * @property {string} name Name of the removed Preference\n         * @property {object} body Last body of the removed Preference\n         */\n\n\n        const clearProperties = () => {\n          const EVENT = {\n            name: this.name,\n            body: lastBody\n          };\n\n          _classPrivateFieldSet(this, _storage, undefined);\n\n          _classPrivateFieldSet(this, _name, undefined);\n\n          this.emit('removed', EVENT);\n        }; // Set default configs\n\n\n        configs = Object.assign({\n          sync: true\n        }, configs);\n\n        if (configs.sync) {\n          if (_classPrivateFieldGet(this, _storage) === undefined) {\n            throw GLOBAL_ERRORS.accessibility.setLogObject({\n              method: '#remove'\n            });\n          }\n\n          _classPrivateFieldGet(this, _storage).updateSync(deletePreference);\n\n          clearProperties();\n          return;\n        }\n\n        if (_classPrivateFieldGet(this, _storage) === undefined) {\n          return Promise.reject(GLOBAL_ERRORS.accessibility.setLogObject({\n            method: '#remove'\n          }));\n        }\n\n        return _classPrivateFieldGet(this, _storage).update(deletePreference).then(clearProperties, error => Promise.reject(error));\n      }\n    });\n\n    _classPrivateFieldSet(this, _storage, _configs.storage);\n\n    _classPrivateFieldSet(this, _name, _configs.name);\n\n    let initial = false;\n    if (_configs.body) initial = true;\n\n    if (initial) {\n      if (typeof _classPrivateFieldGet(this, _storage).body[_classPrivateFieldGet(this, _name)] === 'object') throw new Error(`${_classPrivateFieldGet(this, _name)} is already exist`);\n\n      _classPrivateFieldGet(this, _storage).updateSync(body => {\n        body[_classPrivateFieldGet(this, _name)] = _configs.body;\n        return body;\n      });\n    } else if (typeof _classPrivateFieldGet(this, _storage).body[_classPrivateFieldGet(this, _name)] !== 'object') throw new Error(`${_classPrivateFieldGet(this, _name)} is not accessible`);\n  }\n  /**\n   * Preference's name\n   *\n   * @type {string}\n   */\n\n\n  get name() {\n    return _classPrivateFieldGet(this, _name);\n  }\n  /**\n   * Copy of Preference's body object\n   *\n   * @type {string}\n   */\n\n\n  get body() {\n    if (_classPrivateFieldGet(this, _storage) && _classPrivateFieldGet(this, _storage).body && _classPrivateFieldGet(this, _storage).body[_classPrivateFieldGet(this, _name)]) {\n      return JSON.parse(JSON.stringify(_classPrivateFieldGet(this, _storage).body[_classPrivateFieldGet(this, _name)]));\n    }\n  }\n  /**\n   * Same as {@link module:preferences/preference~remove|~remove}({ sync: false })\n   *\n   * @async\n   *\n   * @see module:preferences/preference~remove\n   */\n\n\n  remove() {\n    return _classPrivateFieldGet(this, _remove).call(this, {\n      sync: false\n    });\n  }\n  /**\n   * Same as {@link module:preferences/preference~remove|~remove}()\n   *\n   * @see module:preferences/preference~remove\n   */\n\n\n  removeSync() {\n    return _classPrivateFieldGet(this, _remove).call(this);\n  }\n  /**\n   * Same as {@link module:preferences/preference~update|~update}(body, { sync: false })\n   *\n   * @param {(object|function)} body\n   *\n   * @async\n   *\n   * @see module:preferences/preference~update\n   */\n\n\n  update(body) {\n    return _classPrivateFieldGet(this, _update).call(this, body, {\n      sync: false\n    });\n  }\n  /**\n   * Same as {@link module:preferences/preference~update|~update}(body)\n   *\n   * @param {(object|function)} body\n   *\n   * @see module:preferences/preference~update\n   */\n\n\n  updateSync(body) {\n    return _classPrivateFieldGet(this, _update).call(this, body);\n  }\n\n  get [_logger__WEBPACK_IMPORTED_MODULE_3__[\"logSymbol\"]]() {\n    return Object.assign({\n      preference: {\n        name: this.name\n      }\n    }, _classPrivateFieldGet(this, _storage) && _classPrivateFieldGet(this, _storage)[_logger__WEBPACK_IMPORTED_MODULE_3__[\"logSymbol\"]]);\n  }\n\n} // Set string tag\n\nvar _storage = new WeakMap();\n\nvar _name = new WeakMap();\n\nvar _update = new WeakMap();\n\nvar _remove = new WeakMap();\n\n_helpers__WEBPACK_IMPORTED_MODULE_2__[\"decorator\"].setStringTag()(Preference);\n\n//# sourceURL=src/preferences/preference.js");

/***/ }),

/***/ "./storages/index.js":
/*!***************************!*\
  !*** ./storages/index.js ***!
  \***************************/
/*! exports provided: default, Storage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makeStorages; });\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ \"./storages/storage.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Storage\", function() { return _storage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/* global global */\n\n/**\n * @module storages\n */\n\n\n\n\n\n\n/**\n * makeStorages creates storages module\n *\n * @param {object} [configs={}]\n * @param {string} [configs.path=process.cwd()] Storages path address\n *\n * @return {module:storages~Storages}\n */\n\nfunction makeStorages(configs = Object.create(null)) {\n  // Error classes\n  const logObject = {\n    scope: 'makeStorages',\n    event: undefined,\n    module: undefined\n  };\n  const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_2__[\"makeClassLoggable\"])(global.Error, logObject);\n  const TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_2__[\"makeClassLoggable\"])(global.TypeError, logObject); // Set default configs\n\n  configs = Object.assign({\n    path: path__WEBPACK_IMPORTED_MODULE_5___default.a.join(process.cwd(), 'storage')\n  }, configs);\n  if (typeof configs.path !== 'string') throw new TypeError('configs.path must be string');\n\n  try {\n    fs__WEBPACK_IMPORTED_MODULE_4___default.a.mkdirSync(configs.path, {\n      recursive: true\n    });\n  } catch (error) {\n    if (error.code !== 'EEXIST') throw error;\n  }\n\n  const logger = this.logger;\n  logObject.module = 'storages';\n  Error.setLogObject(logObject);\n  TypeError.setLogObject(logObject);\n  const STORAGES_GLOBAL_ERRORS = {\n    accessibility: new Error('Storage is not accessible'),\n    existence: name => new Error(`${name} is not exist in list`)\n    /**\n     * Storages module is a Storage holder/manager\n     *\n     * @memberOf module:storages\n     * @inner\n     */\n\n  };\n\n  class Storages extends events__WEBPACK_IMPORTED_MODULE_1___default.a {\n    /**\n     * @type {Object}\n     */\n    // JSDoc doesnt use this class without constructor :/\n    constructor() {\n      super();\n\n      _storagesList.set(this, {\n        writable: true,\n        value: {}\n      });\n\n      _transferEvent.set(this, {\n        writable: true,\n        value: (storage, eventName) => storage.on(eventName, event => this.emit(eventName, storage, event))\n      });\n\n      _remove.set(this, {\n        writable: true,\n        value: (storage, configs = Object.create(null)) => {\n          if (storage === undefined || typeof storage !== 'string' && !(storage instanceof _storage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])) throw new TypeError('storage parameter is required and must be string/Storage'); // Set default configs\n\n          configs = Object.assign({\n            sync: true\n          }, configs);\n          const name = storage.name || storage;\n\n          const deleteStorage = () => {\n            delete _classPrivateFieldGet(this, _storagesList)[name];\n          };\n\n          const ERRORS = {\n            accessibility: STORAGES_GLOBAL_ERRORS.accessibility,\n            existence: STORAGES_GLOBAL_ERRORS.existence(name)\n          };\n          storage = _classPrivateFieldGet(this, _storagesList)[name];\n\n          if (configs.sync) {\n            if (typeof name !== 'string') throw ERRORS.accessibility.setLogObject({\n              method: '#remove'\n            });\n            if (storage === undefined) throw ERRORS.existence.setLogObject({\n              method: '#remove'\n            });\n            storage.removeSync();\n            deleteStorage();\n            return;\n          }\n\n          if (typeof name !== 'string') {\n            return Promise.reject(ERRORS.accessibility.setLogObject({\n              method: '#remove'\n            }));\n          }\n\n          if (storage === undefined) {\n            return Promise.reject(ERRORS.existence.setLogObject({\n              method: '#remove'\n            }));\n          }\n\n          return storage.remove().then(deleteStorage, error => Promise.reject(error));\n        }\n      });\n    } // eslint-disable-line no-useless-constructor\n\n    /**\n     * @summary Storage updated event\n     * @description Target Storage pass as first parameter, and event pass as second parameter\n     *\n     * @event module:storages~Storages#event:updated\n     *\n     * @type {module:storages/storage}\n     *\n     * @see module:storages/storage#event:updated\n     */\n\n    /**\n     * @summary Storage removed event\n     * @description Target Storage pass as first parameter, and event pass as second parameter\n     *\n     * @event module:storages~Storages#event:removed\n     *\n     * @type {module:storages/storage}\n     *\n     * @see module:storages/storage#event:removed\n     */\n\n    /**\n     * Transfer event from storage instance to storages module\n     *\n     * @param {module:storages/storage} storage\n     * @param {string} eventName\n     *\n     * @return {module:storages/storage}\n     */\n\n\n    /**\n     * Get Storage instance via it's name\n     *\n     * @param {string} name Target storage's name\n     *\n     * @emits module:storages~Storages#event:updated\n     * @emits module:storages~Storages#event:removed\n     *\n     * @listens module:storages/storage#event:updated\n     * @listens module:storages/storage#event:removed\n     *\n     * @return {module:storages/storage}\n     */\n    get(name) {\n      if (typeof name !== 'string') throw new TypeError('name parameter is required and must be string'); // Return Storage from list if exist\n\n      if (_classPrivateFieldGet(this, _storagesList).hasOwnProperty(name)) return _classPrivateFieldGet(this, _storagesList)[name];\n      _classPrivateFieldGet(this, _storagesList)[name] = new _storage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        name,\n        path: configs.path\n      });\n\n      _classPrivateFieldGet(this, _transferEvent).call(this, _classPrivateFieldGet(this, _storagesList)[name], 'updated');\n\n      _classPrivateFieldGet(this, _transferEvent).call(this, _classPrivateFieldGet(this, _storagesList)[name], 'removed');\n\n      return _classPrivateFieldGet(this, _storagesList)[name];\n    }\n    /**\n     * Add/Initialize Storage\n     *\n     * @param {(module:storages/storage|string)} storage Storage instance or storage's name\n     * @param {object} [body={}] Storage's initial content\n     *\n     * @emits module:storages~Storages#event:updated\n     * @emits module:storages~Storages#event:removed\n     * @emits module:storages~Storages#event:added\n     *\n     * @listens module:storages/storage#event:updated\n     * @listens module:storages/storage#event:removed\n     *\n     * @throws Will throw an error if Storage is already exist in list\n     *\n     * @return {module:storages/storage}\n     */\n\n\n    add(storage, body = Object.create(null)) {\n      const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_2__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n        method: 'add',\n        ...this[_logger__WEBPACK_IMPORTED_MODULE_2__[\"logSymbol\"]]\n      });\n      if (!(storage instanceof _storage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) && typeof storage !== 'string') throw new TypeError('storage parameter is required and must be Storage/string');else if (typeof body !== 'object') throw new TypeError('body parameter must be object');\n      let name = storage.name || storage;\n      if (!(storage instanceof _storage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])) storage = undefined;\n      if (_classPrivateFieldGet(this, _storagesList).hasOwnProperty(name)) throw new Error(`${name} is already exist`);\n\n      if (storage) {\n        _classPrivateFieldGet(this, _storagesList)[name] = storage;\n      } else {\n        _classPrivateFieldGet(this, _storagesList)[name] = storage = new _storage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n          name,\n          body,\n          path: configs.path\n        });\n      }\n\n      _classPrivateFieldGet(this, _transferEvent).call(this, storage, 'updated');\n\n      _classPrivateFieldGet(this, _transferEvent).call(this, storage, 'removed');\n      /**\n       * Storage added event\n       *\n       * @event module:storages~Storages#event:added\n       *\n       * @type module:storages/storage\n       */\n\n\n      this.emit('added', storage);\n      return storage;\n    }\n    /**\n     * Same as {@link module:storages~Storages~remove|~remove}(storage, { sync: false })\n     *\n     * @param {(string|module:storages/storage)} storage\n     *\n     * @async\n     *\n     * @see module:storages~Storages~remove\n     */\n\n\n    remove(storage) {\n      return _classPrivateFieldGet(this, _remove).call(this, storage, {\n        sync: false\n      });\n    }\n    /**\n     * Same as {@link module:storages~Storages~remove|~remove}(storage)\n     *\n     * @param {(string|module:storages/storage)} storage\n     *\n     * @see module:storages~Storages~remove\n     */\n\n\n    removeSync(storage) {\n      return _classPrivateFieldGet(this, _remove).call(this, storage);\n    }\n    /**\n     * Check Storage is already exist\n     *\n     * @param {string} storageName Storage's name to check\n     *\n     * @return {boolean}\n     */\n\n\n    has(storageName) {\n      return _classPrivateFieldGet(this, _storagesList).hasOwnProperty(storageName);\n    }\n    /**\n     * Return storage's path\n     *\n     * @return {string}\n     */\n\n\n    get path() {\n      return configs.path;\n    }\n\n    get [_logger__WEBPACK_IMPORTED_MODULE_2__[\"logSymbol\"]]() {\n      return {\n        storages: {\n          path: this.path\n        }\n      };\n    }\n\n  } // Set string tag\n\n\n  var _storagesList = new WeakMap();\n\n  var _transferEvent = new WeakMap();\n\n  var _remove = new WeakMap();\n\n  _helpers__WEBPACK_IMPORTED_MODULE_3__[\"decorator\"].setStringTag()(Storages);\n  const storages = new Storages() // Logging\n  ;\n\n  (() => {\n    storages.on('added', storage => logger.info('makeStorages', {\n      module: 'storages',\n      event: 'added'\n    }, storage, storages));\n    storages.on('removed', (storage, {\n      name\n    }) => logger.info('makeStorages', {\n      module: 'storages',\n      event: 'removed'\n    }, storage, {\n      storage: {\n        name\n      }\n    }, storages));\n    storages.on('updated', storage => logger.info('makeStorages', {\n      module: 'storages',\n      event: 'updated'\n    }, storage, storages));\n  })();\n\n  return storages;\n}\n\n\n\n//# sourceURL=src/storages/index.js");

/***/ }),

/***/ "./storages/storage.js":
/*!*****************************!*\
  !*** ./storages/storage.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Storage; });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logger */ \"./logger.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers */ \"./helpers.js\");\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/* global global */\n\n/**\n * @module storages/storage\n */\n\n\n\n\n\n\nconst ENCODING = 'utf8'; // Error classes\n\nconst logObject = {\n  scope: 'storage',\n  class: 'Storage',\n  event: undefined,\n  module: undefined\n};\nconst Error = Object(_logger__WEBPACK_IMPORTED_MODULE_4__[\"makeClassLoggable\"])(global.Error, logObject);\n\nconst _TypeError = Object(_logger__WEBPACK_IMPORTED_MODULE_4__[\"makeClassLoggable\"])(global.TypeError, logObject);\n\nconst GLOBAL_ERRORS = {\n  accessibility: new Error('Storage is not accessible')\n  /**\n   * Storage is a json file Manager\n   *\n   * @mixes module:remote-controller-server-core~external:EventEmitter\n   */\n\n};\nclass Storage extends events__WEBPACK_IMPORTED_MODULE_3___default.a {\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {object}\n   */\n\n  /**\n   * Remove storage json file\n   *\n   * @function remove\n   * @memberOf module:storages/storage\n   * @inner\n   *\n   * @param {object} [configs={}]\n   * @param {boolean} [configs.sync=true] Async or sync\n   *\n   * @throws Will throw an error if the storage's json file doesn't accessible\n   *\n   * @emits module:storages/storage#event:removed\n   *\n   * @return {(void|Promise<(void|Error)>)} Return promise if configs.sync equal to false\n   * * Rejection\n   *  * Reject an error if the storage's json file doesn't accessible\n   */\n\n  /**\n   * Update storage content\n   *\n   * @function update\n   * @memberOf module:storages/storage\n   * @inner\n   *\n   * @param {(object|function)} body Updated Storage body, if body is a function, a copy of last body passed to it, then have to return object as storage body\n   * @param {object} [configs={}]\n   * @param {boolean} [configs.sync=true] Async or sync\n   *\n   * @throws Will throw an error if the storage's json file doesn't accessible\n   *\n   * @emits module:storages/storage#event:updated\n   *\n   * @return {(void|Promise<(void|Error)>)} Return promise if configs.sync equal to false\n   * * Rejection\n   *  * Reject an error if the storage's json file doesn't accessible\n   */\n\n  /**\n   * Initialize/Read json file\n   *\n   * @param {object} configs\n   * @param {string} configs.name json file name\n   * @param {object} [configs.body] json file initial content\n   * @param {object} [configs.path=process.cwd()] json file initial content\n   *\n   * @throws Will throw an error if the requested storage's json file is not accessible\n   * @throws Will throw an error if the body property provided but storage is already exist\n   * @throws Will throw an error if the body property not provided and storage is not accessible\n   */\n  constructor(_configs) {\n    const Error = Object(_logger__WEBPACK_IMPORTED_MODULE_4__[\"makeClassLoggable\"])(global.Error, logObject).assignLogObject({\n      method: 'constructor'\n    });\n    if (typeof _configs !== 'object') throw new _TypeError('configs parameter is required and must be object'); // Set default configs\n\n    _configs = Object.assign({\n      path: process.cwd()\n    }, _configs);\n    if (typeof _configs.name !== 'string') throw new _TypeError('configs.name is required and must be string');else if (_configs.body !== undefined && typeof _configs.body !== 'object') throw new _TypeError('configs.body must be object');else if (typeof _configs.path !== 'string') throw new _TypeError('configs.path must be string');\n    super();\n\n    _name.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _address.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _body.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _remove.set(this, {\n      writable: true,\n      value: (configs = Object.create(null)) => {\n        // Set default configs\n        configs = Object.assign({\n          sync: true\n        }, configs);\n\n        const clearProperties = () => {\n          const EVENT = {\n            name: _classPrivateFieldGet(this, _name),\n            body: _classPrivateFieldGet(this, _body)\n          };\n\n          _classPrivateFieldSet(this, _body, undefined);\n\n          _classPrivateFieldSet(this, _name, undefined);\n          /**\n           * Storage removed event\n           *\n           * @event module:storages/storage#event:removed\n           *\n           * @type {object}\n           * @property {string} name Name of the removed storage\n           * @property {object} body Last body of the removed storage\n           */\n\n\n          this.emit('removed', EVENT);\n        };\n\n        if (configs.sync) {\n          try {\n            fs__WEBPACK_IMPORTED_MODULE_1___default.a.accessSync(_classPrivateFieldGet(this, _address), fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.F_OK | fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.W_OK);\n          } catch (error) {\n            throw GLOBAL_ERRORS.accessibility.setLogObject({\n              method: '#remove'\n            });\n          }\n\n          fs__WEBPACK_IMPORTED_MODULE_1___default.a.unlinkSync(_classPrivateFieldGet(this, _address));\n          clearProperties();\n          return;\n        }\n\n        return Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(fs__WEBPACK_IMPORTED_MODULE_1___default.a.access)(_classPrivateFieldGet(this, _address), fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.F_OK | fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.W_OK).then(() => {\n          return Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(fs__WEBPACK_IMPORTED_MODULE_1___default.a.unlink)(_classPrivateFieldGet(this, _address)).then(clearProperties, error => Promise.reject(error));\n        }, () => Promise.reject(GLOBAL_ERRORS.accessibility.setLogObject({\n          method: '#remove'\n        })));\n      }\n    });\n\n    _update.set(this, {\n      writable: true,\n      value: (body, configs = Object.create(null)) => {\n        if (typeof body === 'function') body = body(this.body); // Set default configs\n\n        configs = Object.assign({\n          sync: true\n        }, configs);\n        if (body === undefined || typeof body !== 'object') throw new _TypeError('body parameter is required and must be object/function');\n\n        const setProperties = () => {\n          const EVENT = {\n            lastBody: _classPrivateFieldGet(this, _body),\n            updatedBody: JSON.parse(JSON.stringify(body))\n          };\n\n          _classPrivateFieldSet(this, _body, body);\n          /**\n           * Storage updated event\n           *\n           * @event module:storages/storage#event:updated\n           *\n           * @type {object}\n           * @property {object} lastBody storage's body before update\n           * @property {object} updatedBody A copy of updated body object\n           */\n\n\n          this.emit('updated', EVENT);\n        };\n\n        if (configs.sync) {\n          try {\n            fs__WEBPACK_IMPORTED_MODULE_1___default.a.accessSync(_classPrivateFieldGet(this, _address), fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.F_OK | fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.W_OK);\n          } catch (error) {\n            throw GLOBAL_ERRORS.accessibility.setLogObject({\n              method: '#update'\n            });\n          }\n\n          fs__WEBPACK_IMPORTED_MODULE_1___default.a.writeFileSync(_classPrivateFieldGet(this, _address), JSON.stringify(body), {\n            encoding: ENCODING,\n            flag: 'w'\n          });\n          setProperties();\n          return;\n        }\n\n        return Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(fs__WEBPACK_IMPORTED_MODULE_1___default.a.access)(_classPrivateFieldGet(this, _address), fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.F_OK | fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.W_OK).then(() => {\n          return Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(fs__WEBPACK_IMPORTED_MODULE_1___default.a.writeFile)(_classPrivateFieldGet(this, _address), JSON.stringify(body), {\n            encoding: ENCODING,\n            flag: 'w'\n          }).then(setProperties, error => Promise.reject(error));\n        }, () => Promise.reject(GLOBAL_ERRORS.accessibility.setLogObject({\n          method: '#update'\n        })));\n      }\n    });\n\n    let initial = false;\n    let storageAccessible;\n    let storageAddress; // Mark as must initial if configs.body property is defined\n\n    if (_configs.body !== undefined) initial = true;\n    storageAddress = path__WEBPACK_IMPORTED_MODULE_2___default.a.join(_configs.path, _configs.name + '.json'); // Check storage accessibility\n\n    try {\n      fs__WEBPACK_IMPORTED_MODULE_1___default.a.accessSync(storageAddress, fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.F_OK | fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.W_OK);\n      storageAccessible = true;\n    } catch (error) {\n      storageAccessible = false;\n    }\n\n    if (initial) {\n      if (storageAccessible) throw new Error(`${_configs.name} is already exist`);\n      fs__WEBPACK_IMPORTED_MODULE_1___default.a.writeFileSync(storageAddress, JSON.stringify(_configs.body), {\n        encoding: ENCODING,\n        flag: 'w'\n      }); // Take a copy of body\n\n      _classPrivateFieldSet(this, _body, JSON.parse(JSON.stringify(_configs.body)));\n    } else {\n      if (!storageAccessible) throw new Error(`${_configs.name} is not accessible`); // Read storage and convert it to object\n\n      _classPrivateFieldSet(this, _body, JSON.parse(fs__WEBPACK_IMPORTED_MODULE_1___default.a.readFileSync(storageAddress, {\n        encoding: ENCODING,\n        flag: 'r'\n      })));\n    }\n\n    _classPrivateFieldSet(this, _name, _configs.name);\n\n    _classPrivateFieldSet(this, _address, storageAddress);\n  }\n  /**\n   * Storage's content object\n   *\n   * @type {object}\n   */\n\n\n  get body() {\n    return _classPrivateFieldGet(this, _body) ? JSON.parse(JSON.stringify(_classPrivateFieldGet(this, _body))) : undefined;\n  }\n  /**\n   * Storage's name\n   *\n   * @type {string}\n   */\n\n\n  get name() {\n    return _classPrivateFieldGet(this, _name);\n  }\n  /**\n   * Same as {@link module:storages/storage~remove|~remove}({ sync: false })\n   *\n   * @async\n   *\n   * @see module:storages/storage~remove\n   */\n\n\n  remove() {\n    return _classPrivateFieldGet(this, _remove).call(this, {\n      sync: false\n    });\n  }\n  /**\n   * Same as {@link module:storages/storage~remove|~remove}()\n   *\n   * @see module:storages/storage~remove\n   */\n\n\n  removeSync() {\n    return _classPrivateFieldGet(this, _remove).call(this);\n  }\n  /**\n   * Same as {@link module:storages/storage~update|~update}(body, { sync: false })\n   *\n   * @param {(object|function)} body\n   *\n   * @async\n   *\n   * @see module:storages/storage~update\n   */\n\n\n  update(body) {\n    return _classPrivateFieldGet(this, _update).call(this, body, {\n      sync: false\n    });\n  }\n  /**\n   * Same as {@link module:storages/storage~update|~update}(body)\n   *\n   * @param {(object|function)} body\n   *\n   * @see module:storages/storage~update\n   */\n\n\n  updateSync(body) {\n    return _classPrivateFieldGet(this, _update).call(this, body);\n  }\n\n  get [_logger__WEBPACK_IMPORTED_MODULE_4__[\"logSymbol\"]]() {\n    return {\n      storage: {\n        name: this.name,\n        address: _classPrivateFieldGet(this, _address)\n      }\n    };\n  }\n\n} // Set string tag\n\nvar _name = new WeakMap();\n\nvar _address = new WeakMap();\n\nvar _body = new WeakMap();\n\nvar _remove = new WeakMap();\n\nvar _update = new WeakMap();\n\n_helpers__WEBPACK_IMPORTED_MODULE_5__[\"decorator\"].setStringTag()(Storage);\n\n//# sourceURL=src/storages/storage.js");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"assert\");\n\n//# sourceURL=src/external_%22assert%22");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=src/external_%22crypto%22");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=src/external_%22events%22");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=src/external_%22fs%22");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=src/external_%22http%22");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=src/external_%22https%22");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"net\");\n\n//# sourceURL=src/external_%22net%22");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=src/external_%22os%22");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=src/external_%22path%22");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");\n\n//# sourceURL=src/external_%22stream%22");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tls\");\n\n//# sourceURL=src/external_%22tls%22");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=src/external_%22url%22");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=src/external_%22util%22");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");\n\n//# sourceURL=src/external_%22zlib%22");

/***/ })

/******/ });
});