(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/async-limiter/index.js":
/*!**********************************************!*\
  !*** ../node_modules/async-limiter/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction Queue(options) {\n  if (!(this instanceof Queue)) {\n    return new Queue(options);\n  }\n\n  options = options || {};\n  this.concurrency = options.concurrency || Infinity;\n  this.pending = 0;\n  this.jobs = [];\n  this.cbs = [];\n  this._done = done.bind(this);\n}\n\nvar arrayAddMethods = [\n  'push',\n  'unshift',\n  'splice'\n];\n\narrayAddMethods.forEach(function(method) {\n  Queue.prototype[method] = function() {\n    var methodResult = Array.prototype[method].apply(this.jobs, arguments);\n    this._run();\n    return methodResult;\n  };\n});\n\nObject.defineProperty(Queue.prototype, 'length', {\n  get: function() {\n    return this.pending + this.jobs.length;\n  }\n});\n\nQueue.prototype._run = function() {\n  if (this.pending === this.concurrency) {\n    return;\n  }\n  if (this.jobs.length) {\n    var job = this.jobs.shift();\n    this.pending++;\n    job(this._done);\n    this._run();\n  }\n\n  if (this.pending === 0) {\n    while (this.cbs.length !== 0) {\n      var cb = this.cbs.pop();\n      process.nextTick(cb);\n    }\n  }\n};\n\nQueue.prototype.onDone = function(cb) {\n  if (typeof cb === 'function') {\n    this.cbs.push(cb);\n    this._run();\n  }\n};\n\nfunction done() {\n  this.pending--;\n  this._run();\n}\n\nmodule.exports = Queue;\n\n\n//# sourceURL=node_modules/async-limiter/index.js");

/***/ }),

/***/ "../node_modules/bufferutil/fallback.js":
/*!**********************************************!*\
  !*** ../node_modules/bufferutil/fallback.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nconst mask = (source, mask, output, offset, length) => {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n};\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nconst unmask = (buffer, mask) => {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n};\n\nmodule.exports = { mask, unmask };\n\n\n//# sourceURL=node_modules/bufferutil/fallback.js");

/***/ }),

/***/ "../node_modules/bufferutil/index.js":
/*!*******************************************!*\
  !*** ../node_modules/bufferutil/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"../node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"../node_modules/bufferutil/fallback.js\");\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=node_modules/bufferutil/index.js");

/***/ }),

/***/ "../node_modules/node-gyp-build/index.js":
/*!***********************************************!*\
  !*** ../node_modules/node-gyp-build/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar os = __webpack_require__(/*! os */ \"os\")\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire =  true ? require : undefined // eslint-disable-line\n\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : 'node'\nvar arch = os.arch()\nvar platform = os.platform()\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n  if (release) return release\n\n  var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n  if (debug) return debug\n\n  var prebuild = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchPrebuild)\n  if (prebuild) return prebuild\n\n  var napiRuntime = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapiRuntime)\n  if (napiRuntime) return napiRuntime\n\n  var napi = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapi)\n  if (napi) return napi\n\n  throw new Error('No native build was found for runtime=' + runtime + ' abi=' + abi + ' platform=' + platform + ' arch=' + arch)\n}\n\nfunction getFirst (dir, filter) {\n  try {\n    var files = fs.readdirSync(dir).filter(filter)\n    return files[0] && path.join(dir, files[0])\n  } catch (err) {\n    return null\n  }\n}\n\nfunction matchNapiRuntime (name) {\n  return name === runtime + '-napi.node'\n}\n\nfunction matchNapi (name) {\n  return name === 'node-napi.node'\n}\n\nfunction matchPrebuild (name) {\n  var parts = name.split('-')\n  return parts[0] === runtime && parts[1] === abi + '.node'\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\n\n//# sourceURL=node_modules/node-gyp-build/index.js");

/***/ }),

/***/ "../node_modules/utf-8-validate/fallback.js":
/*!**************************************************!*\
  !*** ../node_modules/utf-8-validate/fallback.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nconst isValidUTF8 = (buf) => {\n  var len = buf.length;\n  var i = 0;\n\n  while (i < len) {\n    if (buf[i] < 0x80) {  // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0  // overlong\n      ) {\n        return false;\n      } else {\n        i += 2;\n      }\n    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong\n        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0     // surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      } else {\n        i += 3;\n      }\n    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong\n        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF\n      ) {\n        return false;\n      } else {\n        i += 4;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = isValidUTF8;\n\n\n//# sourceURL=node_modules/utf-8-validate/fallback.js");

/***/ }),

/***/ "../node_modules/utf-8-validate/index.js":
/*!***********************************************!*\
  !*** ../node_modules/utf-8-validate/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"../node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"../node_modules/utf-8-validate/fallback.js\");\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=node_modules/utf-8-validate/index.js");

/***/ }),

/***/ "../node_modules/ws/index.js":
/*!***********************************!*\
  !*** ../node_modules/ws/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"../node_modules/ws/lib/websocket.js\");\n\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"../node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"../node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"../node_modules/ws/lib/sender.js\");\n\nmodule.exports = WebSocket;\n\n\n//# sourceURL=node_modules/ws/index.js");

/***/ }),

/***/ "../node_modules/ws/lib/buffer-util.js":
/*!*********************************************!*\
  !*** ../node_modules/ws/lib/buffer-util.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  var offset = 0;\n\n  for (var i = 0; i < list.length; i++) {\n    const buf = list[i];\n    buf.copy(target, offset);\n    offset += buf.length;\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  var buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = viewToBuffer(data);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\nfunction viewToBuffer(view) {\n  const buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = __webpack_require__(/*! bufferutil */ \"../node_modules/bufferutil/index.js\");\n  const bu = bufferUtil.BufferUtil || bufferUtil;\n\n  module.exports = {\n    concat,\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bu.mask(source, mask, output, offset, length);\n    },\n    toArrayBuffer,\n    toBuffer,\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bu.unmask(buffer, mask);\n    }\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}\n\n\n//# sourceURL=node_modules/ws/lib/buffer-util.js");

/***/ }),

/***/ "../node_modules/ws/lib/constants.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/constants.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  EMPTY_BUFFER: Buffer.alloc(0),\n  NOOP: () => {}\n};\n\n\n//# sourceURL=node_modules/ws/lib/constants.js");

/***/ }),

/***/ "../node_modules/ws/lib/event-target.js":
/*!**********************************************!*\
  !*** ../node_modules/ws/lib/event-target.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Class representing an event.\n *\n * @private\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was dispatched\n   */\n  constructor(type, target) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(data, target) {\n    super('message', target);\n\n    this.data = data;\n  }\n}\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(code, reason, target) {\n    super('close', target);\n\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    this.reason = reason;\n    this.code = code;\n  }\n}\n\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\nclass OpenEvent extends Event {\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(target) {\n    super('open', target);\n  }\n}\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n * @private\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {Object} error The error that generated this event\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(error, target) {\n    super('error', target);\n\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} method A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @public\n   */\n  addEventListener(method, listener) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage(data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose(code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError(error) {\n      listener.call(this, new ErrorEvent(error, this));\n    }\n\n    function onOpen() {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    if (method === 'message') {\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} method A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener(method, listener) {\n    const listeners = this.listeners(method);\n\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(method, listeners[i]);\n      }\n    }\n  }\n};\n\nmodule.exports = EventTarget;\n\n\n//# sourceURL=node_modules/ws/lib/event-target.js");

/***/ }),

/***/ "../node_modules/ws/lib/extension.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/extension.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (Object.prototype.hasOwnProperty.call(dest, name)) dest[name].push(elem);\n  else dest[name] = [elem];\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = {};\n\n  if (header === undefined || header === '') return offers;\n\n  var params = {};\n  var mustUnescape = false;\n  var isEscaping = false;\n  var inQuotes = false;\n  var extensionName;\n  var paramName;\n  var start = -1;\n  var end = -1;\n\n  for (var i = 0; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = {};\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = {};\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        var value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = {};\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, {});\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      var configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                var values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n\n\n//# sourceURL=node_modules/ws/lib/extension.js");

/***/ }),

/***/ "../node_modules/ws/lib/permessage-deflate.js":
/*!****************************************************!*\
  !*** ../node_modules/ws/lib/permessage-deflate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Limiter = __webpack_require__(/*! async-limiter */ \"../node_modules/async-limiter/index.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"../node_modules/ws/lib/buffer-util.js\");\nconst { kStatusCode, NOOP } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst EMPTY_BLOCK = Buffer.from([0x00]);\n\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate\n   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter({ concurrency });\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      this._deflate.close();\n      this._deflate = null;\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        var value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw(\n        Object.assign({}, this._options.zlibInflateOptions, { windowBits })\n      );\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    if (!data || data.length === 0) {\n      process.nextTick(callback, null, EMPTY_BLOCK);\n      return;\n    }\n\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw(\n        Object.assign({}, this._options.zlibDeflateOptions, { windowBits })\n      );\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      //\n      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the\n      // `zlib.DeflateRaw` instance is closed while data is being processed.\n      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong\n      // time due to an abnormal WebSocket closure.\n      //\n      this._deflate.on('error', NOOP);\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // This `if` statement is only needed for Node.js < 10.0.0 because as of\n        // commit https://github.com/nodejs/node/commit/5e3f5164, the flush\n        // callback is no longer called if the deflate stream is closed while\n        // data is being processed.\n        //\n        return;\n      }\n\n      var data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.close();\n        this._deflate = null;\n      } else {\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n\n\n//# sourceURL=node_modules/ws/lib/permessage-deflate.js");

/***/ }),

/***/ "../node_modules/ws/lib/receiver.js":
/*!******************************************!*\
  !*** ../node_modules/ws/lib/receiver.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"../node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"../node_modules/ws/lib/validation.js\");\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends stream.Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {String} binaryType The type for binary data\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(binaryType, extensions, maxPayload) {\n    super();\n\n    this._binaryType = binaryType || BINARY_TYPES[0];\n    this[kWebSocket] = undefined;\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n\n      if (n >= buf.length) {\n        this._buffers.shift().copy(dst, dst.length - n);\n      } else {\n        buf.copy(dst, dst.length - n, 0, n);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    var err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002);\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002);\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002);\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009);\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    var data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n      if (this._masked) unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its lenght is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(RangeError, 'Max payload size exceeded', false, 1009)\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        var data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('message', buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, '');\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002);\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002);\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('conclude', code, buf.toString());\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {(Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err[kStatusCode] = statusCode;\n  return err;\n}\n\n\n//# sourceURL=node_modules/ws/lib/receiver.js");

/***/ }),

/***/ "../node_modules/ws/lib/sender.js":
/*!****************************************!*\
  !*** ../node_modules/ws/lib/sender.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { randomBytes } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"../node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"../node_modules/ws/lib/buffer-util.js\");\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    var offset = options.mask ? 6 : 2;\n    var payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    const mask = randomBytes(4);\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    var buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || data === '') {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose(data, mask, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x08,\n        mask,\n        readOnly: false\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x09,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x0a,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    var opcode = options.binary ? 2 : 1;\n    var rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(buf, {\n          fin: options.fin,\n          rsv1: false,\n          opcode,\n          mask: options.mask,\n          readOnly: toBuffer.readOnly\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      params[0].apply(this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n\n//# sourceURL=node_modules/ws/lib/sender.js");

/***/ }),

/***/ "../node_modules/ws/lib/validation.js":
/*!********************************************!*\
  !*** ../node_modules/ws/lib/validation.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\ntry {\n  const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"../node_modules/utf-8-validate/index.js\");\n\n  exports.isValidUTF8 =\n    typeof isValidUTF8 === 'object'\n      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\n      : isValidUTF8;\n} catch (e) /* istanbul ignore next */ {\n  exports.isValidUTF8 = () => true;\n}\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nexports.isValidStatusCode = (code) => {\n  return (\n    (code >= 1000 &&\n      code <= 1013 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n};\n\n\n//# sourceURL=node_modules/ws/lib/validation.js");

/***/ }),

/***/ "../node_modules/ws/lib/websocket-server.js":
/*!**************************************************!*\
  !*** ../node_modules/ws/lib/websocket-server.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst http = __webpack_require__(/*! http */ \"http\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\nconst extension = __webpack_require__(/*! ./extension */ \"../node_modules/ws/lib/extension.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"../node_modules/ws/lib/websocket.js\");\nconst { GUID } = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} options.backlog The maximum length of the queue of pending\n   *     connections\n   * @param {Boolean} options.clientTracking Specifies whether or not to track\n   *     clients\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {String} options.path Accept only connections matching this path\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n   *     permessage-deflate\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = Object.assign(\n      {\n        maxPayload: 100 * 1024 * 1024,\n        perMessageDeflate: false,\n        handleProtocols: null,\n        clientTracking: true,\n        verifyClient: null,\n        noServer: false,\n        backlog: null, // use default (511 as implemented in net.js)\n        server: null,\n        host: null,\n        path: null,\n        port: null\n      },\n      options\n    );\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError(\n        'One of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, (ws) => {\n            this.emit('connection', ws, req);\n          });\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(cb) {\n    if (cb) this.once('close', cb);\n\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) {\n        server.close(() => this.emit('close'));\n        return;\n      }\n    }\n\n    process.nextTick(emitClose, this);\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key =\n      req.headers['sec-websocket-key'] !== undefined\n        ? req.headers['sec-websocket-key'].trim()\n        : false;\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' ||\n      req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !key ||\n      !keyRegex.test(key) ||\n      (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(req.headers['sec-websocket-extensions']);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(key, extensions, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(key, extensions, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade(key, extensions, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    const digest = crypto\n      .createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new WebSocket(null);\n    var protocol = req.headers['sec-websocket-protocol'];\n\n    if (protocol) {\n      protocol = protocol.trim().split(/ *, */);\n\n      //\n      // Optionally call external protocol selection handler.\n      //\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n      } else {\n        protocol = protocol[0];\n      }\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws.protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, this.options.maxPayload);\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n    }\n\n    cb(ws);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server.emit('close');\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    headers = Object.assign(\n      {\n        Connection: 'close',\n        'Content-type': 'text/html',\n        'Content-Length': Buffer.byteLength(message)\n      },\n      headers\n    );\n\n    socket.write(\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n        Object.keys(headers)\n          .map((h) => `${h}: ${headers[h]}`)\n          .join('\\r\\n') +\n        '\\r\\n\\r\\n' +\n        message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n\n\n//# sourceURL=node_modules/ws/lib/websocket-server.js");

/***/ }),

/***/ "../node_modules/ws/lib/websocket.js":
/*!*******************************************!*\
  !*** ../node_modules/ws/lib/websocket.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst url = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../node_modules/ws/lib/permessage-deflate.js\");\nconst EventTarget = __webpack_require__(/*! ./event-target */ \"../node_modules/ws/lib/event-target.js\");\nconst extension = __webpack_require__(/*! ./extension */ \"../node_modules/ws/lib/extension.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"../node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"../node_modules/ws/lib/sender.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"../node_modules/ws/lib/constants.js\");\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|url.Url|url.URL)} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = '';\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._closeCode = 1006;\n    this._extensions = {};\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  get CONNECTING() {\n    return WebSocket.CONNECTING;\n  }\n  get CLOSING() {\n    return WebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return WebSocket.CLOSED;\n  }\n  get OPEN() {\n    return WebSocket.OPEN;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return 0;\n\n    //\n    // `socket.bufferSize` is `undefined` if the socket is closed.\n    //\n    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} maxPayload The maximum allowed message size\n   * @private\n   */\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(\n      this._binaryType,\n      this._extensions,\n      maxPayload\n    );\n\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    this.readyState = WebSocket.CLOSED;\n\n    if (!this._socket) {\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived) this._socket.end();\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(\n        `WebSocket is not open: readyState ${this.readyState} ` +\n          `(${readyStates[this.readyState]})`\n      );\n\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(\n        `WebSocket is not open: readyState ${this.readyState} ` +\n          `(${readyStates[this.readyState]})`\n      );\n\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      const err = new Error(\n        `WebSocket is not open: readyState ${this.readyState} ` +\n          `(${readyStates[this.readyState]})`\n      );\n\n      if (cb) return cb(err);\n      throw err;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    const opts = Object.assign(\n      {\n        binary: typeof data !== 'string',\n        mask: !this._isServer,\n        compress: true,\n        fin: true\n      },\n      options\n    );\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this.readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\nreadyStates.forEach((readyState, i) => {\n  WebSocket[readyState] = i;\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get() {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n\n      return undefined;\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set(listener) {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|url.Url|url.URL)} address The URL to which to connect\n * @param {String} protocols The subprotocols\n * @param {Object} options Connection options\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n *     permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the\n *     handshake request\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`\n *     header\n * @param {String} options.origin Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {Boolean} options.followRedirects Whether or not to follow redirects\n * @param {Number} options.maxRedirects The maximum number of redirects allowed\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = Object.assign(\n    {\n      protocolVersion: protocolVersions[1],\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: true,\n      followRedirects: false,\n      maxRedirects: 10\n    },\n    options,\n    {\n      createConnection: undefined,\n      socketPath: undefined,\n      hostname: undefined,\n      protocol: undefined,\n      timeout: undefined,\n      method: undefined,\n      auth: undefined,\n      host: undefined,\n      path: undefined,\n      port: undefined\n    }\n  );\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  var parsedUrl;\n\n  if (typeof address === 'object' && address.href !== undefined) {\n    parsedUrl = address;\n    websocket.url = address.href;\n  } else {\n    //\n    // The WHATWG URL constructor is not available on Node.js < 6.13.0\n    //\n    parsedUrl = url.URL ? new url.URL(address) : url.parse(address);\n    websocket.url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${websocket.url}`);\n  }\n\n  const isSecure =\n    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const defaultPort = isSecure ? 443 : 80;\n  const key = crypto.randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  const path = parsedUrl.search\n    ? `${parsedUrl.pathname || '/'}${parsedUrl.search}`\n    : parsedUrl.pathname || '/';\n  var perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = Object.assign(\n    {\n      'Sec-WebSocket-Version': opts.protocolVersion,\n      'Sec-WebSocket-Key': key,\n      Connection: 'Upgrade',\n      Upgrade: 'websocket'\n    },\n    opts.headers\n  );\n  opts.path = path;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = extension.format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols) {\n    opts.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.auth) {\n    opts.auth = parsedUrl.auth;\n  } else if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  var req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (websocket._req.aborted) return;\n\n    req = websocket._req = null;\n    websocket.readyState = WebSocket.CLOSING;\n    websocket.emit('error', err);\n    websocket.emitClose();\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      const addr = url.URL\n        ? new url.URL(location, address)\n        : url.resolve(address, location);\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = crypto\n      .createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    var protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && !protList.includes(serverProt)) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const extensions = extension.parse(\n          res.headers['sec-websocket-extensions']\n        );\n\n        if (extensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n          websocket._extensions[\n            PerMessageDeflate.extensionName\n          ] = perMessageDeflate;\n        }\n      } catch (err) {\n        abortHandshake(\n          websocket,\n          socket,\n          'Invalid Sec-WebSocket-Extensions header'\n        );\n        return;\n      }\n    }\n\n    websocket.setSocket(socket, head, opts.maxPayload);\n  });\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  //\n  // Override `options.path` only if `options` is a copy of the original options\n  // object. This is always true on Node.js >= 8 but not on Node.js 6 where\n  // `options.socketPath` might be `undefined` even if the `socketPath` option\n  // was originally set.\n  //\n  if (options.protocolVersion) options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n  options.servername = options.servername || options.host;\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\n *     socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket.readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n  websocket._socket.resume();\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._closeCode = err[kStatusCode];\n  websocket.emit('error', err);\n  websocket._socket.destroy();\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('end', socketOnEnd);\n\n  websocket.readyState = WebSocket.CLOSING;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk and emitted synchronously in a single\n  // `'data'` event.\n  //\n  websocket._socket.read();\n  websocket._receiver.end();\n\n  this.removeListener('data', socketOnData);\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  websocket.readyState = WebSocket.CLOSING;\n  this.destroy();\n}\n\n\n//# sourceURL=node_modules/ws/lib/websocket.js");

/***/ }),

/***/ "./connections/connection.js":
/*!***********************************!*\
  !*** ./connections/connection.js ***!
  \***********************************/
/*! exports provided: default, uint8ArrayToUint8ArrayLike, bufferToUint8ArrayLike, uint8ArrayLikeToBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Connection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uint8ArrayToUint8ArrayLike\", function() { return uint8ArrayToUint8ArrayLike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bufferToUint8ArrayLike\", function() { return bufferToUint8ArrayLike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uint8ArrayLikeToBuffer\", function() { return uint8ArrayLikeToBuffer; });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ws */ \"../node_modules/ws/index.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _passport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../passport */ \"./passport/index.js\");\n/* harmony import */ var _idGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../idGenerator */ \"./idGenerator.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_5__);\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/**\n * @module connections/connection\n */\n\n\n\n\n\n\nconst CLIENT_AUTHENTICATION_FACTORS = ['passport'];\nconst generateId = Object(_idGenerator__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n/**\n * @summary Connection is a {@link module:remote-controller-server-core~external:ws.WebSocket|ws.WebSocket} wrapper\n * @description\n * This class receives client's messages like this\n * <br> `'[string, *[]]'` <br>\n * and then emit an event with its name and body\n * ##### Elements\n *  | Name | Type | Attributes | Description |\n *  | --- | --- | --- | --- | --- |\n *  | `0` | `string` |   | Message's name |\n *  | `1` | `*[]` | <optional> | Message's body (Every element pass as parameter to event) |\n *\n *\n * ### Messages\n * ##### Sends\n * **authentication**:  `{@link module:connections/connection#event:authentication}`\n *\n * ##### Receives\n * **authenticate**:  `object`\n *\n * | Name  | Type  | Description |\n * | --- | --- | --- |\n * | `factor`  | `string`  |  Target factor\n * | `passportInput` | `string`  | If factor is passport |\n *\n * @mixes module:remote-controller-server-core~external:EventEmitter\n */\n\nclass Connection extends events__WEBPACK_IMPORTED_MODULE_1___default.a {\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {module:remote-controller-server-core~external:ws.WebSocket}\n   */\n\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {module:passport}\n   */\n\n  /**\n   * @type {{passport: boolean[], confirmation: boolean[]}}\n   */\n\n  /**\n   * Transfer events from {@link module:remote-controller-server-core~external:ws.WebSocket|ws.WebSocket}\n   *\n   * @param {object} configs\n   * @param {module:remote-controller-server-core~external:ws.WebSocket} configs.socket\n   * @param {object} [configs.authenticationFactors={}] Authentication factors\n   * @param {boolean} [configs.authenticationFactors.confirmation=true] Must Connection confirm before interact?\n   * @param {boolean} [configs.authenticationFactors.passport=false]\n   * @param {module:passport} [configs.passport] Required if configs.authenticationFactors.passport is set to true\n   *\n   * @emits module:connections/connection#event:authentication\n   */\n  constructor(configs) {\n    if (typeof configs !== 'object') throw new Error('configs parameter is required and must be object');else if (!(configs.socket instanceof ws__WEBPACK_IMPORTED_MODULE_2___default.a)) throw new Error('configs.socket is required and must be ws.WebSocket');else if (configs.authenticationFactors !== undefined && typeof configs.authenticationFactors !== 'object' || (configs.authenticationFactors && configs.authenticationFactors.confirmation) !== undefined && typeof configs.authenticationFactors.confirmation !== 'boolean' || (configs.authenticationFactors && configs.authenticationFactors.passport) !== undefined && typeof configs.authenticationFactors.passport !== 'boolean') throw new Error('configs.authenticationFactors must be object with boolean values');\n    super(); // Set default configs\n\n    _id.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _socket.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _address.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _passport.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _authenticationFactors.set(this, {\n      writable: true,\n      value: {\n        // [Requirement, Verification]\n        passport: [false\n        /* , false */\n        ],\n        // eslint-disable-line standard/array-bracket-even-spacing\n        confirmation: [true\n        /* , false */\n        ] // eslint-disable-line standard/array-bracket-even-spacing\n\n        /**\n         * @emits module:connections/connection#event:authentication\n         */\n\n      }\n    });\n\n    _fireAuthenticatedEvent.set(this, {\n      writable: true,\n      value: (() => {\n        let isAuthenticateCache;\n        return () => {\n          const EVENT_PROPS = ['authentication', {\n            status: this.isAuthenticate ? 1 : 2\n          }]; // Prevent emit authentication status if:\n\n          if (isAuthenticateCache === this.isAuthenticate || // Authentication status has no change\n          _classPrivateFieldGet(this, _authenticationFactors).confirmation[0] && // Only one factor passed when two factor needed\n          _classPrivateFieldGet(this, _authenticationFactors).confirmation[1] === undefined && _classPrivateFieldGet(this, _authenticationFactors).passport[0]) return;\n          isAuthenticateCache = this.isAuthenticate;\n          this.emit(...EVENT_PROPS);\n          this.send(...EVENT_PROPS);\n        };\n      })()\n    });\n\n    _passportChecker.set(this, {\n      writable: true,\n      value: passportInput => {\n        try {\n          _classPrivateFieldGet(this, _authenticationFactors).passport[1] = _classPrivateFieldGet(this, _passport).isEqual(passportInput);\n        } catch (error) {\n          _classPrivateFieldGet(this, _authenticationFactors).passport[1] = false;\n        }\n\n        const EVENT_PROPS = ['authentication', {\n          factor: 'passport',\n          status: _classPrivateFieldGet(this, _authenticationFactors).passport[1] ? 1 : 2\n        }];\n        this.emit(...EVENT_PROPS);\n        this.send(...EVENT_PROPS);\n\n        _classPrivateFieldGet(this, _fireAuthenticatedEvent).call(this);\n      }\n    });\n\n    configs = Object.assign({\n      authenticationFactors: {}\n    }, configs); // Set default authentication factors\n\n    configs.authenticationFactors = Object.assign({\n      confirmation: true,\n      passport: false\n    }, configs.authenticationFactors);\n    let withoutAuthFactor = true;\n\n    for (let factor in configs.authenticationFactors) {\n      if (!_classPrivateFieldGet(this, _authenticationFactors)[factor] || !configs.authenticationFactors[factor]) continue;\n      withoutAuthFactor = false;\n      break;\n    }\n\n    if (withoutAuthFactor) throw new Error('One authentication factor require at least');\n\n    if (configs.authenticationFactors.passport === true && !(configs.passport instanceof _passport__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) {\n      throw new Error('configs.passport is required and must be Passport');\n    }\n\n    _classPrivateFieldSet(this, _id, generateId());\n\n    _classPrivateFieldSet(this, _socket, configs.socket);\n\n    _classPrivateFieldSet(this, _address, _classPrivateFieldGet(this, _socket).request.socket.remoteAddress);\n\n    for (let factor in _classPrivateFieldGet(this, _authenticationFactors)) {\n      _classPrivateFieldGet(this, _authenticationFactors)[factor][0] = configs.authenticationFactors[factor];\n    }\n\n    if (configs.authenticationFactors.passport) _classPrivateFieldSet(this, _passport, configs.passport); // Transform Socket events to Connection\n\n    _classPrivateFieldGet(this, _socket).emit = (eventName, ...args) => {\n      const chain = events__WEBPACK_IMPORTED_MODULE_1___default.a.prototype.emit.call(_classPrivateFieldGet(this, _socket), eventName, ...args);\n      const necessaryEvents = ['message', 'disconnected', 'error']; // Change events name\n\n      if (eventName === 'close') eventName = 'disconnected';\n      if (!necessaryEvents.includes(eventName)) return chain;\n      if (eventName !== 'message') this.emit(eventName, ...args);else {\n        let message = args[0];\n        let name;\n        let body;\n        necessaryEvents.splice(necessaryEvents.indexOf(eventName), 1);\n\n        try {\n          message = JSON.parse(message);\n        } catch (error) {}\n\n        if (message instanceof Array && typeof message[0] === 'string') {\n          name = message[0];\n          if (message[1] instanceof Array) body = message[1];\n        }\n\n        if (body instanceof Array) {\n          for (let dataIndex in body) {\n            const data = body[dataIndex];\n\n            if (data instanceof Array && data[0] === 'Uint8Array' && data[1] instanceof Array) {\n              body[dataIndex] = uint8ArrayLikeToBuffer(data);\n            }\n          }\n        }\n\n        if (!(body instanceof Array)) body = [];\n        if (name && (name === 'authenticate' || this.isAuthenticate) && !necessaryEvents.includes(name)) this.emit(name, ...body);\n      }\n      return chain;\n    };\n\n    setImmediate(() => {\n      for (let factor in _classPrivateFieldGet(this, _authenticationFactors)) {\n        if (!_classPrivateFieldGet(this, _authenticationFactors)[factor][0]) continue;\n        const EVENT_PROPS = ['authentication', {\n          factor,\n          status: 0\n        }];\n        if (factor === 'passport') EVENT_PROPS[1].type = _classPrivateFieldGet(this, _passport).type;\n        this.emit(...EVENT_PROPS);\n        this.send(...EVENT_PROPS);\n        break;\n      }\n\n      this.on('authentication', event => setImmediate(() => {\n        if (event.factor === 'passport') {\n          if (!this.isAuthenticate && _classPrivateFieldGet(this, _authenticationFactors).confirmation[0] && event.status === 1) {\n            const EVENT_PROPS = ['authentication', {\n              factor: 'confirmation',\n              status: 0\n            }];\n            this.emit(...EVENT_PROPS);\n            this.send(...EVENT_PROPS);\n          }\n        }\n      }));\n      this.on('authenticate', event => {\n        if (!_classPrivateFieldGet(this, _authenticationFactors)[event.factor] || !_classPrivateFieldGet(this, _authenticationFactors)[event.factor][0] || _classPrivateFieldGet(this, _authenticationFactors)[event.factor][1] || !CLIENT_AUTHENTICATION_FACTORS.includes(event.factor)) return;\n        if (event.factor === 'passport') _classPrivateFieldGet(this, _passportChecker).call(this, event.passportInput);\n      });\n    });\n  }\n  /**\n   * @summary Send message to client\n   * @description\n   * If every element of body is instanceof Buffer <br>\n   * convert to Uint8Array then convert to pure array <br>\n   * then send as {@link module:connections/connection~Uint8ArrayLike|Uint8ArrayLike} . <br>\n   * This method create an array and push name and body to it like this <br>\n   * `[name, [...body]]` <br>\n   * and then serialize it to string and send to client\n   *\n   * @param {string} name Message's name\n   * @param {...*} [body] Message's content\n   * @param {function} [callback] This function listens to event with the same name just once\n   *\n   * @async\n   * @return {Promise<(void|Error)>}\n   * * Rejection\n   *  * Reject an error if Connection is not authenticated\n   */\n\n\n  send(name, ...body) {\n    if (typeof name !== 'string') throw new Error('name parameter is required and must be string');\n    return (async () => {\n      if (name !== 'authentication' && !this.isAuthenticate) throw new Error('Connection is not authenticated');\n      let message = [name, body];\n      let callback;\n      if (typeof body[body.length - 1] === 'function') callback = body.splice(body.length - 1, 1)[0];\n\n      for (let dataIndex in body) {\n        const data = body[dataIndex];\n        if (data instanceof Buffer) body[dataIndex] = bufferToUint8ArrayLike(data);else if (data instanceof Uint8Array) body[dataIndex] = uint8ArrayToUint8ArrayLike(data);\n      }\n\n      message = JSON.stringify(message);\n      return new Promise(resolve => _classPrivateFieldGet(this, _socket).send(message, undefined, resolve)).then(() => {\n        if (typeof callback === 'function') this.once(name, callback);\n      });\n    })();\n  }\n  /**\n   * Disconnect Connection\n   *\n   * @emits module:connections/connection#event:disconnected\n   *\n   * @return {void}\n   */\n\n\n  disconnect() {\n    /**\n     * @summary Connection disconnected event\n     * @description\n     * Same as {@link module:remote-controller-server-core~external:ws.WebSocket|ws.WebSocket} close event\n     *\n     * @event module:connections/connection#event:disconnected\n     *\n     * @see module:remote-controller-server-core~external:ws.WebSocket\n     */\n    if (this.status !== 'closed' || this.status !== 'closing') _classPrivateFieldGet(this, _socket).close();\n  }\n  /**\n   * Mark this Connection as confirmed\n   *\n   * @param {boolean} [confirmation=true]\n   *\n   * @emits module:connections/connection#event:authentication\n   *\n   * @return {void}\n   */\n\n\n  confirm(confirmation = true) {\n    confirmation = Boolean(confirmation);\n    if (_classPrivateFieldGet(this, _authenticationFactors).confirmation[1] === confirmation) return;\n    _classPrivateFieldGet(this, _authenticationFactors).confirmation[1] = confirmation;\n    const EVENT_PROPS = ['authentication', {\n      factor: 'confirmation',\n      status: _classPrivateFieldGet(this, _authenticationFactors).confirmation[1] ? 1 : 2\n    }];\n    this.emit(...EVENT_PROPS);\n    this.send(...EVENT_PROPS);\n\n    _classPrivateFieldGet(this, _fireAuthenticatedEvent).call(this);\n  }\n  /**\n   * Get Connection authentication status\n   *\n   * @type {boolean}\n   */\n\n\n  get isAuthenticate() {\n    let authenticated = false;\n\n    for (let factor in _classPrivateFieldGet(this, _authenticationFactors)) {\n      if (_classPrivateFieldGet(this, _authenticationFactors)[factor][0]) {\n        authenticated = _classPrivateFieldGet(this, _authenticationFactors)[factor][1];\n        if (!authenticated) break;\n      }\n    }\n\n    return !!authenticated;\n  }\n  /**\n   * Get Client IP\n   *\n   * @type {string}\n   */\n\n\n  get address() {\n    return _classPrivateFieldGet(this, _address);\n  }\n  /**\n   * @type {boolean}\n   */\n\n\n  get isConnected() {\n    return _classPrivateFieldGet(this, _socket).readyState === ws__WEBPACK_IMPORTED_MODULE_2___default.a.OPEN;\n  }\n  /**\n   * Connection id\n   *\n   * @return {number}\n   */\n\n\n  get id() {\n    return _classPrivateFieldGet(this, _id);\n  }\n  /**\n   * Set preferred options for nodejs fs.createReadStream method\n   *\n   * * Read 1.0625 megabyte per chunk\n   *\n   * @param {object} [options={}]\n   * @param {boolean} [overwrite=true] Write to the same object or create a new one\n   *\n   * @returns {Object}\n   */\n\n\n  static setReadStreamDefaults(options, overwrite = true) {\n    if (typeof options !== 'object') options = {};\n    let result; // Byte Per Chunk\n\n    const BPC = 1062500;\n    const DEFAULTS = {\n      end: BPC,\n      highWaterMark: BPC + 1,\n      multiChunks: true\n    };\n    const optionsCache = Object.assign(Object.create(null), options);\n\n    if (typeof optionsCache.end !== 'number') {\n      DEFAULTS.end = (typeof optionsCache.start === 'number' ? optionsCache.start : 0) + BPC;\n    }\n\n    if (typeof optionsCache.highWaterMark === 'number') optionsCache.highWaterMark++;\n    result = Object.assign(overwrite ? options : {}, DEFAULTS, optionsCache);\n\n    if (result.end - result.start < result.highWaterMark) {\n      result.highWaterMark = result.end - result.start;\n    }\n\n    return result;\n  }\n  /**\n   * A helper to read readable stream chunks\n   *\n   * @param {module:remote-controller-server-core~external:readableStream} readableStream\n   * @param {boolean} [multiChunk=true]\n   *\n   * @returns {module:connections/connection~streamChunksReader}\n   *\n   * @example\n   * let streamOptions = {@link module:connections/connection.setReadStreamDefaults|Connection.setReadStreamDefaults}({ end: 1062500 * 5 })\n   * let readableStream = fs.createReadStream('Big.File', streamOptions)\n   * ;(async function () {\n   *    for await (const someChunks of {@link module:connections/connection.readStreamChunks|Connection.readStreamChunks}(readableStream, false)()) {\n   *      await {@link module:connections/connection#send|connection.send}('bigFile', streamOptions, ...someChunks)\n   *    }\n   *  })()\n   */\n\n\n  static readStreamChunks(readableStream, multiChunk = true) {\n    if (!(readableStream instanceof stream__WEBPACK_IMPORTED_MODULE_5___default.a.Readable)) {\n      throw new Error('readableStream parameter is required and must be readableStream');\n    }\n    /**\n     * Resolve an array of chunks. <br>\n     * * `{@link module:connections/connection.readStreamChunks|readStreamChunks}(multiChunk = true)`:\n     * Resolve an array that contains **all** the chunks.\n     * * `{@link module:connections/connection.readStreamChunks|readStreamChunks}(multiChunk = false)`:\n     * Resolve an array that contains **one** chunk in every iteration.\n     *\n     * @name module:connections/connection~streamChunksReader\n     * @generator\n     *\n     * @returns {AsyncIterableIterator<Buffer[]>}\n     */\n\n\n    async function* streamChunksReader() {\n      const CHUNKS = [];\n\n      while (!readableStream.closed) {\n        // EventEmitter's events are not error first, so it reject the promise\n        try {\n          readableStream.resume();\n          await Promise.race([Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(readableStream.once.bind(readableStream))('data'), Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(readableStream.once.bind(readableStream))('close')]);\n        } catch (chunk) {\n          readableStream.pause();\n          if (multiChunk) CHUNKS.push(chunk);else yield [chunk];\n        }\n      }\n\n      if (multiChunk) yield CHUNKS;\n    }\n\n    return streamChunksReader;\n  }\n\n}\n/**\n * Convert uint8Array to pure array then uint8ArrayLike\n *\n * @param {Uint8Array} uint8Array\n *\n * @returns {module:connections/connection~Uint8ArrayLike}\n */\n\nvar _id = new WeakMap();\n\nvar _socket = new WeakMap();\n\nvar _address = new WeakMap();\n\nvar _passport = new WeakMap();\n\nvar _authenticationFactors = new WeakMap();\n\nvar _fireAuthenticatedEvent = new WeakMap();\n\nvar _passportChecker = new WeakMap();\n\nfunction uint8ArrayToUint8ArrayLike(uint8Array) {\n  return ['Uint8Array', Array.from(uint8Array)];\n}\n/**\n * Convert buffer to uint8Array then uint8ArrayLike\n *\n * @param {Buffer} buffer\n *\n * @returns {module:connections/connection~Uint8ArrayLike}\n */\n\nfunction bufferToUint8ArrayLike(buffer) {\n  const arrayBuffer = new ArrayBuffer(buffer.length);\n  const uint8Array = new Uint8Array(arrayBuffer);\n\n  for (let index = 0; index < buffer.length; index++) {\n    uint8Array[index] = buffer[index];\n  }\n\n  return uint8ArrayToUint8ArrayLike(uint8Array);\n}\n/**\n * Convert uint8ArrayLike to buffer\n *\n * @param {module:connections/connection~Uint8ArrayLike} uint8ArrayLike\n *\n * @returns {Buffer}\n */\n\nfunction uint8ArrayLikeToBuffer(uint8ArrayLike) {\n  return Buffer.from(Uint8Array.from(uint8ArrayLike[1]));\n}\n/**\n * Binary style use for send and receive <br>\n * `[\"Uint8Array\", arrayFromUint8Array]`\n *\n * @typedef {array} module:connections/connection~Uint8ArrayLike\n * @property {string} 0 This element always is Uint8Array\n * @property {Array} 1 An array that contains uint8Array's data\n */\n\n/**\n * Connection authentication status\n *\n * @event module:connections/connection#event:authentication\n *\n * @type {object}\n * @property {string} factor Authentication factor's name that it's state changed\n * @property {number} status\n * Authentication (factor) status\n *\n * | Value | Description |\n * | --- | --- |\n * | `0` | Ask for authentication factor |\n * | `1` | Allowed |\n * | `2` | Denied |\n *\n * @property {string} type\n * Depend on factor\n *\n * |  Factor  | Description |\n * | --- | --- |\n * |  `passport`  | Type of passport |\n */\n\n//# sourceURL=src/connections/connection.js");

/***/ }),

/***/ "./engine/index.js":
/*!*************************!*\
  !*** ./engine/index.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makeEngine; });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ws */ \"../node_modules/ws/index.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _connections_connection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../connections/connection */ \"./connections/connection.js\");\n/* harmony import */ var _passport__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../passport */ \"./passport/index.js\");\n/**\n * @module engine\n */\n\n\n\n\n\n\n\n/**\n * makeEngine creates engine module\n *\n * @param {object} [configs={}]\n * @param {number} [configs.port=7777] Server's port\n * @param {string} [configs.path=\"/\"] WebSocket's path\n *\n * @return {module:engine~Engine}\n */\n\nfunction makeEngine(configs = Object.create(null)) {\n  if (typeof configs !== 'object') throw new Error('configs parameter must be object'); // Set default configs\n\n  configs = Object.assign({\n    port: 7777,\n    path: '/'\n  }, configs);\n  if (typeof configs.port !== 'number') throw new Error('configs.port must be number');else if (typeof configs.path !== 'string' || !configs.path.startsWith('/')) throw new Error('configs.path must be string and starts with \"/\"');\n  const httpServer = http__WEBPACK_IMPORTED_MODULE_3___default.a.createServer();\n  const webSocketServer = new ws__WEBPACK_IMPORTED_MODULE_4___default.a.Server({\n    server: httpServer,\n    path: configs.path,\n    perMessageDeflate: true\n  });\n  /**\n   * Engine module control web server and it's websocket\n   *\n   * @mixes module:remote-controller-server-core~external:EventEmitter\n   */\n\n  class Engine extends events__WEBPACK_IMPORTED_MODULE_1___default.a {\n    constructor() {\n      super();\n\n      if (true) {\n        webSocketServer.on('connection', (socket, request) => {\n          socket.request = request;\n          const connection = new _connections_connection__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n            socket,\n            authenticationFactors: {\n              passport: true\n            },\n            passport: new _passport__WEBPACK_IMPORTED_MODULE_6__[\"default\"]('password', 'aB_54321')\n          });\n          this.connection = connection;\n          console.log(connection.id, 'Connected', connection.address);\n          connection.on('disconnected', () => {\n            console.log(connection.id, 'Disconnected', connection.address);\n          });\n          connection.on('authentication', event => {\n            switch (event.factor) {\n              case undefined:\n                console.log(connection.id, event.status === 1 ? 'Connection authenticated' : 'Connection unauthenticated');\n                break;\n\n              case 'confirmation':\n                console.log(connection.id, ['Connection ask for confirmation', 'Connection confirmation allowed', 'Connection confirmation denied'][event.status]);\n                break;\n\n              case 'passport':\n                console.log(connection.id, ['Connection ask for passport', 'Connection passport allowed', 'Connection passport denied'][event.status]);\n                break;\n            }\n          });\n        });\n      }\n    }\n    /**\n     * Start engine\n     *\n     * @param {number} [port=module:engine~configs.port]\n     *\n     * @emits module:engine~Engine#event:started\n     *\n     * @async\n     * @returns {Promise<(void|Error)>}\n     * * Rejection\n     *  * Reject an error if engine started before\n     *  * Reject an error if there is no network\n     */\n\n\n    start(port = configs.port) {\n      if (typeof port !== 'number') throw new Error('port parameter must be number');\n      return (async () => {\n        if (this.isActive) throw new Error('Engine already started');else if (getNetworkIP() === null) throw new Error('Network is not available');\n        configs.port = port;\n        /**\n         * Engine started event\n         *\n         * @event module:engine~Engine#event:started\n         */\n\n        const fireEvent = () => {\n          this.emit('started');\n        };\n\n        await Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(httpServer.listen.bind(httpServer))({\n          port,\n          host: '0.0.0.0'\n        });\n        fireEvent();\n      })();\n    }\n    /**\n     * Stop engine\n     *\n     * @emits module:engine~Engine#event:stopped\n     *\n     * @returns {Promise<(void|Error)>}\n     * * Rejection\n     *  * Reject an error if engine stopped before\n     */\n\n\n    async stop() {\n      if (!this.isActive) throw new Error('Engine already stopped');\n      /**\n       * Engine stopped event\n       *\n       * @event module:engine~Engine#event:stopped\n       */\n\n      const fireEvent = () => {\n        this.emit('stopped');\n      };\n\n      for (const webSocket of webSocketServer.clients) {\n        webSocket.close();\n      }\n\n      await Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(httpServer.close.bind(httpServer))();\n      fireEvent();\n    }\n    /**\n     * Get server address\n     *\n     * @example\n     * { address: '192.168.1.2', family: 'IPv4', port: 7777, path: '/'}\n     *\n     * @type {{address: (string|null), family: string, port: number}}\n     *\n     * @see {@link https://github.com/websockets/ws/blob/master/doc/ws.md#serveraddress|WebSocket.Server#address method}\n     */\n\n\n    get address() {\n      const ADDRESS = webSocketServer.address() || {};\n      const ADDRESS_CACHE = Object.assign(Object.create(null), ADDRESS);\n      Object.assign(ADDRESS, {\n        family: 'IPv4',\n        port: configs.port,\n        path: configs.path\n      }, ADDRESS_CACHE, {\n        address: getNetworkIP()\n      });\n      return ADDRESS;\n    }\n    /**\n     * Get server listening status\n     *\n     * @type {boolean}\n     */\n\n\n    get isActive() {\n      return httpServer.listening;\n    }\n\n  }\n\n  return new Engine();\n} // Get Network IP\n\nfunction getNetworkIP() {\n  const networkInterfaces = os__WEBPACK_IMPORTED_MODULE_2___default.a.networkInterfaces();\n  let ip = null;\n\n  for (let interfaceName of Object.keys(networkInterfaces)) {\n    if (typeof ip === 'string') break;\n\n    for (let iface of networkInterfaces[interfaceName]) {\n      if (typeof ip === 'string') break;\n      if (!iface.internal && iface.family === 'IPv4') ip = iface.address;\n    }\n  }\n\n  return ip;\n}\n\n//# sourceURL=src/engine/index.js");

/***/ }),

/***/ "./idGenerator.js":
/*!************************!*\
  !*** ./idGenerator.js ***!
  \************************/
/*! exports provided: keyCodesList, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyCodesList\", function() { return keyCodesList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return idGenerator; });\n/**\n * @module idGenerator\n */\n\n/**\n * ID character's range [0 to 9 then a to z]\n *\n * @type {number[][]}\n */\nconst keyCodesList = [[48, 57], [65, 90]];\n/**\n * Make new id generator\n *\n * @param {number[][]} [charCodesList] Min and max key code as every element (sort by size)\n * @param {string} [lastId]\n *\n * @returns {function(): string}\n */\n\nfunction idGenerator(charCodesList = keyCodesList, lastId) {\n  const firstId = codeToChar(charCodesList[0][0]);\n  const nextCode = nextCharCode.bind(null, charCodesList, charToCode(firstId));\n  /**\n   * Make a new unique id\n   *\n   * @returns {string}\n   */\n\n  return function () {\n    if (lastId === undefined) lastId = firstId;else {\n      let newId = lastId.split('');\n\n      for (let charIndex in newId) {\n        charIndex = Number(charIndex);\n\n        if (charToCode(newId[charIndex]) === charCodesList[charCodesList.length - 1][1]) {\n          newId[charIndex] = firstId;\n\n          if (newId[charIndex + 1] === undefined) {\n            newId.push(firstId);\n            break;\n          }\n        } else {\n          let charCode = nextCode(charToCode(newId[charIndex]));\n          newId[charIndex] = codeToChar(charCode);\n          break;\n        }\n      }\n\n      lastId = newId.join('');\n    }\n    return lastId;\n  };\n}\n/**\n * @param {number[][]} charCodesList\n * @param {number} charCode\n *\n * @throws Will throw an error if id is not in range of charCodesList parameter\n *\n * @returns {number}\n */\n\nfunction rangeOf(charCodesList, charCode) {\n  if (typeof charCode !== 'number') throw new Error('charCode parameter is required and mus be number');\n\n  for (const rangeIndex in charCodesList) {\n    if (charCode > charCodesList[rangeIndex][0] - 1 && charCode < charCodesList[rangeIndex][1] + 1) return Number(rangeIndex);\n  }\n\n  throw new Error('ID is not in range of charCodesList parameter');\n}\n/**\n * @param {number[][]} charCodesList\n * @param {number} firstId\n * @param {number} charCode\n *\n * @returns {number}\n */\n\n\nfunction nextCharCode(charCodesList, firstId, charCode) {\n  let rangeIndex = rangeOf(charCodesList, charCode);\n\n  if (charCode >= charCodesList[rangeIndex][1]) {\n    if (rangeIndex === charCodesList.length - 1) charCode = firstId;else charCode = charCodesList[rangeIndex + 1][0];\n  } else charCode++;\n\n  return charCode;\n}\n/**\n * @param {number} charCode\n *\n * @returns {string}\n */\n\n\nfunction codeToChar(charCode) {\n  return String.fromCharCode(charCode).toUpperCase();\n}\n/**\n * @param {string} char\n *\n * @returns {number}\n */\n\n\nfunction charToCode(char) {\n  return char.toUpperCase().charCodeAt(0);\n}\n\n//# sourceURL=src/idGenerator.js");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! exports provided: default, storages, preferences, engine, passport, idGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makeCore; });\n/* harmony import */ var _storages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storages */ \"./storages/index.js\");\n/* harmony import */ var _preferences__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./preferences */ \"./preferences/index.js\");\n/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./engine */ \"./engine/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"storages\", function() { return _storages__WEBPACK_IMPORTED_MODULE_0__; });\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"preferences\", function() { return _preferences__WEBPACK_IMPORTED_MODULE_1__; });\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"engine\", function() { return _engine__WEBPACK_IMPORTED_MODULE_2__; });\n/* harmony import */ var _passport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./passport */ \"./passport/index.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"passport\", function() { return _passport__WEBPACK_IMPORTED_MODULE_3__; });\n/* harmony import */ var _idGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./idGenerator */ \"./idGenerator.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"idGenerator\", function() { return _idGenerator__WEBPACK_IMPORTED_MODULE_4__; });\n/**\n * @module remote-controller-server-core\n */\n\n/**\n * Nodejs EventEmitter class\n *\n * @external module:remote-controller-server-core~external:EventEmitter\n *\n * @see {@link https://nodejs.org/docs/latest-v10.x/api/events.html#events_class_eventemitter|EventEmitter}\n */\n\n/**\n * Nodejs readableStream class\n *\n * @external module:remote-controller-server-core~external:readableStream\n *\n * @see {@link https://nodejs.org/api/stream.html#stream_readable_streams|Readable Streams}\n */\n\n/**\n * ws module\n *\n * @external module:remote-controller-server-core~external:ws\n *\n * @see {@link https://github.com/websockets/ws/blob/master/README.md|ws Github page}\n */\n\n/**\n * ws WebSocket class\n *\n * @name WebSocket\n * @memberOf module:remote-controller-server-core~external:ws\n * @static\n *\n * @see {@link https://github.com/websockets/ws/blob/master/doc/ws.md#class-websocket|Class: WebSocket}\n */\n\n/**\n * ws WebSocket.Server class\n *\n * @name Server\n * @memberOf module:remote-controller-server-core~external:ws.WebSocket\n * @static\n *\n * @see {@link https://github.com/websockets/ws/blob/master/doc/ws.md#class-websocketserver|Class: WebSocket.Server}\n */\n\n\n\nconst storagesList = Object.create(null);\n/**\n * makeCore creates core namespace\n *\n * @param {object} [configs={}]\n * @param {string} [configs.storagePath=process.cwd()] Storages path address\n * @param {string} [configs.preferenceStorageName='preferences']\n *\n * @return {module:remote-controller-server-core~core}\n */\n\nfunction makeCore(configs = Object.create(null)) {\n  if (typeof configs !== 'object') throw new Error('configs parameter must be object'); // Set default configs\n\n  configs = Object.assign({\n    storagePath: process.cwd(),\n    preferenceStorageName: 'preferences'\n  }, configs);\n  if (typeof configs.storagePath !== 'string') throw new Error('configs.storagePath must be string');else if (typeof configs.preferenceStorageName !== 'string') throw new Error('configs.preferencesStorageName must be string');\n  /**\n   * @namespace module:remote-controller-server-core~core\n   */\n\n  const core = Object.create(null);\n\n  if (storagesList[configs.storagePath] === undefined) {\n    storagesList[configs.storagePath] = _storages__WEBPACK_IMPORTED_MODULE_0__[\"default\"].call(core, {\n      path: configs.storagePath\n    });\n  }\n  /**\n   * Storage manager module\n   *\n   * @name storages\n   * @memberOf module:remote-controller-server-core~core\n   *\n   * @type {module:storages~Storages}\n   */\n\n\n  core.storages = storagesList[configs.storagePath];\n  /**\n   * Preference manager module\n   *\n   * @name preferences\n   * @memberOf module:remote-controller-server-core~core\n   *\n   * @type {module:preferences~Preferences}\n   */\n\n  core.preferences = _preferences__WEBPACK_IMPORTED_MODULE_1__[\"default\"].call(core, {\n    name: configs.preferenceStorageName\n  });\n  /**\n   * Core engine\n   *\n   * @name engine\n   * @memberOf module:remote-controller-server-core~core\n   *\n   * @type {module:engine~Engine}\n   */\n\n  core.engine = _engine__WEBPACK_IMPORTED_MODULE_2__[\"default\"].call(core);\n  return Object.freeze(core);\n}\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=src/main.js");

/***/ }),

/***/ "./passport/encryption.js":
/*!********************************!*\
  !*** ./passport/encryption.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @module passport/encryption\n */\n\n/**\n * encryption is a password encryptor\n *\n * @param {string} password password must have at least two character\n * @param {(string|Buffer|TypedArray|DataView)} [salt=crypto.randomBytes(32)]\n *\n * @return {{salt: Buffer, hash: Buffer}}\n */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ((password, salt) => {\n  if (typeof password !== 'string' || password.length < 2) {\n    throw new Error('password parameter is required and must be string with at least two character');\n  }\n\n  const result = Object.create(null);\n  result.salt = salt !== undefined ? salt : crypto__WEBPACK_IMPORTED_MODULE_0___default.a.randomBytes(32);\n  result.hash = crypto__WEBPACK_IMPORTED_MODULE_0___default.a.scryptSync(password, result.salt, result.salt.length * password.length);\n  return result;\n});\n\n//# sourceURL=src/passport/encryption.js");

/***/ }),

/***/ "./passport/index.js":
/*!***************************!*\
  !*** ./passport/index.js ***!
  \***************************/
/*! exports provided: default, passwordPattern */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Passport; });\n/* harmony import */ var _password__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./password */ \"./passport/password.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"passwordPattern\", function() { return _password__WEBPACK_IMPORTED_MODULE_0__[\"pattern\"]; });\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\n/**\n * @module passport\n */\nconst GLOBAL_ERRORS = {\n  passportInputRequired: new Error('passportInput parameter is required')\n};\nconst passports = {\n  password: __webpack_require__(/*! ./password */ \"./passport/password.js\").default\n};\nclass Passport {\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {Buffer}\n   */\n\n  /**\n   * @type {Buffer}\n   */\n\n  /**\n   * passport holder and manager\n   *\n   * @param {string} type\n   * @param {*} passportInput Depend on passport's type\n   * @param {{salt: Buffer, hash: Buffer}} [passport]\n   */\n  constructor(type, passportInput, passport) {\n    _type.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _hash.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _salt.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    if (typeof type !== 'string' || !passports.hasOwnProperty(type)) {\n      throw new Error('type parameter is required and must be string and one of passport types');\n    } else if (passportInput === undefined) throw GLOBAL_ERRORS.passportInputRequired;else if (passportInput === null && (typeof passport !== 'object' || !(passport.hash instanceof Buffer) || !(passport.hash instanceof Buffer))) {\n      throw new Error('passport parameter must be an encryption object');\n    }\n\n    _classPrivateFieldSet(this, _type, type);\n\n    if (passportInput !== null) passport = passports[_classPrivateFieldGet(this, _type)](passportInput);\n\n    _classPrivateFieldSet(this, _hash, passport.hash);\n\n    _classPrivateFieldSet(this, _salt, passport.salt);\n  }\n  /**\n   * Check passport equality\n   *\n   * @param {*} passportInput This parameter can be a encryption object or passport[type] input\n   *\n   * @return {boolean}\n   */\n\n\n  isEqual(passportInput) {\n    if (passportInput === undefined || passportInput === null) throw GLOBAL_ERRORS.passportInputRequired;\n    const passport = passportInput.hash instanceof Buffer ? passportInput : passports[this.type](passportInput, this.salt);\n    return this.hash.equals(passport.hash);\n  }\n  /**\n   * Create instance from hash\n   *\n   * @param {string} type\n   * @param {{salt: (Buffer|Buffer#toJSON), hash: (Buffer|Buffer#toJSON)}} passport\n   */\n\n\n  static from(type, passport) {\n    if (typeof passport === 'object') {\n      if (typeof passport.salt === 'object' && !(passport.salt instanceof Buffer)) {\n        passport.salt = Buffer.from(passport.salt);\n      }\n\n      if (typeof passport.hash === 'object' && !(passport.hash instanceof Buffer)) {\n        passport.hash = Buffer.from(passport.hash);\n      }\n    }\n\n    return new Passport(type, null, passport);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get type() {\n    return _classPrivateFieldGet(this, _type);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get hash() {\n    return _classPrivateFieldGet(this, _hash);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get salt() {\n    return _classPrivateFieldGet(this, _salt);\n  }\n\n}\n\nvar _type = new WeakMap();\n\nvar _hash = new WeakMap();\n\nvar _salt = new WeakMap();\n\n\n\n//# sourceURL=src/passport/index.js");

/***/ }),

/***/ "./passport/password.js":
/*!******************************!*\
  !*** ./passport/password.js ***!
  \******************************/
/*! exports provided: pattern, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pattern\", function() { return pattern; });\n/* harmony import */ var _encryption__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encryption */ \"./passport/encryption.js\");\n/**\n * @module passport/password\n */\n\nconst pattern = /(?=^.{8,}$)((?=.*\\d)|(?=.*\\W+))(?![.\\n])(?=.*[A-Z])(?=.*[a-z]).*$/;\n/**\n * * Minimum eight characters\n * * At least one uppercase letter\n * * At least one lowercase letter\n * * At least one number\n * * At least one special character\n *\n * @param {string} password\n * @param [salt] same as encryption salt parameter\n *\n * @throws Will throw an error if the password doesn't math with pattern\n *\n * @return {{salt: Buffer, hash: Buffer}}\n */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ((password, salt) => {\n  if (!pattern.test(password)) throw new Error('password is not secure');\n  return Object(_encryption__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(password, salt);\n});\n\n//# sourceURL=src/passport/password.js");

/***/ }),

/***/ "./preferences/index.js":
/*!******************************!*\
  !*** ./preferences/index.js ***!
  \******************************/
/*! exports provided: default, Preference */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makePreferences; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _preference__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./preference */ \"./preferences/preference.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Preference\", function() { return _preference__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/**\n * @module preferences\n */\n\n\n/**\n * makePreferences creates preferences module\n *\n * @param {object} configs\n * @param {string} [configs.name='preferences'] Preferences's Storage name\n *\n * @throws Will throw an error if Preferences file is already in use\n *\n * @return {module:preferences~Preferences}\n */\n\nfunction makePreferences(configs) {\n  if (typeof configs !== 'object') throw new Error('configs parameter is required and must be object'); // Set default configs\n\n  configs = Object.assign({\n    name: 'preferences'\n  }, configs);\n  if (typeof configs.name !== 'string') throw new Error('configs.name must be string');else if (this.storages.has(configs.name)) throw new Error(`${configs.name} is already in use`);\n  const PREFERENCES_GLOBAL_ERRORS = {\n    accessibility: new Error(`Preference is not accessible`),\n    existence: name => new Error(`${name} is not exist in list`)\n  };\n\n  const preferencesStorage = (() => {\n    try {\n      return this.storages.get(configs.name);\n    } catch (error) {\n      return this.storages.initialize(configs.name);\n    }\n  })();\n  /**\n   * Preferences module is a Preference holder/manager\n   *\n   * @mixes module:remote-controller-server-core~external:EventEmitter\n   */\n\n\n  class Preferences extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n    constructor(...args) {\n      super(...args);\n\n      _preferencesList.set(this, {\n        writable: true,\n        value: {}\n      });\n    }\n\n    /**\n     * Preference updated event\n     *\n     * @event module:preferences~Preferences#event:updated\n     *\n     * @type {object}\n     * @property {string} name Preference's name that updated\n     *\n     * @see module:preferences/preference#event:updated\n     */\n\n    /**\n     * Preference removed event\n     *\n     * @event module:preferences~Preferences#event:removed\n     *\n     * @see module:preferences/preference#event:removed\n     */\n\n    /**\n     * Get Preference instance via it's name\n     *\n     * @param {string} name Target Preference's name\n     *\n     * @emits module:preferences~Preferences#event:updated\n     * @emits module:preferences~Preferences#event:removed\n     *\n     * @listens module:preferences/preference#event:updated\n     * @listens module:preferences/preference#event:removed\n     *\n     * @return {module:preferences/preference}\n     */\n    get(name) {\n      if (typeof name !== 'string') throw new Error('name parameter is required and must be string'); // Return Preference from list if exist\n\n      if (_classPrivateFieldGet(this, _preferencesList).hasOwnProperty(name)) return _classPrivateFieldGet(this, _preferencesList)[name];\n      _classPrivateFieldGet(this, _preferencesList)[name] = new _preference__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        name,\n        storage: preferencesStorage\n      });\n\n      _classPrivateFieldGet(this, _preferencesList)[name].on('updated', event => this.emit('updated', {\n        name,\n        ...event\n      }));\n\n      _classPrivateFieldGet(this, _preferencesList)[name].on('removed', event => this.emit('removed', event));\n\n      return _classPrivateFieldGet(this, _preferencesList)[name];\n    }\n    /**\n     * Initialize Preference\n     *\n     * @param {string} name Preference's name\n     * @param {object} [body={}] Preference's initial content\n     *\n     * @throws Will throw an error if Preference is already exist in list\n     *\n     * @emits module:preferences~Preferences#event:updated\n     * @emits module:preferences~Preferences#event:removed\n     *\n     * @listens module:preferences/preference#event:updated\n     * @listens module:preferences/preference#event:removed\n     *\n     * @return {module:preferences/preference}\n     */\n\n\n    initialize(name, body = Object.create(null)) {\n      if (typeof name !== 'string') throw new Error('name parameter is required and must be string');else if (typeof body !== 'object') throw new Error('body parameter must be object');else if (_classPrivateFieldGet(this, _preferencesList).hasOwnProperty(name)) throw new Error(`${name} is already exist`);\n      _classPrivateFieldGet(this, _preferencesList)[name] = new _preference__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        name,\n        body,\n        storage: preferencesStorage\n      });\n\n      _classPrivateFieldGet(this, _preferencesList)[name].on('updated', event => this.emit('updated', {\n        name,\n        ...event\n      }));\n\n      _classPrivateFieldGet(this, _preferencesList)[name].on('removed', event => this.emit('removed', event));\n\n      return _classPrivateFieldGet(this, _preferencesList)[name];\n    }\n    /**\n     * Remove Preference from list and its Storage\n     *\n     * @param {(string|module:preferences/preference)} preference Preference or Preference's name to remove\n     * @param {object} [configs={}]\n     * @param {boolean} [configs.sync=true] Async or sync\n     *\n     * @throws Will throw an error if Preference is not accessible\n     * @throws Will throw an error if Preference is not exist in list\n     *\n     * @return {(void|Promise<(void|Error)>)} Return promise if configs.sync equal to false\n     * * Rejection\n     *  * Reject an error if Preference is not accessible\n     *  * Reject an error if Preference is not exist in list\n     */\n\n\n    remove(preference, configs = Object.create(null)) {\n      if (preference === undefined || typeof preference !== 'string' && !(preference instanceof _preference__WEBPACK_IMPORTED_MODULE_1__[\"default\"])) {\n        throw new Error('preference parameter is required and must be string/Preference');\n      } // Set default configs\n\n\n      configs = Object.assign({\n        sync: true\n      }, configs);\n      const name = preference.name || preference;\n\n      const deletePreference = () => {\n        delete _classPrivateFieldGet(this, _preferencesList)[name];\n      };\n\n      const ERRORS = {\n        accessibility: PREFERENCES_GLOBAL_ERRORS.accessibility,\n        existence: PREFERENCES_GLOBAL_ERRORS.existence(name)\n      };\n      preference = _classPrivateFieldGet(this, _preferencesList)[name];\n\n      if (configs.sync) {\n        if (typeof name !== 'string') throw ERRORS.accessibility;\n        if (preference === undefined) throw ERRORS.existence;\n        preference.remove();\n        deletePreference();\n        return;\n      }\n\n      if (typeof name !== 'string') return Promise.reject(ERRORS.accessibility);\n      if (preference === undefined) return Promise.reject(ERRORS.existence);\n      return preference.remove({\n        sync: false\n      }).then(deletePreference, error => Promise.reject(error));\n    }\n    /**\n     * Check Preference is already exist\n     *\n     * @param {string} preferenceName Storage's name to check\n     *\n     * @return {boolean}\n     */\n\n\n    has(preferenceName) {\n      return _classPrivateFieldGet(this, _preferencesList).hasOwnProperty(preferenceName);\n    }\n\n  }\n\n  var _preferencesList = new WeakMap();\n\n  return new Preferences();\n}\n\n\n\n//# sourceURL=src/preferences/index.js");

/***/ }),

/***/ "./preferences/preference.js":
/*!***********************************!*\
  !*** ./preferences/preference.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Preference; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _storages_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../storages/storage */ \"./storages/storage.js\");\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\n/**\n * @module preferences/preference\n */\n\n\nconst GLOBAL_ERRORS = {\n  accessibility: new Error('Preference is not accessible')\n  /**\n   * Preference is a holder for modules preferences\n   *\n   * @mixes module:remote-controller-server-core~external:EventEmitter\n   */\n\n};\nclass Preference extends events__WEBPACK_IMPORTED_MODULE_0___default.a {\n  /**\n   * preferences storage\n   *\n   * @type {module:storages/storage}\n   */\n\n  /**\n   * Preference's name\n   *\n   * @type {string}\n   */\n\n  /**\n   * Initialize/Read Preference\n   *\n   * @param {object} configs\n   * @param {string} configs.name Preference's name\n   * @param {module:storages/storage} configs.storage Storage that use for preferences\n   * @param {object} [configs.body] Preference's initial content\n   *\n   * @throws Will throw an error if the storage is not accessible\n   * @throws Will throw an error if the body property provided but storage is already exist\n   * @throws Will throw an error if the body property not provided and storage is not accessible\n   */\n  constructor(configs) {\n    let initial = false;\n    if (typeof configs !== 'object') throw new Error('configs parameter is required and must be object');else if (typeof configs.name !== 'string') throw new Error('configs.name is required and must be string');else if (configs.storage === undefined || !(configs.storage instanceof _storages_storage__WEBPACK_IMPORTED_MODULE_1__[\"default\"])) throw new Error('configs.storage is required and must be Storage');else if (configs.storage.body === undefined) throw new Error('Storage is not accessible');else if (configs.body !== undefined && typeof configs.body !== 'object') throw new Error('configs.body must be object');\n    super();\n\n    _storage.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _name.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldSet(this, _storage, configs.storage);\n\n    _classPrivateFieldSet(this, _name, configs.name);\n\n    if (configs.body) initial = true;\n\n    if (initial) {\n      if (typeof _classPrivateFieldGet(this, _storage).body[_classPrivateFieldGet(this, _name)] === 'object') throw new Error(`${_classPrivateFieldGet(this, _name)} is already exist`);\n\n      _classPrivateFieldGet(this, _storage).update(body => {\n        body[_classPrivateFieldGet(this, _name)] = configs.body;\n        return body;\n      });\n    } else if (typeof _classPrivateFieldGet(this, _storage).body[_classPrivateFieldGet(this, _name)] !== 'object') throw new Error(`${_classPrivateFieldGet(this, _name)} is not accessible`);\n  }\n  /**\n   * Preference's name\n   *\n   * @type {string}\n   */\n\n\n  get name() {\n    return _classPrivateFieldGet(this, _name);\n  }\n  /**\n   * Copy of Preference's body object\n   *\n   * @type {string}\n   */\n\n\n  get body() {\n    if (_classPrivateFieldGet(this, _storage) && _classPrivateFieldGet(this, _storage).body && _classPrivateFieldGet(this, _storage).body[_classPrivateFieldGet(this, _name)]) {\n      return JSON.parse(JSON.stringify(_classPrivateFieldGet(this, _storage).body[_classPrivateFieldGet(this, _name)]));\n    }\n  }\n  /**\n   * Update Preference content\n   *\n   * @param {(object|function)} body Updated Preference body, if body is a function, a copy of last body passed to it, then have to return object as Preference body\n   * @param {object} [configs={}]\n   * @param {boolean} [configs.sync=true] Async or sync\n   *\n   * @throws Will throw an error if the Preference is not accessible\n   *\n   * @emits module:preferences/preference#event:updated\n   *\n   * @return {(void|Promise<(void|Error)>)} Return promise if configs.sync equal to false\n   * * Rejection\n   *  * Reject an error if the Preference is not accessible\n   */\n\n\n  update(body, configs = Object.create(null)) {\n    // Make body object from function\n    if (typeof body === 'function') body = body(this.body);\n    if (typeof body !== 'object') throw new Error('body parameter is required and must be object/function'); // Set default configs\n\n    configs = Object.assign({\n      sync: true\n    }, configs);\n\n    const updateBody = storageBody => {\n      storageBody[_classPrivateFieldGet(this, _name)] = body;\n      return storageBody;\n    };\n\n    const currentBody = this.body;\n    /**\n     * Preference updated event\n     *\n     * @event module:preferences/preference#event:updated\n     *\n     * @type {object}\n     * @property {object} lastBody Preference's body before update\n     * @property {object} updatedBody A copy of updated body object\n     */\n\n    const fireEvent = () => {\n      const EVENT = {\n        lastBody: currentBody,\n        updatedBody: this.body\n      };\n      this.emit('updated', EVENT);\n    };\n\n    if (configs.sync) {\n      if (_classPrivateFieldGet(this, _storage) === undefined) throw GLOBAL_ERRORS.accessibility;\n\n      _classPrivateFieldGet(this, _storage).update(updateBody);\n\n      fireEvent();\n      return;\n    }\n\n    if (_classPrivateFieldGet(this, _storage) === undefined) return Promise.reject(GLOBAL_ERRORS.accessibility);\n    return _classPrivateFieldGet(this, _storage).update(updateBody, {\n      sync: false\n    }).then(fireEvent, error => Promise.reject(error));\n  }\n  /**\n   * Remove Preference object\n   *\n   * @param {object} [configs={}]\n   * @param {boolean} [configs.sync=true] Async or sync\n   *\n   * @throws Will throw an error if the Preference is not accessible\n   *\n   * @emits module:preferences/preference#event:removed\n   *\n   * @return {(void|Promise<(void|Error)>)} Return promise if configs.sync equal to false\n   * * Rejection\n   *  * Reject an error if the Preference is not accessible\n   */\n\n\n  remove(configs = Object.create(null)) {\n    const lastBody = this.body;\n\n    const deletePreference = body => {\n      delete body[this.name];\n      return body;\n    };\n    /**\n     * Preference removed event\n     *\n     * @event module:preferences/preference#event:removed\n     *\n     * @type {object}\n     * @property {string} name Name of the removed Preference\n     * @property {object} body Last body of the removed Preference\n     */\n\n\n    const clearProperties = () => {\n      const EVENT = {\n        name: this.name,\n        body: lastBody\n      };\n\n      _classPrivateFieldSet(this, _storage, undefined);\n\n      _classPrivateFieldSet(this, _name, undefined);\n\n      this.emit('removed', EVENT);\n    }; // Set default configs\n\n\n    configs = Object.assign({\n      sync: true\n    }, configs);\n\n    if (configs.sync) {\n      if (_classPrivateFieldGet(this, _storage) === undefined) throw GLOBAL_ERRORS.accessibility;\n\n      _classPrivateFieldGet(this, _storage).update(deletePreference);\n\n      clearProperties();\n      return;\n    }\n\n    if (_classPrivateFieldGet(this, _storage) === undefined) return Promise.reject(GLOBAL_ERRORS.accessibility);\n    return _classPrivateFieldGet(this, _storage).update(deletePreference, {\n      sync: false\n    }).then(clearProperties, error => Promise.reject(error));\n  }\n\n}\n\nvar _storage = new WeakMap();\n\nvar _name = new WeakMap();\n\n//# sourceURL=src/preferences/preference.js");

/***/ }),

/***/ "./storages/index.js":
/*!***************************!*\
  !*** ./storages/index.js ***!
  \***************************/
/*! exports provided: default, Storage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return makeStorages; });\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage */ \"./storages/storage.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Storage\", function() { return _storage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\n/**\n * @module storages\n */\n\n/**\n * makeStorages creates storages module\n *\n * @param {object} [configs={}]\n * @param {string} [configs.path=process.cwd()] Storages path address\n *\n * @return {module:storages~Storages}\n */\n\nfunction makeStorages(configs = Object.create(null)) {\n  // Set default configs\n  configs = Object.assign({\n    path: process.cwd()\n  }, configs);\n  if (typeof configs.path !== 'string') throw new Error('configs.path must be string');\n  const STORAGES_GLOBAL_ERRORS = {\n    accessibility: new Error('Storage is not accessible'),\n    existence: name => new Error(`${name} is not exist in list`)\n    /**\n     * Storages module is a Storage holder/manager\n     */\n\n  };\n\n  class Storages {\n    /**\n     * @type {Object}\n     */\n    // JSDoc doesnt use this class without constructor :/\n    constructor() {\n      _storagesList.set(this, {\n        writable: true,\n        value: {}\n      });\n    } // eslint-disable-line no-useless-constructor\n\n    /**\n     * Get Storage instance via it's name\n     *\n     * @param {string} name Target storage's name\n     *\n     * @return {module:storages/storage}\n     */\n\n\n    get(name) {\n      if (typeof name !== 'string') throw new Error('name parameter is required and must be string'); // Return Storage from list if exist\n\n      if (_classPrivateFieldGet(this, _storagesList).hasOwnProperty(name)) return _classPrivateFieldGet(this, _storagesList)[name];\n      _classPrivateFieldGet(this, _storagesList)[name] = new _storage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        name,\n        path: configs.path\n      });\n      return _classPrivateFieldGet(this, _storagesList)[name];\n    }\n    /**\n     * Initialize Storage\n     *\n     * @param {string} name Storage's name\n     * @param {object} [body={}] Storage's initial content\n     *\n     * @throws Will throw an error if Storage is already exist in list\n     *\n     * @return {module:storages/storage}\n     */\n\n\n    initialize(name, body = Object.create(null)) {\n      if (typeof name !== 'string') throw new Error('name parameter is required and must be string');else if (typeof body !== 'object') throw new Error('body parameter must be object');else if (_classPrivateFieldGet(this, _storagesList).hasOwnProperty(name)) throw new Error(`${name} is already exist`);\n      _classPrivateFieldGet(this, _storagesList)[name] = new _storage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        name,\n        body,\n        path: configs.path\n      });\n      return _classPrivateFieldGet(this, _storagesList)[name];\n    }\n    /**\n     * Remove Storage from list and it's file\n     *\n     * @param {(string|module:storages/storage)} storage Storage or storage's name to remove\n     * @param {object} [configs={}]\n     * @param {boolean} [configs.sync=true] Async or sync\n     *\n     * @throws Will throw an error if Storage is not accessible\n     * @throws Will throw an error if Storage is not exist in list\n     *\n     * @return {(void|Promise<(void|Error)>)} Return promise if configs.sync equal to false\n     * * Rejection\n     *  * Reject an error if Storage is not accessible\n     *  * Reject an error if Storage is not exist in list\n     */\n\n\n    remove(storage, configs = Object.create(null)) {\n      if (storage === undefined || typeof storage !== 'string' && !(storage instanceof _storage__WEBPACK_IMPORTED_MODULE_0__[\"default\"])) {\n        throw new Error('storage parameter is required and must be string/Storage');\n      } // Set default configs\n\n\n      configs = Object.assign({\n        sync: true\n      }, configs);\n      const name = storage.name || storage;\n\n      const deleteStorage = () => {\n        delete _classPrivateFieldGet(this, _storagesList)[name];\n      };\n\n      const ERRORS = {\n        accessibility: STORAGES_GLOBAL_ERRORS.accessibility,\n        existence: STORAGES_GLOBAL_ERRORS.existence(name)\n      };\n      storage = _classPrivateFieldGet(this, _storagesList)[name];\n\n      if (configs.sync) {\n        if (typeof name !== 'string') throw ERRORS.accessibility;\n        if (storage === undefined) throw ERRORS.existence;\n        storage.remove();\n        deleteStorage();\n        return;\n      }\n\n      if (typeof name !== 'string') return Promise.reject(ERRORS.accessibility);\n      if (storage === undefined) return Promise.reject(ERRORS.existence);\n      return storage.remove({\n        sync: false\n      }).then(deleteStorage, error => Promise.reject(error));\n    }\n    /**\n     * Check Storage is already exist\n     *\n     * @param {string} storageName Storage's name to check\n     *\n     * @return {boolean}\n     */\n\n\n    has(storageName) {\n      return _classPrivateFieldGet(this, _storagesList).hasOwnProperty(storageName);\n    }\n    /**\n     * Return storage's path\n     *\n     * @return {string}\n     */\n\n\n    get path() {\n      return configs.path;\n    }\n\n  }\n\n  var _storagesList = new WeakMap();\n\n  return new Storages();\n}\n\n\n\n//# sourceURL=src/storages/index.js");

/***/ }),

/***/ "./storages/storage.js":
/*!*****************************!*\
  !*** ./storages/storage.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Storage; });\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_3__);\nfunction _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to set private field on non-instance\"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\n/**\n * @module storages/storage\n */\n\n\n\n\nconst ENCODING = 'utf8';\nconst GLOBAL_ERRORS = {\n  accessibility: new Error('Storage is not accessible')\n  /**\n   * Storage is a json file Manager\n   *\n   * @mixes module:remote-controller-server-core~external:EventEmitter\n   */\n\n};\nclass Storage extends events__WEBPACK_IMPORTED_MODULE_3___default.a {\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {string}\n   */\n\n  /**\n   * @type {object}\n   */\n\n  /**\n   * Initialize/Read json file\n   *\n   * @param {object} configs\n   * @param {string} configs.name json file name\n   * @param {object} [configs.body] json file initial content\n   * @param {object} [configs.path=process.cwd()] json file initial content\n   *\n   * @throws Will throw an error if the requested storage's json file is not accessible\n   * @throws Will throw an error if the body property provided but storage is already exist\n   * @throws Will throw an error if the body property not provided and storage is not accessible\n   */\n  constructor(configs) {\n    let initial = false;\n    let storageAccessible;\n    let storageAddress;\n    if (typeof configs !== 'object') throw new Error('configs parameter is required and must be object');\n    super(); // Set default configs\n\n    _name.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _address.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    _body.set(this, {\n      writable: true,\n      value: void 0\n    });\n\n    configs = Object.assign({\n      path: process.cwd()\n    }, configs);\n    if (typeof configs.name !== 'string') throw new Error('configs.name is required and must be string');else if (configs.body !== undefined && typeof configs.body !== 'object') throw new Error('configs.body must be object');else if (typeof configs.path !== 'string') throw new Error('configs.path must be string'); // Mark as must initial if configs.body property is defined\n\n    if (configs.body !== undefined) initial = true;\n    storageAddress = path__WEBPACK_IMPORTED_MODULE_2___default.a.join(configs.path, configs.name + '.json'); // Check storage accessibility\n\n    try {\n      fs__WEBPACK_IMPORTED_MODULE_1___default.a.accessSync(storageAddress, fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.F_OK | fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.W_OK);\n      storageAccessible = true;\n    } catch (error) {\n      storageAccessible = false;\n    }\n\n    if (initial) {\n      if (storageAccessible) throw new Error(`${configs.name} is already exist`);\n      fs__WEBPACK_IMPORTED_MODULE_1___default.a.writeFileSync(storageAddress, JSON.stringify(configs.body), {\n        encoding: ENCODING,\n        flag: 'w'\n      }); // Take a copy of body\n\n      _classPrivateFieldSet(this, _body, JSON.parse(JSON.stringify(configs.body)));\n    } else {\n      if (!storageAccessible) throw new Error(`${configs.name} is not accessible`); // Read storage and convert it to object\n\n      _classPrivateFieldSet(this, _body, JSON.parse(fs__WEBPACK_IMPORTED_MODULE_1___default.a.readFileSync(storageAddress, {\n        encoding: ENCODING,\n        flag: 'r'\n      })));\n    }\n\n    _classPrivateFieldSet(this, _name, configs.name);\n\n    _classPrivateFieldSet(this, _address, storageAddress);\n  }\n  /**\n   * Storage's content object\n   *\n   * @type {object}\n   */\n\n\n  get body() {\n    return _classPrivateFieldGet(this, _body) ? JSON.parse(JSON.stringify(_classPrivateFieldGet(this, _body))) : undefined;\n  }\n  /**\n   * Storage's name\n   *\n   * @type {string}\n   */\n\n\n  get name() {\n    return _classPrivateFieldGet(this, _name);\n  }\n  /**\n   * Remove storage json file\n   *\n   * @param {object} [configs={}]\n   * @param {boolean} [configs.sync=true] Async or sync\n   *\n   * @throws Will throw an error if the storage's json file doesn't accessible\n   *\n   * @emits module:storages/storage#event:removed\n   *\n   * @return {(void|Promise<(void|Error)>)} Return promise if configs.sync equal to false\n   * * Rejection\n   *  * Reject an error if the storage's json file doesn't accessible\n   */\n\n\n  remove(configs = Object.create(null)) {\n    // Set default configs\n    configs = Object.assign({\n      sync: true\n    }, configs);\n\n    const clearProperties = () => {\n      const EVENT = {\n        name: _classPrivateFieldGet(this, _name),\n        body: _classPrivateFieldGet(this, _body)\n      };\n\n      _classPrivateFieldSet(this, _body, undefined);\n\n      _classPrivateFieldSet(this, _name, undefined);\n      /**\n       * Storage removed event\n       *\n       * @event module:storages/storage#event:removed\n       *\n       * @type {object}\n       * @property {string} name Name of the removed storage\n       * @property {object} body Last body of the removed storage\n       */\n\n\n      this.emit('removed', EVENT);\n    };\n\n    if (configs.sync) {\n      try {\n        fs__WEBPACK_IMPORTED_MODULE_1___default.a.accessSync(_classPrivateFieldGet(this, _address), fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.F_OK | fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.W_OK);\n      } catch (error) {\n        throw GLOBAL_ERRORS.accessibility;\n      }\n\n      fs__WEBPACK_IMPORTED_MODULE_1___default.a.unlinkSync(_classPrivateFieldGet(this, _address));\n      clearProperties();\n      return;\n    }\n\n    return Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(fs__WEBPACK_IMPORTED_MODULE_1___default.a.access)(_classPrivateFieldGet(this, _address), fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.F_OK | fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.W_OK).then(() => {\n      return Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(fs__WEBPACK_IMPORTED_MODULE_1___default.a.unlink)(_classPrivateFieldGet(this, _address)).then(clearProperties, error => Promise.reject(error));\n    }, () => Promise.reject(GLOBAL_ERRORS.accessibility));\n  }\n  /**\n   * Update storage content\n   *\n   * @param {(object|function)} body Updated Storage body, if body is a function, a copy of last body passed to it, then have to return object as storage body\n   * @param {object} [configs={}]\n   * @param {boolean} [configs.sync=true] Async or sync\n   *\n   * @throws Will throw an error if the storage's json file doesn't accessible\n   *\n   * @emits module:storages/storage#event:updated\n   *\n   * @return {(void|Promise<(void|Error)>)} Return promise if configs.sync equal to false\n   * * Rejection\n   *  * Reject an error if the storage's json file doesn't accessible\n   */\n\n\n  update(body, configs = Object.create(null)) {\n    if (typeof body === 'function') body = body(this.body); // Set default configs\n\n    configs = Object.assign({\n      sync: true\n    }, configs);\n    if (body === undefined || typeof body !== 'object') throw new Error('body parameter is required and must be object/function');\n\n    const setProperties = () => {\n      const EVENT = {\n        lastBody: _classPrivateFieldGet(this, _body),\n        updatedBody: JSON.parse(JSON.stringify(body))\n      };\n\n      _classPrivateFieldSet(this, _body, body);\n      /**\n       * Storage updated event\n       *\n       * @event module:storages/storage#event:updated\n       *\n       * @type {object}\n       * @property {object} lastBody storage's body before update\n       * @property {object} updatedBody A copy of updated body object\n       */\n\n\n      this.emit('updated', EVENT);\n    };\n\n    if (configs.sync) {\n      try {\n        fs__WEBPACK_IMPORTED_MODULE_1___default.a.accessSync(_classPrivateFieldGet(this, _address), fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.F_OK | fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.W_OK);\n      } catch (error) {\n        throw GLOBAL_ERRORS.accessibility;\n      }\n\n      fs__WEBPACK_IMPORTED_MODULE_1___default.a.writeFileSync(_classPrivateFieldGet(this, _address), JSON.stringify(body), {\n        encoding: ENCODING,\n        flag: 'w'\n      });\n      setProperties();\n      return;\n    }\n\n    return Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(fs__WEBPACK_IMPORTED_MODULE_1___default.a.access)(_classPrivateFieldGet(this, _address), fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.F_OK | fs__WEBPACK_IMPORTED_MODULE_1___default.a.constants.W_OK).then(() => {\n      return Object(util__WEBPACK_IMPORTED_MODULE_0__[\"promisify\"])(fs__WEBPACK_IMPORTED_MODULE_1___default.a.writeFile)(_classPrivateFieldGet(this, _address), JSON.stringify(body), {\n        encoding: ENCODING,\n        flag: 'w'\n      }).then(setProperties, error => Promise.reject(error));\n    }, () => Promise.reject(GLOBAL_ERRORS.accessibility));\n  }\n\n}\n\nvar _name = new WeakMap();\n\nvar _address = new WeakMap();\n\nvar _body = new WeakMap();\n\n//# sourceURL=src/storages/storage.js");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=src/external_%22crypto%22");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=src/external_%22events%22");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=src/external_%22fs%22");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=src/external_%22http%22");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=src/external_%22https%22");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"net\");\n\n//# sourceURL=src/external_%22net%22");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=src/external_%22os%22");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=src/external_%22path%22");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");\n\n//# sourceURL=src/external_%22stream%22");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tls\");\n\n//# sourceURL=src/external_%22tls%22");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=src/external_%22url%22");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=src/external_%22util%22");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");\n\n//# sourceURL=src/external_%22zlib%22");

/***/ })

/******/ });
});