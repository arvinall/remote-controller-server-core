!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("remote-controller-server-core",[],t):"object"==typeof exports?exports["remote-controller-server-core"]=t():e["remote-controller-server-core"]=t()}(global,function(){return function(e){var t={};function r(i){if(t[i])return t[i].exports;var s=t[i]={i:i,l:!1,exports:{}};return e[i].call(s.exports,s,s.exports,r),s.l=!0,s.exports}return r.m=e,r.c=t,r.d=function(e,t,i){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)r.d(i,s,function(t){return e[t]}.bind(null,s));return i},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=6)}([function(e,t){e.exports=function(e,t){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");var r=t.get(e);return r.get?r.get.call(e):r.value}},function(e,t){e.exports=require("fs")},function(e,t){e.exports=function(e,t,r){if(!t.has(e))throw new TypeError("attempted to set private field on non-instance");var i=t.get(e);if(i.set)i.set.call(e,r);else{if(!i.writable)throw new TypeError("attempted to set read only private field");i.value=r}return r}},function(e,t){e.exports=require("events")},function(e,t){e.exports=require("util")},function(e,t){e.exports=require("path")},function(e,t,r){"use strict";r.r(t);var i=r(0),s=r.n(i),n=r(2),o=r.n(n),a=r(4),c=r(1),d=r.n(c),f=r(5),h=r.n(f),u=r(3),p=r.n(u);const y="utf8";class m extends p.a{constructor(e){let t,r,i=!1;if("object"!=typeof e)throw new Error("configs parameter is required and must be object");if(super(),b.set(this,{writable:!0,value:void 0}),w.set(this,{writable:!0,value:void 0}),l.set(this,{writable:!0,value:void 0}),void 0===e.path&&(e.path=process.cwd()),"string"!=typeof e.name)throw new Error("configs.name is required and must be string");if(void 0!==e.body&&"object"!=typeof e.body)throw new Error("configs.body must be object");if("string"!=typeof e.path)throw new Error("configs.path must be string");void 0!==e.body&&(i=!0),r=h.a.join(e.path,e.name+".json");try{d.a.accessSync(r,d.a.constants.F_OK|d.a.constants.W_OK),t=!0}catch(e){t=!1}if(i){if(t)throw new Error(`${e.name} is already exist`);d.a.writeFileSync(r,JSON.stringify(e.body),{encoding:y,flag:"w"}),o()(this,l,JSON.parse(JSON.stringify(e.body)))}else{if(!t)throw new Error(`${e.name} is not accessible`);o()(this,l,JSON.parse(d.a.readFileSync(r,{encoding:y,flag:"r"})))}o()(this,b,e.name),o()(this,w,r)}get body(){return s()(this,l)?JSON.parse(JSON.stringify(s()(this,l))):void 0}get name(){return s()(this,b)}remove(e={sync:!0}){const t=()=>{const e={name:s()(this,b),body:s()(this,l)};o()(this,l,void 0),o()(this,b,void 0),this.emit("removed",e)};if(e.sync){try{d.a.accessSync(s()(this,w),d.a.constants.F_OK|d.a.constants.W_OK)}catch(e){throw new Error("Storage is not accessible")}return d.a.unlinkSync(s()(this,w)),void t()}return Object(a.promisify)(d.a.access)(s()(this,w),d.a.constants.F_OK|d.a.constants.W_OK).then(()=>Object(a.promisify)(d.a.unlink)(s()(this,w)).then(t,e=>Promise.reject(e)),()=>Promise.reject(new Error("Storage is not accessible")))}update(e,t={sync:!0}){if("function"==typeof e&&(e=e(this.body)),void 0===e||"object"!=typeof e)throw new Error("body parameter is required and must be object/function");const r=()=>{const t={lastBody:s()(this,l),updatedBody:JSON.parse(JSON.stringify(e))};o()(this,l,e),this.emit("updated",t)};if(t.sync){try{d.a.accessSync(s()(this,w),d.a.constants.F_OK|d.a.constants.W_OK)}catch(e){throw new Error("Storage is not accessible")}return d.a.writeFileSync(s()(this,w),JSON.stringify(e),{encoding:y,flag:"w"}),void r()}return Object(a.promisify)(d.a.access)(s()(this,w),d.a.constants.F_OK|d.a.constants.W_OK).then(()=>Object(a.promisify)(d.a.writeFile)(s()(this,w),JSON.stringify(e),{encoding:y,flag:"w"}).then(r,e=>Promise.reject(e)),()=>Promise.reject(new Error("Storage is not accessible")))}}var b=new WeakMap,w=new WeakMap,l=new WeakMap;class g extends p.a{constructor(e){let t=!1;if("object"!=typeof e)throw new Error("configs parameter is required and must be object");if("string"!=typeof e.name)throw new Error("configs.name is required and must be string");if(void 0===e.storage||e.storage.constructor.name!==m.name)throw new Error("configs.storage is required and must be Storage");if(void 0===e.storage.body)throw new Error("Storage is not accessible");if(void 0!==e.body&&"object"!=typeof e.body)throw new Error("configs.body must be object");if(super(),v.set(this,{writable:!0,value:void 0}),j.set(this,{writable:!0,value:void 0}),o()(this,v,e.storage),o()(this,j,e.name),e.body&&(t=!0),t){if("object"==typeof s()(this,v).body[s()(this,j)])throw new Error(`${s()(this,j)} is already exist`);s()(this,v).update(t=>(t[s()(this,j)]=e.body,t))}else if("object"!=typeof s()(this,v).body[s()(this,j)])throw new Error(`${s()(this,j)} is not accessible`)}get name(){return s()(this,j)}get body(){if(s()(this,v)&&s()(this,v).body&&s()(this,v).body[s()(this,j)])return JSON.parse(JSON.stringify(s()(this,v).body[s()(this,j)]))}update(e,t={sync:!0}){if("function"==typeof e&&(e=e(this.body)),"object"!=typeof e)throw new Error("body parameter is required and must be object/function");if(void 0===s()(this,v))throw new Error("Preference is not accessible");const r=t=>(t[s()(this,j)]=e,t),i=this.body,n=()=>{const e={lastBody:i,updatedBody:this.body};this.emit("updated",e)};return t.sync?(s()(this,v).update(r),void n()):s()(this,v).update(r,{sync:!1}).then(n,e=>Promise.reject(e))}remove(e={sync:!0}){if(void 0===s()(this,v))throw new Error("Preference is not accessible");const t=this.body,r=e=>(delete e[this.name],e),i=()=>{const e={name:this.name,body:t};o()(this,v,void 0),o()(this,j,void 0),this.emit("removed",e)};return e.sync?(s()(this,v).update(r),void i()):s()(this,v).update(r,{sync:!1}).then(i,e=>Promise.reject(e))}}var v=new WeakMap,j=new WeakMap;r.d(t,"default",function(){return O});const E=new Map;function O(e=Object.create(null)){if("object"!=typeof e)throw new Error("configs parameter must be object");e=Object.assign({storagePath:process.cwd(),preferencesStorageName:"preferences"},e);const t=Object.create(null);let r=E.get(e.storagePath);return void 0===r&&(r=function(e={path:process.cwd()}){if("string"!=typeof e.path)throw new Error("configs.path must be string");var t=new WeakMap;return new class{constructor(){t.set(this,{writable:!0,value:{}})}get(r){if("string"!=typeof r)throw new Error("name parameter is required and must be string");return s()(this,t).hasOwnProperty(r)?s()(this,t)[r]:(s()(this,t)[r]=new m({name:r,path:e.path}),s()(this,t)[r])}initialize(r,i=Object.create(null)){if("string"!=typeof r)throw new Error("name parameter is required and must be string");if("object"!=typeof i)throw new Error("body parameter must be object");if(s()(this,t).hasOwnProperty(r))throw new Error(`${r} is already exist`);return s()(this,t)[r]=new m({name:r,body:i,path:e.path}),s()(this,t)[r]}remove(e,r={sync:!0}){if(void 0===e||"string"!=typeof e&&!(e instanceof m))throw new Error("storage parameter is required and must be string/Storage");const i=e.name||e;e=s()(this,t)[i];const n=()=>{delete s()(this,t)[i]},o={accessibility:new Error("storage is not accessible"),existence:new Error(`${i} is not exist in list`)};if(r.sync){if("string"!=typeof i)throw o.accessibility;if(void 0===e)throw o.existence;return e.remove(),void n()}return new Promise((t,r)=>{"string"!=typeof i&&r(o.accessibility),void 0===e&&r(o.existence),t(e.remove({sync:!1}).then(n,e=>Promise.reject(e)))})}has(e){if("string"!=typeof e)throw new Error("storageName parameter is required and must be string");return s()(this,t).hasOwnProperty(e)}get _path(){return e.path}}}({path:e.storagePath}),E.set(e.storagePath,r)),t.preferences=function(e){if("object"!=typeof e)throw new Error("configs parameter is required and must be object");if("object"!=typeof e.storages||"function"!=typeof e.storages.initialize)throw new Error("configs.storages is required and must be storages");if("string"!=typeof(e=Object.assign({name:"preferences"},e)).name)throw new Error("configs.name is required and must be string");if(e.storages.has(e.name))throw new Error(`${e.name} is already in use`);const t=(()=>{try{return e.storages.get(e.name)}catch(t){return e.storages.initialize(e.name)}})();var r=new WeakMap;return new class extends p.a{constructor(...e){super(...e),r.set(this,{writable:!0,value:{}})}get(e){if("string"!=typeof e)throw new Error("name parameter is required and must be string");return s()(this,r).hasOwnProperty(e)?s()(this,r)[e]:(s()(this,r)[e]=new g({name:e,storage:t}),s()(this,r)[e].on("updated",t=>this.emit("updated",{name:e,...t})),s()(this,r)[e].on("removed",e=>this.emit("removed",e)),s()(this,r)[e])}initialize(e,i=Object.create(null)){if("string"!=typeof e)throw new Error("name parameter is required and must be string");if("object"!=typeof i)throw new Error("body parameter must be object");if(s()(this,r).hasOwnProperty(e))throw new Error(`${e} is already exist`);return s()(this,r)[e]=new g({name:e,body:i,storage:t}),s()(this,r)[e].on("updated",t=>this.emit("updated",{name:e,...t})),s()(this,r)[e].on("removed",e=>this.emit("removed",e)),s()(this,r)[e]}remove(e,t={sync:!0}){if(void 0===e||"string"!=typeof e&&!(e instanceof g))throw new Error("preference parameter is required and must be string/Preference");const i=e.name||e;e=s()(this,r)[i];const n=()=>{delete s()(this,r)[i]},o={accessibility:new Error("Preference is not accessible"),existence:new Error(`${i} is not exist in list`)};if(t.sync){if("string"!=typeof i)throw o.accessibility;if(void 0===e)throw o.existence;return e.remove(),void n()}return new Promise((t,r)=>{"string"!=typeof i&&r(o.accessibility),void 0===e&&r(o.existence),t(e.remove({sync:!1}).then(n,e=>Promise.reject(e)))})}has(e){if("string"!=typeof e)throw new Error("PreferenceName parameter is required and must be string");return s()(this,r).hasOwnProperty(e)}}}({storages:r,name:e.preferencesStorageName}),t}}])});