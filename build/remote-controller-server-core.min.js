!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r():"function"==typeof define&&define.amd?define("remote-controller-server-core",[],r):"object"==typeof exports?exports["remote-controller-server-core"]=r():e["remote-controller-server-core"]=r()}(global,function(){return function(e){var r={};function t(o){if(r[o])return r[o].exports;var n=r[o]={i:o,l:!1,exports:{}};return e[o].call(n.exports,n,n.exports,t),n.l=!0,n.exports}return t.m=e,t.c=r,t.d=function(e,r,o){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var n in e)t.d(o,n,function(r){return e[r]}.bind(null,n));return o},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=6)}([function(e,r){e.exports=require("fs")},function(e){e.exports={name:"@remote-controller-server/core",version:"0.1.0",description:"Remote Controller Server's Core module",main:"build/remote-controller-server-core.min.js",scripts:{test:"eslint src/**/*.test.js && jest src",docs:"jsdoc -c jsdoc.config.js -P package.json -R README.md",build:"NODE_ENV=production webpack",start:"node build/remote-controller-server-core.min.js","build:dev":"NODE_ENV=development webpack","start:dev":"node $NODE_DEBUG_OPTION build/remote-controller-server-core.js"},repository:{type:"git",url:"git+https://github.com/arvinall/remote-controller-server-core.git"},keywords:["remote-controller","server","core"],author:"Arvinall <arvinall021@gmail.com>",license:"SEE LICENSE IN LICENSE.md",bugs:{url:"https://github.com/arvinall/remote-controller-server-core/issues"},homepage:"https://github.com/arvinall/remote-controller-server-core#readme",devDependencies:{"@babel/core":"^7.2.2","@babel/plugin-proposal-class-properties":"^7.3.0","@babel/plugin-proposal-private-methods":"^7.3.0","@babel/plugin-syntax-dynamic-import":"^7.2.0","@babel/plugin-transform-runtime":"^7.2.0","@babel/preset-env":"^7.3.1","babel-eslint":"^10.0.1","babel-loader":"^8.0.5",eslint:"^5.12.1","eslint-config-standard":"^12.0.0","eslint-loader":"^2.1.1","eslint-plugin-babel":"^5.3.0","eslint-plugin-import":"^2.16.0","eslint-plugin-node":"^8.0.1","eslint-plugin-promise":"^4.0.1","eslint-plugin-standard":"^4.0.0",jest:"^24.0.0",jsdoc:"^3.5.5","jsdoc-babel":"^0.5.0",webpack:"^4.29.0","webpack-cli":"^3.2.1"},dependencies:{"@babel/polyfill":"^7.2.5","@babel/runtime":"^7.3.1","engine.io":"^3.3.2"},optionalDependencies:{bufferutil:"^4.0.1","supports-color":"^6.1.0","utf-8-validate":"^5.0.2"}}},function(e,r){e.exports=function(e,r){if(!r.has(e))throw new TypeError("attempted to get private field on non-instance");var t=r.get(e);return t.get?t.get.call(e):t.value}},function(e,r){e.exports=function(e,r,t){if(!r.has(e))throw new TypeError("attempted to set private field on non-instance");var o=r.get(e);if(o.set)o.set.call(e,t);else{if(!o.writable)throw new TypeError("attempted to set read only private field");o.value=t}return t}},function(e,r){e.exports=require("path")},function(e,r){e.exports=require("events")},function(e,r,t){"use strict";t.r(r);var o=t(1),n=t(2),i=t.n(n),s=t(3),l=t.n(s),a=t(0),c=t.n(a),u=t(4),p=t.n(u),d=t(5),f=t.n(d);const b="utf8";var m=new WeakMap;t.d(r,"default",function(){return v}),t.d(r,"Storage",function(){return g});class v{constructor(e={}){this.version=o.version,this.mode=e.mode||"production"}}let g=class extends f.a{constructor(e){let r,t,o=!1;if(super(),m.set(this,{writable:!0,value:void 0}),void 0===e.path&&(e.path=process.cwd()),"string"!=typeof e.name)throw new Error("configs.name is required and must be string");if(void 0!==e.body&&"object"!=typeof e.body)throw new Error("configs.body must be object");if("string"!=typeof e.path)throw new Error("configs.path must be string");void 0!==e.body&&(o=!0),t=p.a.join(e.path,e.name+".json");try{c.a.accessSync(t,c.a.constants.F_OK|c.a.constants.W_OK),r=!0}catch(e){r=!1}if(o){if(r)throw new Error(`${e.name} is already exist`);c.a.writeFileSync(t,JSON.stringify(e.body),{encoding:b,flag:"w"})}else if(!r)throw new Error(`${e.name} is not accessible`);l()(this,m,JSON.parse(c.a.readFileSync(t,{encoding:b,flag:"r"})))}get body(){return i()(this,m)}}}])});