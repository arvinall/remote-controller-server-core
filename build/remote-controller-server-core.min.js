!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("remote-controller-server-core",[],t):"object"==typeof exports?exports["remote-controller-server-core"]=t():e["remote-controller-server-core"]=t()}(global,function(){return function(e){var t={};function r(o){if(t[o])return t[o].exports;var n=t[o]={i:o,l:!1,exports:{}};return e[o].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,o){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)r.d(o,n,function(t){return e[t]}.bind(null,n));return o},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=7)}([function(e,t){e.exports=function(e,t){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");var r=t.get(e);return r.get?r.get.call(e):r.value}},function(e,t){e.exports=require("fs")},function(e,t){e.exports=function(e,t,r){if(!t.has(e))throw new TypeError("attempted to set private field on non-instance");var o=t.get(e);if(o.set)o.set.call(e,r);else{if(!o.writable)throw new TypeError("attempted to set read only private field");o.value=r}return r}},function(e,t){e.exports=require("util")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("events")},function(e){e.exports={name:"@remote-controller-server/core",version:"0.1.0",description:"Remote Controller Server's Core module",main:"build/remote-controller-server-core.min.js",scripts:{test:"eslint src/**/*.test.js && jest src",docs:"jsdoc -c jsdoc.config.js -P package.json -R README.md",build:"NODE_ENV=production webpack",start:"node build/remote-controller-server-core.min.js","build:dev":"NODE_ENV=development webpack","start:dev":"node $NODE_DEBUG_OPTION build/remote-controller-server-core.js"},repository:{type:"git",url:"git+https://github.com/arvinall/remote-controller-server-core.git"},keywords:["remote-controller","server","core"],author:"Arvinall <arvinall021@gmail.com>",license:"SEE LICENSE IN LICENSE.md",bugs:{url:"https://github.com/arvinall/remote-controller-server-core/issues"},homepage:"https://github.com/arvinall/remote-controller-server-core#readme",devDependencies:{"@babel/core":"^7.2.2","@babel/plugin-proposal-class-properties":"^7.3.0","@babel/plugin-proposal-private-methods":"^7.3.0","@babel/plugin-syntax-dynamic-import":"^7.2.0","@babel/plugin-transform-runtime":"^7.2.0","@babel/preset-env":"^7.3.1","babel-eslint":"^10.0.1","babel-loader":"^8.0.5",eslint:"^5.12.1","eslint-config-standard":"^12.0.0","eslint-loader":"^2.1.1","eslint-plugin-babel":"^5.3.0","eslint-plugin-import":"^2.16.0","eslint-plugin-node":"^8.0.1","eslint-plugin-promise":"^4.0.1","eslint-plugin-standard":"^4.0.0",jest:"^24.0.0",jsdoc:"^3.5.5","jsdoc-babel":"^0.5.0",webpack:"^4.29.0","webpack-cli":"^3.2.1"},dependencies:{"@babel/polyfill":"^7.2.5","@babel/runtime":"^7.3.1","engine.io":"^3.3.2"},optionalDependencies:{bufferutil:"^4.0.1","supports-color":"^6.1.0","utf-8-validate":"^5.0.2"}}},function(e,t,r){"use strict";r.r(t);var o=r(4),n=r.n(o),i=r(6),s=r(0),a=r.n(s),c=r(5),l=r.n(c),u=r(2),d=r.n(u),p=r(3),f=r(1),b=r.n(f);const m="utf8";class h extends l.a{constructor(e){let t,r,o=!1;if(void 0===e)throw new Error("configs parameter is require");if(super(),y.set(this,{writable:!0,value:void 0}),g.set(this,{writable:!0,value:void 0}),v.set(this,{writable:!0,value:void 0}),void 0===e.path&&(e.path=process.cwd()),"string"!=typeof e.name)throw new Error("configs.name is required and must be string");if(void 0!==e.body&&"object"!=typeof e.body)throw new Error("configs.body must be object");if("string"!=typeof e.path)throw new Error("configs.path must be string");void 0!==e.body&&(o=!0),r=n.a.join(e.path,e.name+".json");try{b.a.accessSync(r,b.a.constants.F_OK|b.a.constants.W_OK),t=!0}catch(e){t=!1}if(o){if(t)throw new Error(`${e.name} is already exist`);b.a.writeFileSync(r,JSON.stringify(e.body),{encoding:m,flag:"w"}),d()(this,v,JSON.parse(JSON.stringify(e.body)))}else{if(!t)throw new Error(`${e.name} is not accessible`);d()(this,v,JSON.parse(b.a.readFileSync(r,{encoding:m,flag:"r"})))}d()(this,y,e.name),d()(this,g,r)}get body(){return a()(this,v)?JSON.parse(JSON.stringify(a()(this,v))):void 0}get name(){return a()(this,y)}remove(e={sync:!0}){const t=()=>{const e={name:a()(this,y),body:a()(this,v)};d()(this,v,void 0),d()(this,y,void 0),this.emit("removed",e)};if(e.sync){try{b.a.accessSync(a()(this,g),b.a.constants.F_OK|b.a.constants.W_OK)}catch(e){throw new Error("Storage is not accessible")}return b.a.unlinkSync(a()(this,g)),void t()}return Object(p.promisify)(b.a.access)(a()(this,g),b.a.constants.F_OK|b.a.constants.W_OK).then(()=>Object(p.promisify)(b.a.unlink)(a()(this,g)).then(t,e=>Promise.reject(e)),()=>Promise.reject(new Error("Storage is not accessible")))}update(e,t={sync:!0}){if("function"==typeof e&&(e=e(this.body)),void 0===e||"object"!=typeof e&&"function"!=typeof e)throw new Error("body parameter is required and must be object/function");const r=()=>{const t={lastBody:a()(this,v),updatedBody:JSON.parse(JSON.stringify(e))};d()(this,v,e),this.emit("updated",t)};if(t.sync){try{b.a.accessSync(a()(this,g),b.a.constants.F_OK|b.a.constants.W_OK)}catch(e){throw new Error("Storage is not accessible")}return b.a.writeFileSync(a()(this,g),JSON.stringify(e),{encoding:m,flag:"w"}),void r()}return Object(p.promisify)(b.a.access)(a()(this,g),b.a.constants.F_OK|b.a.constants.W_OK).then(()=>Object(p.promisify)(b.a.writeFile)(a()(this,g),JSON.stringify(e),{encoding:m,flag:"w"}).then(r,e=>Promise.reject(e)),()=>Promise.reject(new Error("Storage is not accessible")))}}var y=new WeakMap,g=new WeakMap,v=new WeakMap;r.d(t,"default",function(){return w}),r.d(t,"storages",function(){return j});class w{constructor(e={}){this.version=i.version,this.mode=e.mode||"production"}}let j=function(e={path:process.cwd()}){var t=new WeakMap;return new class extends l.a{constructor(...e){super(...e),t.set(this,{writable:!0,value:{}})}get(r){if("string"!=typeof r)throw new Error("name parameter is required and must be string");return void 0!==a()(this,t)[r]?a()(this,t)[r]:(a()(this,t)[r]=new h({name:r,path:e.path}),a()(this,t)[r])}initialize(r,o=Object.create(null)){if("string"!=typeof r)throw new Error("name parameter is required and must be string");if("object"!=typeof o)throw new Error("body parameter must be object");if(void 0!==a()(this,t)[r])throw new Error(`${r} is already exist`);return a()(this,t)[r]=new h({name:r,body:o,path:e.path}),a()(this,t)[r]}remove(e,r={sync:!0}){if(void 0===e||"string"!=typeof e&&!(e instanceof h))throw new Error("storage parameter is required and must be string/Storage");const o=e.name||e;e=a()(this,t)[o];const n={accessibility:new Error("storage is not accessible"),existence:new Error(`${o} is not exist in list`)};if(r.sync){if("string"!=typeof o)throw n.accessibility;if(void 0===e)throw n.existence;return e.remove(),void delete a()(this,t)[o]}return new Promise((r,i)=>{"string"!=typeof o&&i(n.accessibility),void 0===e&&i(n.existence),r(e.remove({sync:!1}).then(()=>{delete a()(this,t)[o]},e=>Promise.reject(e)))})}}}({path:n.a.join(process.cwd(),"tmp")})}])});