!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("remote-controller-server-core",[],t):"object"==typeof exports?exports["remote-controller-server-core"]=t():e["remote-controller-server-core"]=t()}(global,function(){return function(e){var t={};function r(o){if(t[o])return t[o].exports;var i=t[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,o){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(o,i,function(t){return e[t]}.bind(null,i));return o},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=6)}([function(e,t){e.exports=function(e,t){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");var r=t.get(e);return r.get?r.get.call(e):r.value}},function(e,t){e.exports=require("fs")},function(e,t){e.exports=function(e,t,r){if(!t.has(e))throw new TypeError("attempted to set private field on non-instance");var o=t.get(e);if(o.set)o.set.call(e,r);else{if(!o.writable)throw new TypeError("attempted to set read only private field");o.value=r}return r}},function(e,t){e.exports=require("util")},function(e,t){e.exports=require("events")},function(e,t){e.exports=require("path")},function(e,t,r){"use strict";r.r(t);var o=r(0),i=r.n(o),n=r(2),s=r.n(n),a=r(3),c=r(1),d=r.n(c),f=r(5),u=r.n(f),h=r(4),y=r.n(h);const p="utf8";class b extends y.a{constructor(e){let t,r,o=!1;if("object"!=typeof e)throw new Error("configs parameter is required and must be object");if(super(),l.set(this,{writable:!0,value:void 0}),w.set(this,{writable:!0,value:void 0}),m.set(this,{writable:!0,value:void 0}),void 0===e.path&&(e.path=process.cwd()),"string"!=typeof e.name)throw new Error("configs.name is required and must be string");if(void 0!==e.body&&"object"!=typeof e.body)throw new Error("configs.body must be object");if("string"!=typeof e.path)throw new Error("configs.path must be string");void 0!==e.body&&(o=!0),r=u.a.join(e.path,e.name+".json");try{d.a.accessSync(r,d.a.constants.F_OK|d.a.constants.W_OK),t=!0}catch(e){t=!1}if(o){if(t)throw new Error(`${e.name} is already exist`);d.a.writeFileSync(r,JSON.stringify(e.body),{encoding:p,flag:"w"}),s()(this,m,JSON.parse(JSON.stringify(e.body)))}else{if(!t)throw new Error(`${e.name} is not accessible`);s()(this,m,JSON.parse(d.a.readFileSync(r,{encoding:p,flag:"r"})))}s()(this,l,e.name),s()(this,w,r)}get body(){return i()(this,m)?JSON.parse(JSON.stringify(i()(this,m))):void 0}get name(){return i()(this,l)}remove(e={sync:!0}){const t=()=>{const e={name:i()(this,l),body:i()(this,m)};s()(this,m,void 0),s()(this,l,void 0),this.emit("removed",e)};if(e.sync){try{d.a.accessSync(i()(this,w),d.a.constants.F_OK|d.a.constants.W_OK)}catch(e){throw new Error("Storage is not accessible")}return d.a.unlinkSync(i()(this,w)),void t()}return Object(a.promisify)(d.a.access)(i()(this,w),d.a.constants.F_OK|d.a.constants.W_OK).then(()=>Object(a.promisify)(d.a.unlink)(i()(this,w)).then(t,e=>Promise.reject(e)),()=>Promise.reject(new Error("Storage is not accessible")))}update(e,t={sync:!0}){if("function"==typeof e&&(e=e(this.body)),void 0===e||"object"!=typeof e)throw new Error("body parameter is required and must be object/function");const r=()=>{const t={lastBody:i()(this,m),updatedBody:JSON.parse(JSON.stringify(e))};s()(this,m,e),this.emit("updated",t)};if(t.sync){try{d.a.accessSync(i()(this,w),d.a.constants.F_OK|d.a.constants.W_OK)}catch(e){throw new Error("Storage is not accessible")}return d.a.writeFileSync(i()(this,w),JSON.stringify(e),{encoding:p,flag:"w"}),void r()}return Object(a.promisify)(d.a.access)(i()(this,w),d.a.constants.F_OK|d.a.constants.W_OK).then(()=>Object(a.promisify)(d.a.writeFile)(i()(this,w),JSON.stringify(e),{encoding:p,flag:"w"}).then(r,e=>Promise.reject(e)),()=>Promise.reject(new Error("Storage is not accessible")))}}var l=new WeakMap,w=new WeakMap,m=new WeakMap;var g=new WeakMap,v=new WeakMap;function j(e={}){const t=Object.create(null);if("object"!=typeof e)throw new Error("configs parameter must be object");return e=Object.assign({storagePath:process.cwd()},e),t.storages=function(e={path:process.cwd()}){var t=new WeakMap;return new class{constructor(){t.set(this,{writable:!0,value:{}})}get(r){if("string"!=typeof r)throw new Error("name parameter is required and must be string");return void 0!==i()(this,t)[r]?i()(this,t)[r]:(i()(this,t)[r]=new b({name:r,path:e.path}),i()(this,t)[r])}initialize(r,o=Object.create(null)){if("string"!=typeof r)throw new Error("name parameter is required and must be string");if("object"!=typeof o)throw new Error("body parameter must be object");if(void 0!==i()(this,t)[r])throw new Error(`${r} is already exist`);return i()(this,t)[r]=new b({name:r,body:o,path:e.path}),i()(this,t)[r]}remove(e,r={sync:!0}){if(void 0===e||"string"!=typeof e&&!(e instanceof b))throw new Error("storage parameter is required and must be string/Storage");const o=e.name||e;e=i()(this,t)[o];const n=()=>{delete i()(this,t)[o]},s={accessibility:new Error("storage is not accessible"),existence:new Error(`${o} is not exist in list`)};if(r.sync){if("string"!=typeof o)throw s.accessibility;if(void 0===e)throw s.existence;return e.remove(),void n()}return new Promise((t,r)=>{"string"!=typeof o&&r(s.accessibility),void 0===e&&r(s.existence),t(e.remove({sync:!1}).then(n,e=>Promise.reject(e)))})}}}({path:e.storagePath}),t}r.d(t,"default",function(){return j}),r.d(t,"Preference",function(){return O});const O=class extends y.a{constructor(e){let t=!1;if("object"!=typeof e)throw new Error("configs parameter is required and must be object");if("string"!=typeof e.name)throw new Error("configs.name is required and must be string");if(void 0===e.storage||e.storage.constructor.name!==b.name)throw new Error("configs.storage is required and must be Storage");if(void 0===e.storage.body)throw new Error("Storage is not accessible");if(void 0!==e.body&&"object"!=typeof e.body)throw new Error("configs.body must be object");if(super(),g.set(this,{writable:!0,value:void 0}),v.set(this,{writable:!0,value:void 0}),s()(this,g,e.storage),s()(this,v,e.name),e.body&&(t=!0),t){if("object"==typeof i()(this,g).body[i()(this,v)])throw new Error(`${i()(this,v)} is already exist`);i()(this,g).update(t=>(t[i()(this,v)]=e.body,t))}else if("object"!=typeof i()(this,g).body[i()(this,v)])throw new Error(`${i()(this,v)} is not accessible`)}get name(){return i()(this,v)}get body(){if(i()(this,g)&&i()(this,g).body&&i()(this,g).body[i()(this,v)])return JSON.parse(JSON.stringify(i()(this,g).body[i()(this,v)]))}update(e,t={sync:!0}){if("function"==typeof e&&(e=e(this.body)),"object"!=typeof e)throw new Error("body parameter is required and must be object/function");if(void 0===i()(this,g))throw new Error("Preference is not accessible");const r=t=>(t[i()(this,v)]=e,t),o=this.body,n=()=>{const e={lastBody:o,updatedBody:this.body};this.emit("updated",e)};return t.sync?(i()(this,g).update(r),void n()):i()(this,g).update(r,{sync:!1}).then(n,e=>Promise.reject(e))}remove(e={sync:!0}){if(void 0===i()(this,g))throw new Error("Preference is not accessible");const t=e=>(delete e[this.name],e),r=()=>{const e={name:this.name,body:i()(this,g).body[this.name]};s()(this,g,void 0),s()(this,v,void 0),this.emit("removed",e)};return e.sync?(i()(this,g).update(t),void r()):i()(this,g).update(t,{sync:!1}).then(r,e=>Promise.reject(e))}}}])});